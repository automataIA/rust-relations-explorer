<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","dio","knowledge-rs","benches","build_graph.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};\nuse knowledge_rs::graph::KnowledgeGraph;\nuse knowledge_rs::utils::cache::CacheMode;\nuse std::path::Path;\n\nfn bench_build_graph(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"build_graph\");\n\n    // Benchmark different cache modes\n    for mode in [CacheMode::Rebuild, CacheMode::Use, CacheMode::Ignore] {\n        let label = match mode {\n            CacheMode::Rebuild =\u003e \"rebuild\",\n            CacheMode::Use =\u003e \"use_cache\",\n            CacheMode::Ignore =\u003e \"ignore_cache\",\n        };\n        group.bench_function(BenchmarkId::new(\"build_from_directory_with_cache_opts\", label), |b| {\n            b.iter(|| {\n                let root = Path::new(\".\");\n                let graph = KnowledgeGraph::build_from_directory_with_cache_opts(black_box(root), mode, false)\n                    .expect(\"build graph\");\n                // prevent optimizer from discarding\n                black_box(graph.files.len())\n            })\n        });\n    }\n\n    group.finish();\n}\n\ncriterion_group!(name = benches; config = Criterion::default(); targets = bench_build_graph);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","benches","queries.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};\nuse knowledge_rs::graph::KnowledgeGraph;\nuse knowledge_rs::query::{CentralityMetric, ConnectedFilesQuery, HubsQuery, Query, ShortestPathQuery};\nuse knowledge_rs::utils::cache::CacheMode;\nuse std::path::Path;\n\nfn build_graph_once() -\u003e KnowledgeGraph {\n    let root = Path::new(\".\");\n    KnowledgeGraph::build_from_directory_with_cache_opts(root, CacheMode::Use, false)\n        .expect(\"build graph\")\n}\n\nfn bench_queries(c: \u0026mut Criterion) {\n    // Setup outside of iter\n    let graph = build_graph_once();\n\n    let mut group = c.benchmark_group(\"queries\");\n\n    // Heuristic pick: pick two files from the repo for path \u0026 connected benchmarks\n    let mut files: Vec\u003c_\u003e = graph.files.keys().cloned().collect();\n    files.sort();\n    let from = files.get(0).cloned();\n    let to = files.get(1).cloned();\n\n    // Connected files\n    if let Some(sample) = from.clone() {\n        group.bench_function(BenchmarkId::new(\"connected_files\", sample.file_name().and_then(|s| s.to_str()).unwrap_or(\"sample\")), |b| {\n            b.iter(|| {\n                let q = ConnectedFilesQuery { file: sample.clone() };\n                let res = q.run(black_box(\u0026graph));\n                black_box(res.len())\n            })\n        });\n    }\n\n    // Hubs (top 10 by total degree)\n    group.bench_function(BenchmarkId::new(\"hubs\", \"top10_total\"), |b| {\n        b.iter(|| {\n            let q = HubsQuery { metric: CentralityMetric::Total, top: 10 };\n            let res = q.run(black_box(\u0026graph));\n            black_box(res.len())\n        })\n    });\n\n    // Shortest path between two files (if at least two files)\n    if let (Some(a), Some(b)) = (from, to) {\n        group.bench_function(BenchmarkId::new(\"shortest_path\", \"a_to_b\"), |bch| {\n            bch.iter(|| {\n                let q = ShortestPathQuery { from: a.clone(), to: b.clone() };\n                let res = q.run(black_box(\u0026graph));\n                black_box(res.len())\n            })\n        });\n    }\n\n    group.finish();\n}\n\ncriterion_group!(name = benches; config = Criterion::default(); targets = bench_queries);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","examples","basic_build.rs"],"content":"use knowledge_rs::graph::KnowledgeGraph;\nuse knowledge_rs::utils::cache::CacheMode;\n\nfn main() {\n    let root = std::path::Path::new(\".\");\n    let no_ignore = false; // set true to include ignored files\n    let graph = KnowledgeGraph::build_from_directory_with_cache_opts(root, CacheMode::Use, no_ignore)\n        .expect(\"build graph\");\n    println!(\n        \"Built graph: files={}, relationships={}\",\n        graph.files.len(),\n        graph.relationships.len()\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","examples","generate_svg.rs"],"content":"use knowledge_rs::graph::KnowledgeGraph;\nuse knowledge_rs::utils::cache::CacheMode;\nuse knowledge_rs::visualization::{DotGenerator, DotOptions, EdgeStyle, RankDir, SvgGenerator, SvgOptions, DotTheme};\n\nfn main() {\n    let root = std::path::Path::new(\".\");\n    let graph = KnowledgeGraph::build_from_directory_with_cache_opts(root, CacheMode::Use, false)\n        .expect(\"build graph\");\n\n    // Generate DOT with options\n    let dot_opts = DotOptions { clusters: true, legend: true, theme: DotTheme::Light, rankdir: RankDir::LR, splines: EdgeStyle::Curved, rounded: true };\n    let dot = DotGenerator::new().generate_dot_with_options(\u0026graph, dot_opts).expect(\"dot\");\n    std::fs::write(\"graph.dot\", dot).expect(\"write dot\");\n\n    // Generate SVG (requires `dot` from Graphviz on PATH)\n    let svg_opts = SvgOptions { dot: dot_opts, interactive: true };\n    match SvgGenerator::new().generate_svg_with_options(\u0026graph, svg_opts) {\n        Ok(svg) =\u003e {\n            std::fs::write(\"graph.svg\", svg).expect(\"write svg\");\n            println!(\"Wrote graph.svg\");\n        }\n        Err(e) =\u003e {\n            eprintln!(\"SVG generation failed: {}\\nHint: ensure Graphviz 'dot' is installed and on PATH.\", e);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","examples","generate_synthetic.rs"],"content":"use std::env;\nuse std::fs;\nuse std::io::Write;\nuse std::path::PathBuf;\n\n// Generate a synthetic Rust project with many small files to benchmark build speed.\n// Usage:\n//   cargo run --example generate_synthetic -- \u003croot\u003e \u003cfiles\u003e\n// Example:\n//   cargo run --example generate_synthetic -- /tmp/kr_synth 10000\nfn main() {\n    let args: Vec\u003cString\u003e = env::args().collect();\n    if args.len() != 3 {\n        eprintln!(\"Usage: {} \u003croot\u003e \u003cfiles\u003e\", args.get(0).map(String::as_str).unwrap_or(\"generate_synthetic\"));\n        std::process::exit(2);\n    }\n    let root = PathBuf::from(\u0026args[1]);\n    let n: usize = args[2].parse().expect(\"files must be a number\");\n\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).expect(\"create src\");\n\n    // Write lib.rs that mods chunks to keep module tree shallow-ish\n    let mut lib = String::new();\n    lib.push_str(\"// synthetic project generated for benchmarking\\n\");\n    lib.push_str(\"pub fn root() {}\\n\");\n\n    for i in 0..n {\n        lib.push_str(\u0026format!(\"pub mod f{};\\n\", i));\n    }\n    fs::write(src.join(\"lib.rs\"), lib).expect(\"write lib.rs\");\n\n    // Each file defines one function and calls previous one to create a chain of calls\n    for i in 0..n {\n        let path = src.join(format!(\"f{}.rs\", i));\n        let mut file = fs::File::create(\u0026path).expect(\"create file\");\n        if i == 0 {\n            writeln!(file, \"pub fn f0() {{}} \").unwrap();\n        } else {\n            writeln!(file, \"use crate::f{}::f{};\", i - 1, i - 1).unwrap();\n            writeln!(file, \"pub fn f{}() {{ f{}(); }}\", i, i - 1).unwrap();\n        }\n    }\n\n    println!(\"Generated synthetic project at {} with {} files\", root.display(), n);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","examples","query_connected.rs"],"content":"use knowledge_rs::graph::{ItemId, KnowledgeGraph};\nuse knowledge_rs::utils::cache::CacheMode;\n\nfn main() {\n    let root = std::path::Path::new(\".\");\n    let graph = KnowledgeGraph::build_from_directory_with_cache_opts(root, CacheMode::Use, false)\n        .expect(\"build graph\");\n\n    // Pick a file like src/lib.rs if it exists; otherwise, print the first file.\n    let target = std::path::Path::new(\"src/lib.rs\");\n    let file = if graph.files.contains_key(target) {\n        target\n    } else if let Some(first) = graph.files.keys().next() {\n        first.as_path()\n    } else {\n        eprintln!(\"No files in graph\");\n        return;\n    };\n\n    // Build an index from ItemId -\u003e owning file\n    let mut owner: std::collections::HashMap\u003cItemId, std::path::PathBuf\u003e = std::collections::HashMap::new();\n    for (path, node) in \u0026graph.files {\n        for it in \u0026node.items {\n            owner.insert(it.id.clone(), path.clone());\n        }\n    }\n\n    // List files that have direct relationships with any item in the target file\n    let mut related = std::collections::BTreeSet::new();\n    for rel in \u0026graph.relationships {\n        let from_file = owner.get(\u0026rel.from_item);\n        let to_file = owner.get(\u0026rel.to_item);\n        match (from_file, to_file) {\n            (Some(f), Some(t)) =\u003e {\n                if f == file \u0026\u0026 t != file {\n                    related.insert(t.clone());\n                } else if t == file \u0026\u0026 f != file {\n                    related.insert(f.clone());\n                }\n            }\n            _ =\u003e {}\n        }\n    }\n\n    println!(\"Connected files to {}:\", file.display());\n    for f in related {\n        println!(\"- {}\", f.display());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","src","cli","mod.rs"],"content":"use clap::{Parser, Subcommand};\n\n#[derive(Debug, Parser)]\n#[command(\n    name = \"knowledge-rs\",\n    version,\n    about = \"Rust Knowledge Graph System\",\n    long_about = \"Parse Rust projects into a knowledge graph and run queries. File discovery respects .gitignore and .ignore with parent traversal. Global git excludes are disabled for determinism. Use --no-ignore to bypass ignore rules.\"\n)] \npub struct Cli {\n    #[command(subcommand)]\n    pub command: Commands,\n}\n\n#[derive(Debug, Subcommand)]\npub enum Commands {\n    /// Build the knowledge graph from a source directory\n    Build {\n        /// Path to the Rust project root (directory containing src/)\n        #[arg(short, long, default_value = \".\")] \n        path: String,\n        /// Path to a TOML configuration file\n        #[arg(long)]\n        config: Option\u003cString\u003e,\n        /// Bypass ignore rules (.gitignore/.ignore) when discovering files\n        #[arg(long, default_value_t = false, help = \"Include files even if matched by .gitignore/.ignore. Global git excludes are always disabled for determinism.\")]\n        no_ignore: bool,\n        /// Ignore cache when building (do not reuse cached files)\n        #[arg(long, default_value_t = false)]\n        no_cache: bool,\n        /// Rebuild cache from scratch (clears previous cache)\n        #[arg(long, default_value_t = false)]\n        rebuild: bool,\n        /// Output JSON file path\n        #[arg(long)]\n        json: Option\u003cString\u003e,\n        /// Output DOT file path\n        #[arg(long)]\n        dot: Option\u003cString\u003e,\n        /// Output SVG file path\n        #[arg(long)]\n        svg: Option\u003cString\u003e,\n        /// DOT: enable/disable hierarchical clusters (default: on)\n        #[arg(long, value_parser = [\"on\", \"off\"], default_value = \"on\")]\n        dot_clusters: String,\n        /// DOT: include legend (default: on)\n        #[arg(long, value_parser = [\"on\", \"off\"], default_value = \"on\")]\n        dot_legend: String,\n        /// DOT: theme (light or dark)\n        #[arg(long, value_parser = [\"light\", \"dark\"], default_value = \"light\")]\n        dot_theme: String,\n        /// DOT: rank direction (LR or TB)\n        #[arg(long, value_parser = [\"LR\", \"TB\"], default_value = \"LR\")]\n        dot_rankdir: String,\n        /// DOT: edge splines style (curved, ortho, polyline)\n        #[arg(long, value_parser = [\"curved\", \"ortho\", \"polyline\"], default_value = \"curved\")]\n        dot_splines: String,\n        /// DOT: rounded node corners (on/off)\n        #[arg(long, value_parser = [\"on\", \"off\"], default_value = \"on\")]\n        dot_rounded: String,\n        /// SVG: add interactive enhancements (on/off)\n        #[arg(long, value_parser = [\"on\", \"off\"], default_value = \"on\")]\n        svg_interactive: String,\n        /// Save built graph to JSON file path\n        #[arg(long)]\n        save: Option\u003cString\u003e,\n    },\n    /// Run queries over the knowledge graph\n    Query {\n        #[command(subcommand)]\n        query: QueryCommands,\n    },\n    \n}\n\n#[derive(Debug, Subcommand)]\npub enum QueryCommands {\n    /// List files connected to the given file via relationships\n    ConnectedFiles {\n        /// Path to project root (directory containing src/)\n        #[arg(short, long, default_value = \".\")] \n        path: String,\n        /// Path to a TOML configuration file\n        #[arg(long)]\n        config: Option\u003cString\u003e,\n        /// Bypass ignore rules (.gitignore/.ignore) when discovering files\n        #[arg(long, default_value_t = false, help = \"Include files even if matched by .gitignore/.ignore. Global git excludes are always disabled for determinism.\")]\n        no_ignore: bool,\n        /// The file to analyze (absolute or relative)\n        #[arg(long)]\n        file: String,\n        /// Optional path to a prebuilt graph JSON (skips rebuild)\n        #[arg(long)]\n        graph: Option\u003cString\u003e,\n        /// Output format: text or json\n        #[arg(long, value_parser = [\"text\", \"json\"], default_value = \"text\")]\n        format: String,\n    },\n    /// List files that call or are called by a given function name\n    FunctionUsage {\n        /// Path to project root (directory containing src/)\n        #[arg(short, long, default_value = \".\")] \n        path: String,\n        /// Path to a TOML configuration file\n        #[arg(long)]\n        config: Option\u003cString\u003e,\n        /// Bypass ignore rules (.gitignore/.ignore) when discovering files\n        #[arg(long, default_value_t = false)]\n        no_ignore: bool,\n        /// Function name to analyze\n        #[arg(long)]\n        function: String,\n        /// Direction: callers or callees\n        #[arg(long, value_parser = [\"callers\", \"callees\"], default_value = \"callers\")]\n        direction: String,\n        /// Optional path to a prebuilt graph JSON (skips rebuild)\n        #[arg(long)]\n        graph: Option\u003cString\u003e,\n        /// Output format: text or json\n        #[arg(long, value_parser = [\"text\", \"json\"], default_value = \"text\")]\n        format: String,\n    },\n    /// Detect cycles between files\n    Cycles {\n        /// Path to project root (directory containing src/)\n        #[arg(short, long, default_value = \".\")] \n        path: String,\n        /// Path to a TOML configuration file\n        #[arg(long)]\n        config: Option\u003cString\u003e,\n        /// Bypass ignore rules (.gitignore/.ignore) when discovering files\n        #[arg(long, default_value_t = false)]\n        no_ignore: bool,\n        /// Optional path to a prebuilt graph JSON (skips rebuild)\n        #[arg(long)]\n        graph: Option\u003cString\u003e,\n        /// Output format: text or json\n        #[arg(long, value_parser = [\"text\", \"json\"], default_value = \"text\")]\n        format: String,\n    },\n    /// Compute shortest path between two files\n    Path {\n        /// Path to project root (directory containing src/)\n        #[arg(short, long, default_value = \".\")] \n        path: String,\n        /// Path to a TOML configuration file\n        #[arg(long)]\n        config: Option\u003cString\u003e,\n        /// Bypass ignore rules (.gitignore/.ignore) when discovering files\n        #[arg(long, default_value_t = false)]\n        no_ignore: bool,\n        /// Source file path\n        #[arg(long)]\n        from: String,\n        /// Destination file path\n        #[arg(long)]\n        to: String,\n        /// Optional path to a prebuilt graph JSON (skips rebuild)\n        #[arg(long)]\n        graph: Option\u003cString\u003e,\n        /// Output format: text or json\n        #[arg(long, value_parser = [\"text\", \"json\"], default_value = \"text\")]\n        format: String,\n    },\n    /// List top-N hub files by degree centrality\n    Hubs {\n        /// Path to project root (directory containing src/)\n        #[arg(short, long, default_value = \".\")] \n        path: String,\n        /// Path to a TOML configuration file\n        #[arg(long)]\n        config: Option\u003cString\u003e,\n        /// Bypass ignore rules (.gitignore/.ignore) when discovering files\n        #[arg(long, default_value_t = false)]\n        no_ignore: bool,\n        /// Optional path to a prebuilt graph JSON (skips rebuild)\n        #[arg(long)]\n        graph: Option\u003cString\u003e,\n        /// Metric: in, out, total\n        #[arg(long, value_parser = [\"in\", \"out\", \"total\"], default_value = \"total\")]\n        metric: String,\n        /// Top N results\n        #[arg(long, default_value_t = 10)]\n        top: usize,\n        /// Output format: text or json\n        #[arg(long, value_parser = [\"text\", \"json\"], default_value = \"text\")]\n        format: String,\n    },\n    /// List top-N modules (directories) by degree centrality\n    ModuleCentrality {\n        /// Path to project root (directory containing src/)\n        #[arg(short, long, default_value = \".\")] \n        path: String,\n        /// Path to a TOML configuration file\n        #[arg(long)]\n        config: Option\u003cString\u003e,\n        /// Bypass ignore rules (.gitignore/.ignore) when discovering files\n        #[arg(long, default_value_t = false)]\n        no_ignore: bool,\n        /// Optional path to a prebuilt graph JSON (skips rebuild)\n        #[arg(long)]\n        graph: Option\u003cString\u003e,\n        /// Metric: in, out, total\n        #[arg(long, value_parser = [\"in\", \"out\", \"total\"], default_value = \"total\")]\n        metric: String,\n        /// Top N results\n        #[arg(long, default_value_t = 10)]\n        top: usize,\n        /// Output format: text or json\n        #[arg(long, value_parser = [\"text\", \"json\"], default_value = \"text\")]\n        format: String,\n    },\n    /// List types implementing a trait\n    TraitImpls {\n        /// Path to project root (directory containing src/)\n        #[arg(short, long, default_value = \".\")] \n        path: String,\n        /// Path to a TOML configuration file\n        #[arg(long)]\n        config: Option\u003cString\u003e,\n        /// Bypass ignore rules (.gitignore/.ignore) when discovering files\n        #[arg(long, default_value_t = false)]\n        no_ignore: bool,\n        /// Trait name (e.g., Display)\n        #[arg(long, value_name = \"NAME\")]\n        r#trait: String,\n        /// Optional path to a prebuilt graph JSON (skips rebuild)\n        #[arg(long)]\n        graph: Option\u003cString\u003e,\n        /// Output format: text or json\n        #[arg(long, value_parser = [\"text\", \"json\"], default_value = \"text\")]\n        format: String,\n    },\n}\n\npub fn parse() -\u003e Cli {\n    Cli::parse()\n}\n","traces":[{"line":236,"address":[7029328],"length":1,"stats":{"Line":0}},{"line":237,"address":[7029336],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","dio","knowledge-rs","src","errors.rs"],"content":"use std::path::PathBuf;\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum ParseError {\n    #[error(\"Regex match failed: {0}\")]\n    Regex(String),\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n    #[error(\"Invalid UTF-8 in file {file}\")]\n    InvalidUtf8 { file: PathBuf },\n}\n\n#[derive(Debug, Error)]\npub enum KnowledgeGraphError {\n    #[error(\"Parse error in file {file}: {source}\")]\n    ParseError { file: PathBuf, source: ParseError },\n\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"Invalid query: {0}\")]\n    Query(String),\n\n    #[error(\"Visualization error: {0}\")]\n    Visualization(String),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","src","graph","mod.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::PathBuf;\nuse regex::Regex;\nuse rayon::prelude::*;\nuse crate::utils::cache;\n\npub mod resolver;\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Hash)]\npub struct ItemId(pub String);\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Location {\n    pub file: PathBuf,\n    pub line_start: usize,\n    pub line_end: usize,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ItemType {\n    Module { is_inline: bool },\n    Function { is_async: bool, is_const: bool },\n    Struct { is_tuple: bool },\n    Enum { variant_count: usize },\n    Trait { is_object_safe: bool },\n    Impl { trait_name: Option\u003cString\u003e, type_name: String },\n    Const,\n    Static { is_mut: bool },\n    Type,\n    Macro,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum Visibility {\n    Public,\n    Private,\n    PubCrate,\n    PubSuper,\n    PubIn(String),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Item {\n    pub id: ItemId,\n    pub item_type: ItemType,\n    pub name: String,\n    pub visibility: Visibility,\n    pub location: Location,\n    pub attributes: Vec\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Import {\n    pub path: String,\n    pub alias: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum RelationshipType {\n    Uses { import_type: String },\n    Implements { trait_name: String },\n    Contains { containment_type: String },\n    Extends { extension_type: String },\n    Calls { call_type: String },\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Relationship {\n    pub from_item: ItemId,\n    pub to_item: ItemId,\n    pub relationship_type: RelationshipType,\n    pub strength: f64,\n    pub context: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct FileMetrics {\n    pub item_count: usize,\n    pub import_count: usize,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct FileNode {\n    pub path: PathBuf,\n    pub items: Vec\u003cItem\u003e,\n    pub imports: Vec\u003cImport\u003e,\n    pub metrics: FileMetrics,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct GraphMetadata {\n    pub generated_at: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct KnowledgeGraph {\n    pub files: HashMap\u003cPathBuf, FileNode\u003e,\n    pub relationships: Vec\u003cRelationship\u003e,\n    pub metadata: GraphMetadata,\n    // Module hierarchy tracking: parent and children maps keyed by file paths\n    pub module_parent: HashMap\u003cPathBuf, PathBuf\u003e,\n    pub module_children: HashMap\u003cPathBuf, Vec\u003cPathBuf\u003e\u003e,\n}\n\nimpl KnowledgeGraph {\n    /// Build a knowledge graph from a directory with explicit cache mode and ignore behavior.\n    ///\n    /// Arguments:\n    /// - `path`: Root directory to scan for Rust source files.\n    /// - `mode`: Cache usage policy (see `utils::cache::CacheMode`).\n    /// - `no_ignore`: When true, bypasses `.gitignore`/`.ignore` rules in file discovery.\n    ///\n    /// Returns a fully built `KnowledgeGraph`, loading from and/or updating the on-disk cache\n    /// according to `mode`. File discovery is performed via `utils::file_walker::rust_files_with_options`.\n    pub fn build_from_directory_with_cache_opts(\n        path: \u0026std::path::Path,\n        mode: cache::CacheMode,\n        no_ignore: bool,\n    ) -\u003e Result\u003cSelf, crate::errors::KnowledgeGraphError\u003e {\n        use crate::parser::RustParser;\n        use crate::utils::file_walker;\n        use std::fs;\n        use crate::errors::KnowledgeGraphError;\n\n        let files = file_walker::rust_files_with_options(path.to_string_lossy().as_ref(), no_ignore);\n\n        // Load or ignore cache based on mode\n        let root_dir = path.to_path_buf();\n        let mut cache_state = match mode {\n            cache::CacheMode::Use =\u003e cache::load_cache(\u0026root_dir).unwrap_or_default(),\n            cache::CacheMode::Ignore | cache::CacheMode::Rebuild =\u003e Default::default(),\n        };\n\n        // Collect file metadata for change detection\n        let infos: Vec\u003c(String, cache::CacheEntryMeta)\u003e = files\n            .iter()\n            .map(|f| {\n                let p = std::path::Path::new(f);\n                let meta = fs::metadata(p).ok();\n                let len = meta.as_ref().and_then(|m| m.len().try_into().ok()).unwrap_or(0u64);\n                let mtime = meta\n                    .and_then(|m| m.modified().ok())\n                    .and_then(|t| t.duration_since(std::time::UNIX_EPOCH).ok())\n                    .map(|d| d.as_secs())\n                    .unwrap_or(0u64);\n                (f.clone(), cache::CacheEntryMeta { mtime, len })\n            })\n            .collect();\n\n        // Prune cache entries for files that no longer exist in the walk\n        if matches!(mode, cache::CacheMode::Use) {\n            use std::collections::HashSet;\n            let present: HashSet\u003cPathBuf\u003e = files.iter().map(|f| std::path::Path::new(f).to_path_buf()).collect();\n            cache_state.entries.retain(|k, _| present.contains(k));\n        }\n\n    \n\n    \n\n        // Reuse from cache when metadata matches (only in Use mode)\n        let mut reused: Vec\u003c(PathBuf, FileNode, Vec\u003cRelationship\u003e)\u003e = Vec::new();\n        let mut to_parse: Vec\u003c(String, cache::CacheEntryMeta)\u003e = Vec::new();\n        for (file, meta) in \u0026infos {\n            let key = std::path::Path::new(file).to_path_buf();\n            if matches!(mode, cache::CacheMode::Use) {\n                if let Some(entry) = cache_state.entries.get(\u0026key) {\n                    if entry.meta == *meta {\n                        let node = entry.node.clone();\n                        // Rebuild contains edges for cached node\n                        let file_id = ItemId(format!(\"file:{}\", node.path.display()));\n                        let mut edges = Vec::new();\n                        for it in node.items.iter().skip(1) {\n                            edges.push(Relationship {\n                                from_item: file_id.clone(),\n                                to_item: it.id.clone(),\n                                relationship_type: RelationshipType::Contains { containment_type: \"file_contains\".to_string() },\n                                strength: 1.0,\n                                context: \"auto\".to_string(),\n                            });\n                        }\n                        reused.push((node.path.clone(), node, edges));\n                        continue;\n                    }\n                }\n            }\n            to_parse.push((file.clone(), meta.clone()));\n        }\n\n        // Parse files in parallel. Each task returns (path, node, contains_edges)\n        let parsed: Result\u003cVec\u003c(PathBuf, FileNode, Vec\u003cRelationship\u003e, cache::CacheEntry)\u003e, KnowledgeGraphError\u003e = to_parse\n            .into_par_iter()\n            .map(|file| {\n                let (file, meta) = file;\n                let content = fs::read_to_string(\u0026file).map_err(KnowledgeGraphError::Io)?;\n                let p = std::path::Path::new(\u0026file).to_path_buf();\n                let mut node = RustParser::new()\n                    .parse_file(\u0026content, \u0026p)\n                    .map_err(|source| KnowledgeGraphError::ParseError { file: p.clone(), source })?;\n\n                // Create a synthetic file-level module item\n                let file_id = ItemId(format!(\"file:{}\", node.path.display()));\n                let file_item = Item {\n                    id: file_id.clone(),\n                    item_type: ItemType::Module { is_inline: false },\n                    name: node\n                        .path\n                        .file_stem()\n                        .and_then(|s| s.to_str())\n                        .unwrap_or(\"(file)\")\n                        .to_string(),\n                    visibility: Visibility::PubCrate,\n                    location: Location { file: node.path.clone(), line_start: 1, line_end: 1 },\n                    attributes: vec![],\n                };\n\n                // Prepend the file item\n                let mut items_with_file = Vec::with_capacity(node.items.len() + 1);\n                items_with_file.push(file_item);\n                items_with_file.extend(node.items.into_iter());\n                node.metrics.item_count = items_with_file.len();\n                node.items = items_with_file;\n\n                // Build Contains relationships from file item to each other item\n                let mut contains_edges: Vec\u003cRelationship\u003e = Vec::new();\n                for it in node.items.iter().skip(1) {\n                    contains_edges.push(Relationship {\n                        from_item: file_id.clone(),\n                        to_item: it.id.clone(),\n                        relationship_type: RelationshipType::Contains { containment_type: \"file_contains\".to_string() },\n                        strength: 1.0,\n                        context: \"auto\".to_string(),\n                    });\n                }\n\n                let cache_entry = cache::CacheEntry { meta, node: node.clone() };\n                Ok::\u003c_, KnowledgeGraphError\u003e((node.path.clone(), node, contains_edges, cache_entry))\n            })\n            .collect();\n\n        let mut graph = KnowledgeGraph::default();\n        // Insert reused nodes\n        for (path, node, edges) in reused {\n            graph.files.insert(path, node);\n            graph.relationships.extend(edges);\n        }\n        // Insert newly parsed nodes and update cache\n        for (path, node, edges, cache_entry) in parsed? {\n            graph.files.insert(path, node);\n            graph.relationships.extend(edges);\n            cache_state.entries.insert(cache_entry.node.path.clone(), cache_entry);\n        }\n\n        // Set generation timestamp (seconds since epoch) without extra deps\n        graph.metadata.generated_at = match std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n        {\n            Ok(d) =\u003e format!(\"{}\", d.as_secs()),\n            Err(_) =\u003e \"0\".to_string(),\n        };\n        // Analyze relationships beyond file containment\n        graph.analyze_relationships();\n\n        // Save cache (best-effort). Even in Ignore/Rebuild, we save freshly parsed state.\n        cache::save_cache(\u0026root_dir, \u0026cache_state);\n        Ok(graph)\n    }\n\n    // Module hierarchy helpers\n    pub fn get_module_parent(\u0026self, file: \u0026PathBuf) -\u003e Option\u003c\u0026PathBuf\u003e {\n        self.module_parent.get(file)\n    }\n\n    pub fn get_module_children(\u0026self, file: \u0026PathBuf) -\u003e \u0026[PathBuf] {\n        match self.module_children.get(file) {\n            Some(v) =\u003e v.as_slice(),\n            None =\u003e \u0026[],\n        }\n    }\n    /// Backward-compatible builder: reads env var `KNOWLEDGE_RS_NO_IGNORE` for ignore bypass.\n    pub fn build_from_directory_with_cache(path: \u0026std::path::Path, mode: cache::CacheMode) -\u003e Result\u003cSelf, crate::errors::KnowledgeGraphError\u003e {\n        let no_ignore = std::env::var(\"KNOWLEDGE_RS_NO_IGNORE\")\n            .map(|v| v == \"1\" || v.eq_ignore_ascii_case(\"true\"))\n            .unwrap_or(false);\n        Self::build_from_directory_with_cache_opts(path, mode, no_ignore)\n    }\n\n    /// Backward-compatible builder: `CacheMode::Use` and env-derived ignore bypass.\n    pub fn build_from_directory(path: \u0026std::path::Path) -\u003e Result\u003cSelf, crate::errors::KnowledgeGraphError\u003e {\n        let no_ignore = std::env::var(\"KNOWLEDGE_RS_NO_IGNORE\")\n            .map(|v| v == \"1\" || v.eq_ignore_ascii_case(\"true\"))\n            .unwrap_or(false);\n        Self::build_from_directory_with_cache_opts(path, cache::CacheMode::Use, no_ignore)\n    }\n\n    /// Convenience builder: explicit ignore bypass with default `CacheMode::Use`.\n    pub fn build_from_directory_opts(path: \u0026std::path::Path, no_ignore: bool) -\u003e Result\u003cSelf, crate::errors::KnowledgeGraphError\u003e {\n        Self::build_from_directory_with_cache_opts(path, cache::CacheMode::Use, no_ignore)\n    }\n\n    pub fn save_json(\u0026self, path: \u0026std::path::Path) -\u003e Result\u003c(), crate::errors::KnowledgeGraphError\u003e {\n        let data = serde_json::to_string_pretty(self).map_err(|e| {\n            crate::errors::KnowledgeGraphError::Io(std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))\n        })?;\n        std::fs::write(path, data)?;\n        Ok(())\n    }\n\n    pub fn load_json(path: \u0026std::path::Path) -\u003e Result\u003cSelf, crate::errors::KnowledgeGraphError\u003e {\n        let data = std::fs::read_to_string(path)?;\n        let graph: KnowledgeGraph = serde_json::from_str(\u0026data).map_err(|e| {\n            crate::errors::KnowledgeGraphError::Io(std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))\n        })?;\n        Ok(graph)\n    }\n\n    \n}\n\nimpl KnowledgeGraph {\n    fn analyze_relationships(\u0026mut self) {\n        self.analyze_module_hierarchy();\n        self.analyze_import_uses();\n        self.analyze_calls_heuristic();\n    }\n\n    // Establish module hierarchy using filesystem layout.\n    // For every file-level synthetic module item, link its parent module (if present) with a Contains edge.\n    fn analyze_module_hierarchy(\u0026mut self) {\n        // Reset hierarchy maps to avoid stale entries on re-analysis\n        self.module_parent.clear();\n        self.module_children.clear();\n        // Helper to get file-level item id (first item) for a given path\n        let mut file_level_id: HashMap\u003cPathBuf, ItemId\u003e = HashMap::new();\n        for (p, f) in \u0026self.files {\n            if let Some(it) = f.items.first() {\n                file_level_id.insert(p.clone(), it.id.clone());\n            }\n        }\n\n        // For each file, determine its parent module file and add Contains edge\n        for (path, _file) in self.files.clone().into_iter() {\n            // Skip if we can't find this file's synthetic id\n            let Some(child_id) = file_level_id.get(\u0026path) else { continue; };\n\n            // Determine parent file candidate based on path structure\n            let parent_dir = match path.parent() { Some(d) =\u003e d.to_path_buf(), None =\u003e continue };\n            let file_name = path.file_name().and_then(|s| s.to_str()).unwrap_or(\"\");\n\n            // If current file is mod.rs or lib.rs, parent is parent's parent dir's mod.rs or lib.rs\n            let parent_candidates: Vec\u003cPathBuf\u003e = if file_name == \"mod.rs\" || file_name == \"lib.rs\" {\n                let grand = parent_dir.parent().map(|p| p.to_path_buf());\n                match grand {\n                    Some(g) =\u003e vec![g.join(\"mod.rs\"), g.join(\"lib.rs\")],\n                    None =\u003e Vec::new(),\n                }\n            } else {\n                // foo.rs -\u003e parent is current dir's mod.rs or lib.rs\n                vec![parent_dir.join(\"mod.rs\"), parent_dir.join(\"lib.rs\")]\n            };\n\n            // Find first existing parent in graph\n            let mut parent_id_opt: Option\u003cItemId\u003e = None;\n            for cand in parent_candidates {\n                if let Some(pid) = file_level_id.get(\u0026cand) {\n                    parent_id_opt = Some(pid.clone());\n                    break;\n                }\n            }\n\n            if let Some(parent_id) = parent_id_opt {\n                if parent_id != *child_id {\n                    // Relationship edge\n                    self.relationships.push(Relationship {\n                        from_item: parent_id.clone(),\n                        to_item: child_id.clone(),\n                        relationship_type: RelationshipType::Contains { containment_type: \"module_contains\".to_string() },\n                        strength: 1.0,\n                        context: \"fs\".to_string(),\n                    });\n                    // Hierarchy maps\n                    // Resolve actual parent path from id -\u003e file map\n                    let parent_path = self\n                        .files\n                        .keys()\n                        .find(|p| if let Some(fid) = file_level_id.get(*p) { fid == \u0026parent_id } else { false })\n                        .cloned();\n                    if let Some(pp) = parent_path {\n                        self.module_parent.insert(path.clone(), pp.clone());\n                        self.module_children.entry(pp).or_default().push(path.clone());\n                    }\n                }\n            }\n        }\n    }\n\n    fn analyze_import_uses(\u0026mut self) {\n        // Build edges using a Resolver in a separate scope to avoid \u0026mut self conflicts\n        let mut new_edges: Vec\u003cRelationship\u003e = Vec::new();\n        {\n            let res = resolver::Resolver::new(\u0026self);\n            for (path, file) in \u0026self.files {\n                if file.items.is_empty() { continue; }\n                let file_id = file.items[0].id.clone();\n                for imp in \u0026file.imports {\n                    let targets = res.resolve_import(path, \u0026imp.path);\n                    if targets.is_empty() { continue; }\n                    for to in targets {\n                        if to == file_id { continue; }\n                        // Prefer module when the resolved target is the synthetic file-level module; else item\n                        let import_type = if res.is_file_level_module(\u0026to) { \"import-module\" } else { \"import-item\" };\n                        new_edges.push(Relationship {\n                            from_item: file_id.clone(),\n                            to_item: to,\n                            relationship_type: RelationshipType::Uses { import_type: import_type.to_string() },\n                            strength: if import_type == \"import-item\" { 1.0 } else { 0.8 },\n                            context: imp.path.clone(),\n                        });\n                    }\n                }\n            }\n        }\n        self.relationships.extend(new_edges);\n    }\n\n    fn analyze_calls_heuristic(\u0026mut self) {\n        // Regex for fully qualified paths like a::b::foo(...)\n        let path_call_re = Regex::new(r\"\\b([A-Za-z_][A-Za-z0-9_]*(?:::[A-Za-z_][A-Za-z0-9_]*)+)\\s*\\(\").unwrap();\n        // Regex for simple names: foo(...)\n        let simple_call_re = Regex::new(r\"\\b([A-Za-z_][A-Za-z0-9_]*)\\s*\\(\").unwrap();\n\n        // Build index of function name -\u003e list of ItemIds that are functions\n        let mut func_index: HashMap\u003cString, Vec\u003cItemId\u003e\u003e = HashMap::new();\n        for file in self.files.values() {\n            for item in \u0026file.items {\n                if let ItemType::Function { .. } = item.item_type {\n                    func_index.entry(item.name.clone()).or_default().push(item.id.clone());\n                }\n            }\n        }\n\n        // Dedup set of created edges (from,to)\n        let mut seen: std::collections::HashSet\u003c(String, String)\u003e = std::collections::HashSet::new();\n        let mut new_edges: Vec\u003cRelationship\u003e = Vec::new();\n\n        for (path, file) in \u0026self.files {\n            if file.items.is_empty() { continue; }\n            let file_id = file.items[0].id.clone();\n            if let Ok(content) = std::fs::read_to_string(path) {\n                // 1) Resolve fully qualified calls via Resolver (more precise)\n                let res = resolver::Resolver::new(\u0026self);\n                for cap in path_call_re.captures_iter(\u0026content) {\n                    let full = cap.get(1).map(|m| m.as_str()).unwrap_or(\"\");\n                    let mut targets = res.resolve_import(path, full);\n                    // Fallback: if resolution fails, try last segment as function name\n                    if targets.is_empty() {\n                        if let Some(last) = full.rsplit(\"::\").next() {\n                            if let Some(funcs) = func_index.get(last) {\n                                targets = funcs.clone();\n                            }\n                        }\n                    }\n                    for to in targets {\n                        let key = (file_id.0.clone(), to.0.clone());\n                        if seen.insert(key) {\n                            new_edges.push(Relationship {\n                                from_item: file_id.clone(),\n                                to_item: to.clone(),\n                                relationship_type: RelationshipType::Calls { call_type: \"path\".to_string() },\n                                strength: 0.7,\n                                context: full.to_string(),\n                            });\n                        }\n                    }\n                }\n\n                // 2) Fallback simple name calls, filtering out definitions/macros and keywords\n                for cap in simple_call_re.captures_iter(\u0026content) {\n                    let m = match cap.get(0) { Some(m) =\u003e m, None =\u003e continue };\n                    let name = cap.get(1).map(|m| m.as_str()).unwrap_or(\"\");\n                    // Skip if preceding few chars suggest a definition like `fn name(` or macro `name!(`\n                    let start = m.start();\n                    let prefix = \u0026content[start.saturating_sub(8)..start];\n                    if prefix.contains(\"fn \") || prefix.contains(\"struct \") || prefix.contains(\"enum \") || prefix.contains(\"trait \") {\n                        continue;\n                    }\n                    // Skip macro invocations `name!(` by checking previous non-space char\n                    if start \u003e 0 {\n                        let prev = content[..start].chars().rev().find(|c| !c.is_whitespace());\n                        if let Some('!') = prev { continue; }\n                    }\n                    if let Some(targets) = func_index.get(name) {\n                        for to in targets {\n                            let key = (file_id.0.clone(), to.0.clone());\n                            if seen.insert(key) {\n                                new_edges.push(Relationship {\n                                    from_item: file_id.clone(),\n                                    to_item: to.clone(),\n                                    relationship_type: RelationshipType::Calls { call_type: \"heuristic\".to_string() },\n                                    strength: 0.5,\n                                    context: name.to_string(),\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        self.relationships.extend(new_edges);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[test]\n    fn module_hierarchy_basic() {\n        // Files: src/lib.rs (parent of src/a/mod.rs); src/a/mod.rs (parent of src/a/foo.rs)\n        let mut g = KnowledgeGraph::default();\n        let lib = PathBuf::from(\"src/lib.rs\");\n        let a_mod = PathBuf::from(\"src/a/mod.rs\");\n        let a_foo = PathBuf::from(\"src/a/foo.rs\");\n\n        let make_file_item = |p: \u0026PathBuf| Item {\n            id: ItemId(format!(\"file:{}\", p.display())),\n            item_type: ItemType::Module { is_inline: false },\n            name: p.file_stem().and_then(|s| s.to_str()).unwrap_or(\"(file)\").to_string(),\n            visibility: Visibility::PubCrate,\n            location: Location { file: p.clone(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        };\n\n        g.files.insert(lib.clone(), FileNode { path: lib.clone(), items: vec![make_file_item(\u0026lib)], imports: vec![], metrics: Default::default() });\n        g.files.insert(a_mod.clone(), FileNode { path: a_mod.clone(), items: vec![make_file_item(\u0026a_mod)], imports: vec![], metrics: Default::default() });\n        g.files.insert(a_foo.clone(), FileNode { path: a_foo.clone(), items: vec![make_file_item(\u0026a_foo)], imports: vec![], metrics: Default::default() });\n\n        // Build hierarchy\n        g.analyze_module_hierarchy();\n\n        // Parent checks\n        assert_eq!(g.get_module_parent(\u0026a_mod), Some(\u0026lib));\n        assert_eq!(g.get_module_parent(\u0026a_foo), Some(\u0026a_mod));\n        assert!(g.get_module_parent(\u0026lib).is_none());\n\n        // Children checks\n        let lib_children = g.get_module_children(\u0026lib);\n        assert!(lib_children.contains(\u0026a_mod));\n        let a_mod_children = g.get_module_children(\u0026a_mod);\n        assert!(a_mod_children.contains(\u0026a_foo));\n    }\n\n    #[test]\n    fn import_uses_edges_item_vs_module() {\n        // Build a small graph with two files in a temp dir\n        let td = tempdir().unwrap();\n        let f1 = td.path().join(\"a.rs\");\n        let f2 = td.path().join(\"modx.rs\");\n        let f3 = td.path().join(\"b.rs\");\n        // Write contents (not strictly needed for imports)\n        fs::write(\u0026f1, \"// a.rs\\n\").unwrap();\n        fs::write(\u0026f2, \"// modx.rs\\n\").unwrap();\n        fs::write(\u0026f3, \"// b.rs\\n\").unwrap();\n\n        // File nodes\n        let mk_file_item = |p: \u0026PathBuf| Item {\n            id: ItemId(format!(\"file:{}\", p.display())),\n            item_type: ItemType::Module { is_inline: false },\n            name: p.file_stem().and_then(|s| s.to_str()).unwrap_or(\"(file)\").to_string(),\n            visibility: Visibility::PubCrate,\n            location: Location { file: p.clone(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        };\n        let mk_fn_item = |p: \u0026PathBuf, name: \u0026str| Item {\n            id: ItemId(format!(\"fn:{}:1\", name)),\n            item_type: ItemType::Function { is_async: false, is_const: false },\n            name: name.to_string(),\n            visibility: Visibility::Public,\n            location: Location { file: p.clone(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        };\n\n        let mut g = KnowledgeGraph::default();\n\n        // a.rs imports: item \"foo\" and module \"modx\"\n        let mut a_node = FileNode::default();\n        a_node.path = f1.clone();\n        a_node.items = vec![mk_file_item(\u0026f1)];\n        a_node.imports = vec![\n            Import { path: \"foo\".into(), alias: None },\n            Import { path: \"modx\".into(), alias: None },\n        ];\n\n        // modx.rs is a module (no inner items needed)\n        let mut modx_node = FileNode::default();\n        modx_node.path = f2.clone();\n        modx_node.items = vec![mk_file_item(\u0026f2)];\n\n        // b.rs defines function foo\n        let mut b_node = FileNode::default();\n        b_node.path = f3.clone();\n        b_node.items = vec![mk_file_item(\u0026f3), mk_fn_item(\u0026f3, \"foo\")];\n\n        g.files.insert(f1.clone(), a_node);\n        g.files.insert(f2.clone(), modx_node);\n        g.files.insert(f3.clone(), b_node);\n\n        // Run import uses analysis\n        g.analyze_import_uses();\n\n        // Check relationships: from a.rs file-level id\n        let a_file_id = ItemId(format!(\"file:{}\", f1.display()));\n        // Expect one import-item edge to function foo and one import-module edge to modx\n        let mut saw_item = false;\n        let mut saw_module = false;\n        for r in \u0026g.relationships {\n            if r.from_item == a_file_id {\n                if let RelationshipType::Uses { import_type } = \u0026r.relationship_type {\n                    if import_type == \"import-item\" { saw_item = true; }\n                    if import_type == \"import-module\" { saw_module = true; }\n                }\n            }\n        }\n        assert!(saw_item, \"expected import-item edge\");\n        assert!(saw_module, \"expected import-module edge\");\n    }\n\n    #[test]\n    fn calls_heuristic_and_path_and_macro_exclusion() {\n        // temp dir structure with caller and callees; write contents so heuristic reads\n        let td = tempdir().unwrap();\n        let caller = td.path().join(\"caller.rs\");\n        let callee_foo = td.path().join(\"callee.rs\");\n        let dir_a = td.path().join(\"a\");\n        let dir_b = dir_a.join(\"b\");\n        fs::create_dir_all(\u0026dir_b).unwrap();\n        let baz = dir_b.join(\"baz.rs\");\n\n        // Contents: caller calls foo(), a::b::baz(), and macro!() which should be ignored\n        fs::write(\u0026caller, \"fn main(){ foo(); a::b::baz(); my_macro!(x); }\\n\").unwrap();\n        fs::write(\u0026callee_foo, \"pub fn foo(){}\\n\").unwrap();\n        fs::write(\u0026baz, \"pub fn baz(){}\\n\").unwrap();\n\n        // Helpers to build graph items\n        let mk_file_item = |p: \u0026PathBuf| Item {\n            id: ItemId(format!(\"file:{}\", p.display())),\n            item_type: ItemType::Module { is_inline: false },\n            name: p.file_stem().and_then(|s| s.to_str()).unwrap_or(\"(file)\").to_string(),\n            visibility: Visibility::PubCrate,\n            location: Location { file: p.clone(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        };\n        let mk_fn_item = |p: \u0026PathBuf, name: \u0026str| Item {\n            id: ItemId(format!(\"fn:{}:X\", name)),\n            item_type: ItemType::Function { is_async: false, is_const: false },\n            name: name.to_string(),\n            visibility: Visibility::Public,\n            location: Location { file: p.clone(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        };\n\n        let mut g = KnowledgeGraph::default();\n        // caller file\n        let mut caller_node = FileNode::default();\n        caller_node.path = caller.clone();\n        caller_node.items = vec![mk_file_item(\u0026caller)];\n        // callee foo\n        let mut callee_node = FileNode::default();\n        callee_node.path = callee_foo.clone();\n        callee_node.items = vec![mk_file_item(\u0026callee_foo), mk_fn_item(\u0026callee_foo, \"foo\")];\n        // baz\n        let mut baz_node = FileNode::default();\n        baz_node.path = baz.clone();\n        baz_node.items = vec![mk_file_item(\u0026baz), mk_fn_item(\u0026baz, \"baz\")];\n\n        g.files.insert(caller.clone(), caller_node);\n        g.files.insert(callee_foo.clone(), callee_node);\n        g.files.insert(baz.clone(), baz_node);\n\n        // Run call analysis\n        g.analyze_calls_heuristic();\n\n        let caller_file_id = ItemId(format!(\"file:{}\", caller.display()));\n        let mut saw_foo = false;\n        let mut saw_baz = false;\n        let mut saw_macro = false;\n        for r in \u0026g.relationships {\n            if r.from_item != caller_file_id { continue; }\n            if let RelationshipType::Calls { call_type } = \u0026r.relationship_type {\n                // Identify target by id suffix\n                if r.to_item.0.starts_with(\"fn:foo:\") {\n                    saw_foo = true;\n                    assert_eq!(call_type, \"heuristic\");\n                }\n                if r.to_item.0.starts_with(\"fn:baz:\") {\n                    saw_baz = true;\n                    // path or heuristic is acceptable; path is preferred route\n                }\n            }\n            if let RelationshipType::Uses { .. } = r.relationship_type { /* ignore */ }\n        }\n        assert!(saw_foo, \"expected call edge to foo()\");\n        assert!(saw_baz, \"expected call edge to a::b::baz()\");\n        assert!(!saw_macro, \"macro invocations must not create call edges\");\n    }\n}\n","traces":[{"line":115,"address":[5987040,5988160,5993573],"length":1,"stats":{"Line":4}},{"line":125,"address":[6124324],"length":1,"stats":{"Line":4}},{"line":128,"address":[7087703],"length":1,"stats":{"Line":5}},{"line":129,"address":[8935921],"length":1,"stats":{"Line":6}},{"line":130,"address":[5987579,5987478],"length":1,"stats":{"Line":11}},{"line":131,"address":[7087781,7087934],"length":1,"stats":{"Line":2}},{"line":135,"address":[7082475],"length":1,"stats":{"Line":6}},{"line":137,"address":[8516352],"length":1,"stats":{"Line":11}},{"line":138,"address":[7353646],"length":1,"stats":{"Line":5}},{"line":139,"address":[6026183],"length":1,"stats":{"Line":6}},{"line":140,"address":[6024135,6022713,6022704],"length":1,"stats":{"Line":16}},{"line":142,"address":[7377671,7345833,7377664],"length":1,"stats":{"Line":17}},{"line":143,"address":[7380685,7353769,7380672],"length":1,"stats":{"Line":16}},{"line":144,"address":[7384988,7353780,7384976],"length":1,"stats":{"Line":17}},{"line":145,"address":[6024218],"length":1,"stats":{"Line":5}},{"line":146,"address":[6148860],"length":1,"stats":{"Line":6}},{"line":151,"address":[7158708],"length":1,"stats":{"Line":5}},{"line":153,"address":[6279157,6279274],"length":1,"stats":{"Line":22}},{"line":154,"address":[7082915],"length":1,"stats":{"Line":8}},{"line":162,"address":[7158760],"length":1,"stats":{"Line":5}},{"line":163,"address":[7159010],"length":1,"stats":{"Line":6}},{"line":164,"address":[7088506,7088603],"length":1,"stats":{"Line":11}},{"line":165,"address":[7083321,7086346],"length":1,"stats":{"Line":11}},{"line":166,"address":[6128708],"length":1,"stats":{"Line":5}},{"line":167,"address":[7162343,7162245],"length":1,"stats":{"Line":11}},{"line":168,"address":[6283031],"length":1,"stats":{"Line":1}},{"line":169,"address":[7162452],"length":1,"stats":{"Line":1}},{"line":171,"address":[6129035,6128967],"length":1,"stats":{"Line":2}},{"line":172,"address":[7092325],"length":1,"stats":{"Line":1}},{"line":173,"address":[6129385,6129300],"length":1,"stats":{"Line":2}},{"line":174,"address":[5993119],"length":1,"stats":{"Line":1}},{"line":175,"address":[6129620],"length":1,"stats":{"Line":1}},{"line":176,"address":[7093149],"length":1,"stats":{"Line":1}},{"line":177,"address":[6130112,6130184],"length":1,"stats":{"Line":2}},{"line":179,"address":[7052500],"length":1,"stats":{"Line":1}},{"line":182,"address":[7087310],"length":1,"stats":{"Line":1}},{"line":187,"address":[7162265,7163985],"length":1,"stats":{"Line":11}},{"line":191,"address":[7047959],"length":1,"stats":{"Line":6}},{"line":193,"address":[6084288,6089007,6088293],"length":1,"stats":{"Line":8}},{"line":194,"address":[7411215],"length":1,"stats":{"Line":3}},{"line":195,"address":[7148461,7143941,7143870],"length":1,"stats":{"Line":6}},{"line":196,"address":[8574380,8574475],"length":1,"stats":{"Line":6}},{"line":197,"address":[6206782,6207071,6207207],"length":1,"stats":{"Line":6}},{"line":198,"address":[6084322,6084426],"length":1,"stats":{"Line":6}},{"line":199,"address":[6217175,6203356,6217476,6217068,6220881,6216905,6203328],"length":1,"stats":{"Line":6}},{"line":202,"address":[6207512],"length":1,"stats":{"Line":3}},{"line":203,"address":[5993409],"length":1,"stats":{"Line":3}},{"line":204,"address":[6085845],"length":1,"stats":{"Line":3}},{"line":205,"address":[5992980],"length":1,"stats":{"Line":3}},{"line":206,"address":[6207866],"length":1,"stats":{"Line":3}},{"line":208,"address":[6217981],"length":1,"stats":{"Line":3}},{"line":209,"address":[6238496,6238510,6207980],"length":1,"stats":{"Line":9}},{"line":210,"address":[7405051],"length":1,"stats":{"Line":3}},{"line":211,"address":[7413014],"length":1,"stats":{"Line":3}},{"line":212,"address":[7405123],"length":1,"stats":{"Line":3}},{"line":213,"address":[8575819,8575870],"length":1,"stats":{"Line":6}},{"line":214,"address":[7145734],"length":1,"stats":{"Line":3}},{"line":218,"address":[6085981,6086051],"length":1,"stats":{"Line":6}},{"line":219,"address":[7146175],"length":1,"stats":{"Line":3}},{"line":220,"address":[6208770],"length":1,"stats":{"Line":3}},{"line":221,"address":[7405911],"length":1,"stats":{"Line":3}},{"line":222,"address":[8576620],"length":1,"stats":{"Line":3}},{"line":225,"address":[6086460],"length":1,"stats":{"Line":3}},{"line":226,"address":[7413967,7414050],"length":1,"stats":{"Line":6}},{"line":227,"address":[7407529],"length":1,"stats":{"Line":3}},{"line":228,"address":[6086796],"length":1,"stats":{"Line":3}},{"line":229,"address":[7147767],"length":1,"stats":{"Line":3}},{"line":230,"address":[7147890,7147818],"length":1,"stats":{"Line":6}},{"line":232,"address":[8578126],"length":1,"stats":{"Line":3}},{"line":236,"address":[6209350],"length":1,"stats":{"Line":3}},{"line":237,"address":[8577272,8577213],"length":1,"stats":{"Line":6}},{"line":241,"address":[5988048],"length":1,"stats":{"Line":3}},{"line":243,"address":[6125872,6128617,6125980,6126115],"length":1,"stats":{"Line":10}},{"line":244,"address":[5989140,5991332],"length":1,"stats":{"Line":2}},{"line":245,"address":[7050807],"length":1,"stats":{"Line":1}},{"line":248,"address":[7049083,7050567,7048661],"length":1,"stats":{"Line":9}},{"line":249,"address":[7084804,7085645],"length":1,"stats":{"Line":6}},{"line":250,"address":[6128000],"length":1,"stats":{"Line":3}},{"line":251,"address":[7050362],"length":1,"stats":{"Line":3}},{"line":255,"address":[7049477,7049810,7049564,7049906,7049831],"length":1,"stats":{"Line":12}},{"line":256,"address":[7049533],"length":1,"stats":{"Line":3}},{"line":258,"address":[8938620],"length":1,"stats":{"Line":3}},{"line":259,"address":[5990373,5990122],"length":1,"stats":{"Line":0}},{"line":262,"address":[5990490],"length":1,"stats":{"Line":3}},{"line":265,"address":[7085353],"length":1,"stats":{"Line":3}},{"line":266,"address":[7161372],"length":1,"stats":{"Line":3}},{"line":270,"address":[7043408],"length":1,"stats":{"Line":1}},{"line":271,"address":[7043422],"length":1,"stats":{"Line":1}},{"line":274,"address":[6267760],"length":1,"stats":{"Line":1}},{"line":275,"address":[8925019,8924926],"length":1,"stats":{"Line":2}},{"line":276,"address":[6113692],"length":1,"stats":{"Line":1}},{"line":277,"address":[7076808],"length":1,"stats":{"Line":0}},{"line":281,"address":[7100544],"length":1,"stats":{"Line":2}},{"line":282,"address":[7138828],"length":1,"stats":{"Line":1}},{"line":283,"address":[6105584,6105593],"length":1,"stats":{"Line":2}},{"line":285,"address":[7059855],"length":1,"stats":{"Line":2}},{"line":289,"address":[7157632],"length":1,"stats":{"Line":3}},{"line":290,"address":[7094626],"length":1,"stats":{"Line":2}},{"line":291,"address":[7383296,7383305],"length":1,"stats":{"Line":3}},{"line":293,"address":[7094702],"length":1,"stats":{"Line":2}},{"line":297,"address":[6118336],"length":1,"stats":{"Line":0}},{"line":298,"address":[7168641],"length":1,"stats":{"Line":0}},{"line":301,"address":[6272458,6271920,6272429],"length":1,"stats":{"Line":0}},{"line":302,"address":[6006622,6006480,6006616],"length":1,"stats":{"Line":0}},{"line":303,"address":[7194792,7194739],"length":1,"stats":{"Line":0}},{"line":305,"address":[7040561,7040327,7040431],"length":1,"stats":{"Line":0}},{"line":306,"address":[7075925],"length":1,"stats":{"Line":0}},{"line":309,"address":[6120176,6120170,6119632],"length":1,"stats":{"Line":0}},{"line":310,"address":[8930945],"length":1,"stats":{"Line":0}},{"line":311,"address":[8931338,8931159,8931093],"length":1,"stats":{"Line":0}},{"line":312,"address":[6154899,6154952],"length":1,"stats":{"Line":0}},{"line":314,"address":[5982339],"length":1,"stats":{"Line":0}},{"line":321,"address":[5993664],"length":1,"stats":{"Line":3}},{"line":322,"address":[7164222],"length":1,"stats":{"Line":3}},{"line":323,"address":[8942152],"length":1,"stats":{"Line":3}},{"line":324,"address":[5993698],"length":1,"stats":{"Line":3}},{"line":329,"address":[7054480,7059572,7056525],"length":1,"stats":{"Line":4}},{"line":331,"address":[6132231],"length":1,"stats":{"Line":4}},{"line":332,"address":[5994508],"length":1,"stats":{"Line":4}},{"line":334,"address":[7054572],"length":1,"stats":{"Line":4}},{"line":335,"address":[7142772,7142713],"length":1,"stats":{"Line":8}},{"line":336,"address":[7100114,7095644],"length":1,"stats":{"Line":8}},{"line":337,"address":[7100214,7100248],"length":1,"stats":{"Line":4}},{"line":342,"address":[8943878,8944052],"length":1,"stats":{"Line":8}},{"line":344,"address":[5995165,5995293],"length":1,"stats":{"Line":8}},{"line":347,"address":[5996017,5995956],"length":1,"stats":{"Line":8}},{"line":348,"address":[6202910,6202896],"length":1,"stats":{"Line":16}},{"line":351,"address":[7144036,7143916],"length":1,"stats":{"Line":8}},{"line":352,"address":[6180598,6180576],"length":1,"stats":{"Line":16}},{"line":353,"address":[6288458],"length":1,"stats":{"Line":4}},{"line":354,"address":[7056639,7059255,7056717],"length":1,"stats":{"Line":4}},{"line":355,"address":[6288549],"length":1,"stats":{"Line":0}},{"line":359,"address":[5996483,5995945],"length":1,"stats":{"Line":4}},{"line":363,"address":[7097253],"length":1,"stats":{"Line":4}},{"line":364,"address":[6289105,6288319,6289240],"length":1,"stats":{"Line":12}},{"line":365,"address":[6289309,6289412],"length":1,"stats":{"Line":8}},{"line":366,"address":[7145680,7145727,7145651],"length":1,"stats":{"Line":8}},{"line":371,"address":[5997796],"length":1,"stats":{"Line":4}},{"line":372,"address":[5998574,5998473],"length":1,"stats":{"Line":8}},{"line":374,"address":[7093736],"length":1,"stats":{"Line":4}},{"line":375,"address":[5998023],"length":1,"stats":{"Line":4}},{"line":376,"address":[6135822],"length":1,"stats":{"Line":4}},{"line":377,"address":[7093537,7093609],"length":1,"stats":{"Line":8}},{"line":379,"address":[5998213],"length":1,"stats":{"Line":4}},{"line":383,"address":[8947532],"length":1,"stats":{"Line":4}},{"line":386,"address":[7146561],"length":1,"stats":{"Line":12}},{"line":388,"address":[7094477,7094003],"length":1,"stats":{"Line":8}},{"line":389,"address":[6290660,6290946,6290556,6290629],"length":1,"stats":{"Line":8}},{"line":390,"address":[7058925],"length":1,"stats":{"Line":4}},{"line":397,"address":[5978784,5976752,5978882],"length":1,"stats":{"Line":4}},{"line":399,"address":[7139711],"length":1,"stats":{"Line":4}},{"line":401,"address":[5977408],"length":1,"stats":{"Line":4}},{"line":402,"address":[6268860,6268788],"length":1,"stats":{"Line":8}},{"line":403,"address":[6114898,6115030],"length":1,"stats":{"Line":8}},{"line":404,"address":[7037317],"length":1,"stats":{"Line":4}},{"line":405,"address":[6269983,6269229,6269308],"length":1,"stats":{"Line":10}},{"line":406,"address":[5978170,5978106],"length":1,"stats":{"Line":4}},{"line":407,"address":[7073090,7073158],"length":1,"stats":{"Line":4}},{"line":408,"address":[7140689,7140608,7140816,7141623],"length":1,"stats":{"Line":8}},{"line":409,"address":[7038177,7038089],"length":1,"stats":{"Line":4}},{"line":411,"address":[7141015,7141048],"length":1,"stats":{"Line":4}},{"line":412,"address":[5979183],"length":1,"stats":{"Line":2}},{"line":413,"address":[5978270],"length":1,"stats":{"Line":2}},{"line":414,"address":[7073717],"length":1,"stats":{"Line":2}},{"line":415,"address":[6116172,6116093],"length":1,"stats":{"Line":4}},{"line":416,"address":[6116294,6116216],"length":1,"stats":{"Line":4}},{"line":417,"address":[5979157],"length":1,"stats":{"Line":2}},{"line":423,"address":[5977160],"length":1,"stats":{"Line":4}},{"line":426,"address":[5969136,5975647,5973306],"length":1,"stats":{"Line":4}},{"line":428,"address":[6106335],"length":1,"stats":{"Line":4}},{"line":430,"address":[5968660,5968728],"length":1,"stats":{"Line":8}},{"line":433,"address":[7148170],"length":1,"stats":{"Line":4}},{"line":434,"address":[7148298,7148218],"length":1,"stats":{"Line":8}},{"line":435,"address":[7069901,7075607],"length":1,"stats":{"Line":8}},{"line":436,"address":[6112628],"length":1,"stats":{"Line":4}},{"line":437,"address":[6112688],"length":1,"stats":{"Line":4}},{"line":443,"address":[6106847],"length":1,"stats":{"Line":4}},{"line":444,"address":[5969090],"length":1,"stats":{"Line":4}},{"line":446,"address":[6261057,6261134],"length":1,"stats":{"Line":8}},{"line":447,"address":[7029450,7029643],"length":1,"stats":{"Line":8}},{"line":448,"address":[7070477],"length":1,"stats":{"Line":4}},{"line":449,"address":[7149022,7149069,7149124],"length":1,"stats":{"Line":12}},{"line":451,"address":[6261736],"length":1,"stats":{"Line":4}},{"line":452,"address":[7065351,7065574,7065447],"length":1,"stats":{"Line":12}},{"line":453,"address":[6082113,6082112],"length":1,"stats":{"Line":12}},{"line":454,"address":[7073745],"length":1,"stats":{"Line":3}},{"line":456,"address":[7073885,7073817],"length":1,"stats":{"Line":6}},{"line":457,"address":[7073971],"length":1,"stats":{"Line":0}},{"line":458,"address":[7152497,7152749],"length":1,"stats":{"Line":0}},{"line":459,"address":[5973986,5973941],"length":1,"stats":{"Line":0}},{"line":463,"address":[6111314,6111449,6110803],"length":1,"stats":{"Line":9}},{"line":464,"address":[8922925,8922798],"length":1,"stats":{"Line":6}},{"line":465,"address":[8923064],"length":1,"stats":{"Line":3}},{"line":466,"address":[7153527],"length":1,"stats":{"Line":3}},{"line":467,"address":[8923143],"length":1,"stats":{"Line":3}},{"line":468,"address":[5974702],"length":1,"stats":{"Line":3}},{"line":469,"address":[7153349,7153427],"length":1,"stats":{"Line":6}},{"line":471,"address":[6112063],"length":1,"stats":{"Line":3}},{"line":478,"address":[6108258,6108076],"length":1,"stats":{"Line":8}},{"line":479,"address":[5970768,5970610],"length":1,"stats":{"Line":8}},{"line":480,"address":[6032224,6032225],"length":1,"stats":{"Line":16}},{"line":482,"address":[8920116],"length":1,"stats":{"Line":4}},{"line":483,"address":[5971096],"length":1,"stats":{"Line":4}},{"line":484,"address":[7031271],"length":1,"stats":{"Line":4}},{"line":488,"address":[7066907],"length":1,"stats":{"Line":3}},{"line":489,"address":[7382928,7382942],"length":1,"stats":{"Line":9}},{"line":490,"address":[6263627],"length":1,"stats":{"Line":3}},{"line":492,"address":[7072648,7072353],"length":1,"stats":{"Line":6}},{"line":493,"address":[6109615,6109680],"length":1,"stats":{"Line":6}},{"line":494,"address":[5972610],"length":1,"stats":{"Line":3}},{"line":495,"address":[7067634],"length":1,"stats":{"Line":3}},{"line":496,"address":[8921585],"length":1,"stats":{"Line":2}},{"line":497,"address":[7151528],"length":1,"stats":{"Line":2}},{"line":498,"address":[7151551],"length":1,"stats":{"Line":2}},{"line":499,"address":[7067774,7067862],"length":1,"stats":{"Line":4}},{"line":501,"address":[7032514],"length":1,"stats":{"Line":2}},{"line":509,"address":[5969427],"length":1,"stats":{"Line":4}}],"covered":199,"coverable":217},{"path":["/","home","dio","knowledge-rs","src","graph","resolver.rs"],"content":"use std::collections::HashMap;\nuse std::path::{Path, PathBuf};\n\nuse crate::graph::{Item, ItemId, ItemType, KnowledgeGraph};\n\npub struct Resolver\u003c'a\u003e {\n    graph: \u0026'a KnowledgeGraph,\n    // name -\u003e items (functions, types, etc.)\n    name_index: HashMap\u003cString, Vec\u003cItemId\u003e\u003e, \n    // module (file stem) -\u003e file-level module item id\n    module_index: HashMap\u003cString, ItemId\u003e,\n    // item -\u003e file mapping\n    item_to_file: HashMap\u003cItemId, PathBuf\u003e,\n    // alias (from pub use ... as Alias) -\u003e fully-qualified target segments\n    alias_map: HashMap\u003cString, Vec\u003cString\u003e\u003e,\n    // per-file exposure of names via non-aliased re-exports: exposed name -\u003e fully-qualified target segments\n    exposure_map: HashMap\u003cPathBuf, HashMap\u003cString, Vec\u003cString\u003e\u003e\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::graph::*;\n    use std::path::PathBuf;\n\n    fn mk_fn(id: \u0026str, name: \u0026str, file: \u0026Path) -\u003e Item {\n        Item {\n            id: ItemId(id.to_string()),\n            item_type: ItemType::Function { is_async: false, is_const: false },\n            name: name.to_string(),\n            visibility: Visibility::Public,\n            location: Location { file: file.to_path_buf(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        }\n    }\n\n    fn mk_file_item(path: \u0026Path) -\u003e Item {\n        Item {\n            id: ItemId(format!(\"file:{}\", path.display())),\n            item_type: ItemType::Module { is_inline: false },\n            name: path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"(file)\").to_string(),\n            visibility: Visibility::PubCrate,\n            location: Location { file: path.to_path_buf(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        }\n    }\n\n    fn graph_fixture() -\u003e KnowledgeGraph {\n        // src/lib.rs\n        let lib = PathBuf::from(\"src/lib.rs\");\n        let mut lib_node = FileNode::default();\n        lib_node.path = lib.clone();\n        lib_node.items = vec![mk_file_item(\u0026lib)];\n        lib_node.imports = vec![Import { path: \"crate::a::foo\".to_string(), alias: None }];\n\n        // src/a/mod.rs\n        let a_mod = PathBuf::from(\"src/a/mod.rs\");\n        let mut a_node = FileNode::default();\n        a_node.path = a_mod.clone();\n        a_node.items = vec![mk_file_item(\u0026a_mod)];\n\n        // src/a/foo.rs\n        let a_foo = PathBuf::from(\"src/a/foo.rs\");\n        let mut afoo_node = FileNode::default();\n        afoo_node.path = a_foo.clone();\n        afoo_node.items = vec![mk_file_item(\u0026a_foo), mk_fn(\"fn:foo:1\", \"foo\", \u0026a_foo)];\n\n        // src/b/bar.rs\n        let b_bar = PathBuf::from(\"src/b/bar.rs\");\n        let mut bbar_node = FileNode::default();\n        bbar_node.path = b_bar.clone();\n        bbar_node.items = vec![mk_file_item(\u0026b_bar), mk_fn(\"fn:bar:1\", \"bar\", \u0026b_bar)];\n\n        let mut g = KnowledgeGraph::default();\n        g.files.insert(lib.clone(), lib_node);\n        g.files.insert(a_mod.clone(), a_node);\n        g.files.insert(a_foo.clone(), afoo_node);\n        g.files.insert(b_bar.clone(), bbar_node);\n        g\n    }\n\n    #[test]\n    fn resolve_crate_path() {\n        let g = graph_fixture();\n        let res = Resolver::new(\u0026g);\n        let from = Path::new(\"src/lib.rs\");\n        let ids = res.resolve_import(from, \"crate::a::foo\");\n        // Should resolve to function named foo\n        assert!(ids.iter().any(|id| id.0.starts_with(\"fn:foo:\")));\n    }\n\n    #[test]\n    fn alias_underscore_is_ignored() {\n        // Graph with a module m1 and a function inside; alias as '_' should not bind a usable name\n        let lib = PathBuf::from(\"src/lib.rs\");\n        let mut lib_node = FileNode::default();\n        lib_node.path = lib.clone();\n        lib_node.items = vec![mk_file_item(\u0026lib)];\n        lib_node.imports = vec![Import { path: \"crate::m1\".to_string(), alias: Some(\"_\".to_string()) }];\n\n        let m1_mod = PathBuf::from(\"src/m1/mod.rs\");\n        let mut m1_node = FileNode::default();\n        m1_node.path = m1_mod.clone();\n        m1_node.items = vec![mk_file_item(\u0026m1_mod)];\n\n        let mut g = KnowledgeGraph::default();\n        g.files.insert(lib.clone(), lib_node);\n        g.files.insert(m1_mod.clone(), m1_node);\n\n        let res = Resolver::new(\u0026g);\n        let from = std::path::Path::new(\"src/lib.rs\");\n        // Resolving '_' should produce nothing since '_' alias is ignored\n        let ids = res.resolve_import(from, \"_\");\n        assert!(ids.is_empty());\n    }\n\n    #[test]\n    fn exposure_reexport_maps_last_segment() {\n        // Non-aliased re-export in lib exposes last segment locally\n        let lib = PathBuf::from(\"src/lib.rs\");\n        let mut lib_node = FileNode::default();\n        lib_node.path = lib.clone();\n        lib_node.items = vec![mk_file_item(\u0026lib)];\n        // Expose baz\n        lib_node.imports = vec![Import { path: \"crate::m1::m2::baz\".to_string(), alias: None }];\n\n        let m1_mod = PathBuf::from(\"src/m1/mod.rs\");\n        let mut m1_node = FileNode::default();\n        m1_node.path = m1_mod.clone();\n        m1_node.items = vec![mk_file_item(\u0026m1_mod)];\n\n        let m2_mod = PathBuf::from(\"src/m1/m2/mod.rs\");\n        let mut m2_node = FileNode::default();\n        m2_node.path = m2_mod.clone();\n        m2_node.items = vec![mk_file_item(\u0026m2_mod)];\n\n        let baz_rs = PathBuf::from(\"src/m1/m2/baz.rs\");\n        let mut baz_node = FileNode::default();\n        baz_node.path = baz_rs.clone();\n        baz_node.items = vec![mk_file_item(\u0026baz_rs), mk_fn(\"fn:baz:2\", \"baz\", \u0026baz_rs)];\n\n        let mut g = KnowledgeGraph::default();\n        g.files.insert(lib.clone(), lib_node);\n        g.files.insert(m1_mod.clone(), m1_node);\n        g.files.insert(m2_mod.clone(), m2_node);\n        g.files.insert(baz_rs.clone(), baz_node);\n\n        let res = Resolver::new(\u0026g);\n        let from = std::path::Path::new(\"src/lib.rs\");\n        let ids = res.resolve_import(from, \"baz\");\n        assert!(ids.iter().any(|id| id.0.starts_with(\"fn:baz:\")));\n    }\n\n    #[test]\n    fn deep_super_navigation_and_helpers() {\n        // Build: src/m1/m2/baz.rs with function baz, and src/m3/qux.rs with function qux\n        // From src/m1/m2/baz.rs, resolve crate::m3::qux and super::super::m3::qux\n        let lib = PathBuf::from(\"src/lib.rs\");\n        let mut lib_node = FileNode::default();\n        lib_node.path = lib.clone();\n        lib_node.items = vec![mk_file_item(\u0026lib)];\n\n        let m1_mod = PathBuf::from(\"src/m1/mod.rs\");\n        let mut m1_node = FileNode::default();\n        m1_node.path = m1_mod.clone();\n        m1_node.items = vec![mk_file_item(\u0026m1_mod)];\n\n        let m2_mod = PathBuf::from(\"src/m1/m2/mod.rs\");\n        let mut m2_node = FileNode::default();\n        m2_node.path = m2_mod.clone();\n        m2_node.items = vec![mk_file_item(\u0026m2_mod)];\n\n        let baz_rs = PathBuf::from(\"src/m1/m2/baz.rs\");\n        let mut baz_node = FileNode::default();\n        baz_node.path = baz_rs.clone();\n        baz_node.items = vec![mk_file_item(\u0026baz_rs), mk_fn(\"fn:baz:3\", \"baz\", \u0026baz_rs)];\n\n        let m3_mod = PathBuf::from(\"src/m3/mod.rs\");\n        let mut m3_node = FileNode::default();\n        m3_node.path = m3_mod.clone();\n        m3_node.items = vec![mk_file_item(\u0026m3_mod)];\n\n        let qux_rs = PathBuf::from(\"src/m3/qux.rs\");\n        let mut qux_node = FileNode::default();\n        qux_node.path = qux_rs.clone();\n        qux_node.items = vec![mk_file_item(\u0026qux_rs), mk_fn(\"fn:qux:1\", \"qux\", \u0026qux_rs)];\n\n        let mut g = KnowledgeGraph::default();\n        g.files.insert(lib.clone(), lib_node);\n        g.files.insert(m1_mod.clone(), m1_node);\n        g.files.insert(m2_mod.clone(), m2_node);\n        g.files.insert(baz_rs.clone(), baz_node);\n        g.files.insert(m3_mod.clone(), m3_node);\n        g.files.insert(qux_rs.clone(), qux_node);\n\n        let res = Resolver::new(\u0026g);\n        let from = std::path::Path::new(\"src/m1/m2/baz.rs\");\n        let ids1 = res.resolve_import(from, \"crate::m3::qux\");\n        assert!(ids1.iter().any(|id| id.0.starts_with(\"fn:qux:\")));\n        let ids2 = res.resolve_import(from, \"super::super::m3::qux\");\n        assert!(ids2.iter().any(|id| id.0.starts_with(\"fn:qux:\")));\n\n        // Helper checks: pick an actual function id among results\n        let func_id = ids1\n            .iter()\n            .find(|id| res.is_item_function(id))\n            .cloned()\n            .expect(\"expected a function id among resolved targets\");\n        assert!(res.is_item_function(\u0026func_id));\n        // file-level module id\n        let file_level_id = ItemId(format!(\"file:{}\", baz_rs.display()));\n        assert!(res.is_file_level_module(\u0026file_level_id));\n    }\n\n    #[test]\n    fn resolve_multi_segment_chain() {\n        // Build a nested module structure: src/m1/mod.rs, src/m1/m2/mod.rs, src/m1/m2/baz.rs\n        let lib = PathBuf::from(\"src/lib.rs\");\n        let mut lib_node = FileNode::default();\n        lib_node.path = lib.clone();\n        lib_node.items = vec![mk_file_item(\u0026lib)];\n\n        let m1_mod = PathBuf::from(\"src/m1/mod.rs\");\n        let mut m1_node = FileNode::default();\n        m1_node.path = m1_mod.clone();\n        m1_node.items = vec![mk_file_item(\u0026m1_mod)];\n\n        let m2_mod = PathBuf::from(\"src/m1/m2/mod.rs\");\n        let mut m2_node = FileNode::default();\n        m2_node.path = m2_mod.clone();\n        m2_node.items = vec![mk_file_item(\u0026m2_mod)];\n\n        let baz_rs = PathBuf::from(\"src/m1/m2/baz.rs\");\n        let mut baz_node = FileNode::default();\n        baz_node.path = baz_rs.clone();\n        baz_node.items = vec![mk_file_item(\u0026baz_rs), mk_fn(\"fn:baz:1\", \"baz\", \u0026baz_rs)];\n\n        let mut g = KnowledgeGraph::default();\n        g.files.insert(lib.clone(), lib_node);\n        g.files.insert(m1_mod.clone(), m1_node);\n        g.files.insert(m2_mod.clone(), m2_node);\n        g.files.insert(baz_rs.clone(), baz_node);\n\n        let res = Resolver::new(\u0026g);\n        let from = Path::new(\"src/lib.rs\");\n        let ids = res.resolve_import(from, \"crate::m1::m2::baz\");\n        assert!(ids.iter().any(|id| id.0.starts_with(\"fn:baz:\")));\n    }\n\n    #[test]\n    fn resolve_alias_splicing_with_suffix() {\n        // Build nested modules m1::m2::baz and alias m1 as M1 in lib\n        let lib = PathBuf::from(\"src/lib.rs\");\n        let mut lib_node = FileNode::default();\n        lib_node.path = lib.clone();\n        lib_node.items = vec![mk_file_item(\u0026lib)];\n        lib_node.imports = vec![Import { path: \"crate::m1\".to_string(), alias: Some(\"M1\".to_string()) }];\n\n        let m1_mod = PathBuf::from(\"src/m1/mod.rs\");\n        let mut m1_node = FileNode::default();\n        m1_node.path = m1_mod.clone();\n        m1_node.items = vec![mk_file_item(\u0026m1_mod)];\n\n        let m2_mod = PathBuf::from(\"src/m1/m2/mod.rs\");\n        let mut m2_node = FileNode::default();\n        m2_node.path = m2_mod.clone();\n        m2_node.items = vec![mk_file_item(\u0026m2_mod)];\n\n        let baz_rs = PathBuf::from(\"src/m1/m2/baz.rs\");\n        let mut baz_node = FileNode::default();\n        baz_node.path = baz_rs.clone();\n        baz_node.items = vec![mk_file_item(\u0026baz_rs), mk_fn(\"fn:baz:1\", \"baz\", \u0026baz_rs)];\n\n        let mut g = KnowledgeGraph::default();\n        g.files.insert(lib.clone(), lib_node);\n        g.files.insert(m1_mod.clone(), m1_node);\n        g.files.insert(m2_mod.clone(), m2_node);\n        g.files.insert(baz_rs.clone(), baz_node);\n\n        let res = Resolver::new(\u0026g);\n        let from = Path::new(\"src/lib.rs\");\n        let ids = res.resolve_import(from, \"M1::m2::baz\");\n        assert!(ids.iter().any(|id| id.0.starts_with(\"fn:baz:\")));\n    }\n\n    #[test]\n    fn resolve_super_and_self() {\n        let g = graph_fixture();\n        let res = Resolver::new(\u0026g);\n        // From src/a/foo.rs, `super` should go to src/a/mod.rs scope\n        let from = Path::new(\"src/a/foo.rs\");\n        let ids = res.resolve_import(from, \"super::foo\");\n        // name_index fallback will still find foo function\n        assert!(ids.iter().any(|id| id.0.starts_with(\"fn:foo:\")));\n\n        let ids2 = res.resolve_import(from, \"self::foo\");\n        assert!(ids2.iter().any(|id| id.0.starts_with(\"fn:foo:\")));\n    }\n\n    #[test]\n    fn resolve_alias_basic() {\n        // Extend graph with an alias in lib imports\n        let mut g = graph_fixture();\n        if let Some(lib) = g.files.get_mut(\u0026PathBuf::from(\"src/lib.rs\")) {\n            lib.imports.push(Import { path: \"crate::a::foo\".to_string(), alias: Some(\"FooAlias\".to_string()) });\n        }\n        let res = Resolver::new(\u0026g);\n        let from = Path::new(\"src/lib.rs\");\n        // If another import references the alias as first segment, resolver should remap it.\n        let ids = res.resolve_import(from, \"FooAlias\");\n        assert!(ids.iter().any(|id| id.0.starts_with(\"fn:foo:\")));\n    }\n}\nimpl\u003c'a\u003e Resolver\u003c'a\u003e {\n    // Compute module segments relative to src/ for a given file path.\n    fn module_segments_for(\u0026self, path: \u0026Path) -\u003e Vec\u003cString\u003e {\n        // Find \"src\" segment index\n        let mut src_idx: Option\u003cusize\u003e = None;\n        let comps: Vec\u003c_\u003e = path.components().collect();\n        for (i, c) in comps.iter().enumerate() {\n            if let std::path::Component::Normal(os) = c {\n                if os.to_str() == Some(\"src\") { src_idx = Some(i); break; }\n            }\n        }\n        let mut segs: Vec\u003cString\u003e = Vec::new();\n        if let Some(i) = src_idx {\n            // Collect directory names after src up to the file\n            for c in \u0026comps[i+1..comps.len().saturating_sub(1)] {\n                if let std::path::Component::Normal(os) = c {\n                    if let Some(s) = os.to_str() { segs.push(s.to_string()); }\n                }\n            }\n            // Handle file as module: if mod.rs or lib.rs =\u003e use last dir as module; else file stem\n            if let Some(file_os) = path.file_name() {\n                let file = file_os.to_string_lossy();\n                if file == \"mod.rs\" || file == \"lib.rs\" {\n                    // nothing to add; module is the parent dir already captured\n                } else if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {\n                    segs.push(stem.to_string());\n                }\n            }\n        }\n        segs\n    }\n}\n\nimpl\u003c'a\u003e Resolver\u003c'a\u003e {\n    pub fn new(graph: \u0026'a KnowledgeGraph) -\u003e Self {\n        let mut name_index: HashMap\u003cString, Vec\u003cItemId\u003e\u003e = HashMap::new();\n        let mut module_index: HashMap\u003cString, ItemId\u003e = HashMap::new();\n        let mut item_to_file: HashMap\u003cItemId, PathBuf\u003e = HashMap::new();\n        let mut alias_map: HashMap\u003cString, Vec\u003cString\u003e\u003e = HashMap::new();\n        let mut exposure_map: HashMap\u003cPathBuf, HashMap\u003cString, Vec\u003cString\u003e\u003e\u003e = HashMap::new();\n        for (path, file) in \u0026graph.files {\n            for (idx, it) in file.items.iter().enumerate() {\n                item_to_file.insert(it.id.clone(), path.clone());\n                name_index.entry(it.name.clone()).or_default().push(it.id.clone());\n                if idx == 0 {\n                    if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {\n                        module_index.insert(stem.to_string(), it.id.clone());\n                    }\n                }\n            }\n            for imp in \u0026file.imports {\n                let segments: Vec\u003cString\u003e = imp\n                    .path\n                    .split(\"::\")\n                    .filter(|s| !s.is_empty())\n                    .map(|s| s.to_string())\n                    .collect();\n                if let Some(alias) = \u0026imp.alias {\n                    // Ignore underscore imports: `use path as _;` doesn't bind a name\n                    if alias == \"_\" { continue; }\n                    if !alias.is_empty() \u0026\u0026 !segments.is_empty() {\n                        alias_map.insert(alias.clone(), segments.clone());\n                    }\n                } else {\n                    // Non-aliased re-export exposes the last segment under the same name within this file/module\n                    if let Some(last) = segments.last() {\n                        exposure_map\n                            .entry(path.clone())\n                            .or_default()\n                            .insert(last.clone(), segments.clone());\n                    }\n                }\n            }\n        }\n        Self { graph, name_index, module_index, item_to_file, alias_map, exposure_map }\n    }\n\n    // Resolve an import path relative to a given file.\n    // Returns a list because globs or ambiguous names can map to multiple targets.\n    pub fn resolve_import(\u0026self, from_file: \u0026Path, raw_path: \u0026str) -\u003e Vec\u003cItemId\u003e {\n        // Strip aliasing `as X`\n        let path = raw_path.split(\" as \").next().unwrap_or(raw_path).trim();\n        let mut parts: Vec\u003cString\u003e = path\n            .split(\"::\")\n            .filter(|s| !s.is_empty())\n            .map(|s| s.to_string())\n            .collect();\n        if parts.is_empty() { return Vec::new(); }\n\n        // Best-effort normalization of crate/self/super using filesystem layout under src/\n        let mut scope: Vec\u003cString\u003e = self.module_segments_for(from_file);\n        loop {\n            match parts.first().map(|s| s.as_str()) {\n                Some(\"crate\") =\u003e { parts.remove(0); scope.clear(); }\n                Some(\"self\") =\u003e { parts.remove(0); /* stay in same scope */ }\n                Some(\"super\") =\u003e { parts.remove(0); if !scope.is_empty() { scope.pop(); } }\n                _ =\u003e break,\n            }\n        }\n        if parts.is_empty() { return Vec::new(); }\n\n        // Apply alias mapping on the first segment, if any\n        if let Some(first) = parts.first().cloned() {\n            if let Some(mapped) = self.alias_map.get(\u0026first) {\n                parts.remove(0);\n                let mut new_parts = mapped.clone();\n                new_parts.extend(parts.into_iter());\n                parts = new_parts;\n            }\n        }\n\n        // Apply per-file exposure mapping (re-exports without alias)\n        if let Some(first) = parts.first().cloned() {\n            if let Some(map) = self.exposure_map.get(from_file) {\n                if let Some(mapped) = map.get(\u0026first) {\n                    parts.remove(0);\n                    let mut new_parts = mapped.clone();\n                    new_parts.extend(parts.into_iter());\n                    parts = new_parts;\n                }\n            }\n        }\n\n        // Try to resolve using scoped module chain based on filesystem under src/\n        // Prepare a borrowable slice of \u0026str for scoped chain\n        let parts_str: Vec\u003c\u0026str\u003e = parts.iter().map(|s| s.as_str()).collect();\n        if let Some(ids) = self.resolve_scoped_chain(from_file, \u0026scope, \u0026parts_str) {\n            return ids;\n        }\n\n        // Fallback: Try exact item name match on the last segment\n        let last = parts.last().unwrap().as_str();\n        if let Some(ids) = self.name_index.get(last) {\n            return ids.clone();\n        }\n\n        // Fallback: map segment to a module (file-level) item\n        if let Some(mid) = self.module_index.get(last) {\n            return vec![mid.clone()];\n        }\n\n        // If there are multiple segments, try mapping first to a module and last to a symbol\n        if parts.len() \u003e= 2 {\n            let first = parts[0].as_str();\n            if let Some(_m0) = self.module_index.get(first) {\n                if let Some(ids) = self.name_index.get(last) {\n                    return ids.clone();\n                }\n            }\n            // Try combining scope head with parts\n            if let Some(scope_head) = scope.first() {\n                if let Some(_m) = self.module_index.get(scope_head) {\n                    if let Some(ids) = self.name_index.get(last) {\n                        return ids.clone();\n                    }\n                }\n            }\n        }\n\n        Vec::new()\n    }\n\n    pub fn is_item_function(\u0026self, id: \u0026ItemId) -\u003e bool {\n        if let Some(file) = self.item_to_file.get(id).and_then(|p| self.graph.files.get(p)) {\n            if let Some(Item { item_type, .. }) = file.items.iter().find(|it| \u0026it.id == id) {\n                return matches!(item_type, ItemType::Function { .. });\n            }\n        }\n        false\n    }\n\n    pub fn is_file_level_module(\u0026self, id: \u0026ItemId) -\u003e bool {\n        if let Some(file_path) = self.item_to_file.get(id) {\n            if let Some(file) = self.graph.files.get(file_path) {\n                if let Some(first) = file.items.first() { return \u0026first.id == id; }\n            }\n        }\n        false\n    }\n\n    // Attempt to walk modules using the scope and parts to find the target file/module and then resolve the final item.\n    // Returns Some(vec) on success; None if chain cannot be mapped.\n    fn resolve_scoped_chain(\u0026self, from_file: \u0026Path, scope: \u0026Vec\u003cString\u003e, parts: \u0026Vec\u003c\u0026str\u003e) -\u003e Option\u003cVec\u003cItemId\u003e\u003e {\n        if parts.is_empty() { return None; }\n        let (base_src, _src_idx) = self.base_src_dir(from_file)?;\n        // Build starting module path from scope\n        let mut dir = base_src.clone();\n        let mut scope_dirs: Vec\u003c\u0026str\u003e = scope.iter().map(|s| s.as_str()).collect();\n        // If from_file is a leaf file (not mod.rs/lib.rs), drop last scope segment (file stem)\n        let is_leaf = from_file.file_name()\n            .and_then(|s| s.to_str())\n            .map(|f| f != \"mod.rs\" \u0026\u0026 f != \"lib.rs\")\n            .unwrap_or(false);\n        if is_leaf \u0026\u0026 !scope_dirs.is_empty() { scope_dirs.pop(); }\n        for seg in scope_dirs { dir.push(seg); }\n        // Walk all segments except the last as module directories/files\n        for seg in \u0026parts[..parts.len().saturating_sub(1)] {\n            // Try directory seg\n            dir.push(seg);\n            // Accept if there is either dir/mod.rs or dir/lib.rs in graph\n            let candidates = vec![dir.join(\"mod.rs\"), dir.join(\"lib.rs\")];\n            let mut found_dir = false;\n            for cand in candidates {\n                if self.graph.files.contains_key(\u0026cand) {\n                    found_dir = true;\n                    break;\n                }\n            }\n            if !found_dir {\n                // Try sibling file: parent/\u003cseg\u003e.rs\n                dir.pop();\n                let file_rs = dir.join(format!(\"{}.rs\", seg));\n                if self.graph.files.contains_key(\u0026file_rs) {\n                    // Now move into that file's dir scope for next segments\n                    dir.push(seg);\n                } else {\n                    return None;\n                }\n            }\n        }\n        // Now resolve the last segment inside current dir/module\n        let last = parts[parts.len()-1];\n        // First, try a file in this dir named last.rs\n        let file_rs = dir.join(format!(\"{}.rs\", last));\n        if let Some(fnode) = self.graph.files.get(\u0026file_rs) {\n            // Prefer concrete items named `last` inside that file\n            let ids: Vec\u003cItemId\u003e = fnode.items.iter()\n                .filter(|it| it.name == last)\n                .map(|it| it.id.clone())\n                .collect();\n            if !ids.is_empty() { return Some(ids); }\n            // Else return the file-level module id if known\n            if let Some(mid) = self.module_index.get(last) { return Some(vec![mid.clone()]); }\n        }\n        // Next, try dir/mod.rs or dir/lib.rs containing an item named `last`\n        let container_candidates = vec![dir.join(\"mod.rs\"), dir.join(\"lib.rs\")];\n        for cand in container_candidates {\n            if let Some(fnode) = self.graph.files.get(\u0026cand) {\n                let mut ids: Vec\u003cItemId\u003e = Vec::new();\n                for it in \u0026fnode.items {\n                    if it.name == last { ids.push(it.id.clone()); }\n                }\n                if !ids.is_empty() { return Some(ids); }\n            }\n        }\n        None\n    }\n\n    // Returns (base_src_dir, index_of_src_component) if src is found in the path\n    fn base_src_dir(\u0026self, path: \u0026Path) -\u003e Option\u003c(PathBuf, usize)\u003e {\n        let comps: Vec\u003c_\u003e = path.components().collect();\n        let mut src_idx: Option\u003cusize\u003e = None;\n        for (i, c) in comps.iter().enumerate() {\n            if let std::path::Component::Normal(os) = c { if os.to_str() == Some(\"src\") { src_idx = Some(i); break; } }\n        }\n        let i = src_idx?;\n        let mut base = PathBuf::new();\n        for c in \u0026comps[..=i] {\n            base.push(c.as_os_str());\n        }\n        Some((base, i))\n    }\n}\n","traces":[{"line":316,"address":[6017956,6018156,6016224],"length":1,"stats":{"Line":4}},{"line":318,"address":[7603189],"length":1,"stats":{"Line":3}},{"line":319,"address":[],"length":0,"stats":{"Line":5}},{"line":320,"address":[6307786,6307699],"length":1,"stats":{"Line":11}},{"line":321,"address":[6154006,6153941],"length":1,"stats":{"Line":12}},{"line":322,"address":[6016837],"length":1,"stats":{"Line":6}},{"line":325,"address":[],"length":0,"stats":{"Line":6}},{"line":326,"address":[8965446],"length":1,"stats":{"Line":6}},{"line":328,"address":[8965476,8965675,8965571],"length":1,"stats":{"Line":18}},{"line":329,"address":[7052045,7052590],"length":1,"stats":{"Line":2}},{"line":330,"address":[7604862],"length":1,"stats":{"Line":1}},{"line":334,"address":[6154654],"length":1,"stats":{"Line":5}},{"line":335,"address":[6017592],"length":1,"stats":{"Line":5}},{"line":336,"address":[6017007,6017081,6017139],"length":1,"stats":{"Line":17}},{"line":338,"address":[7062096,7062110],"length":1,"stats":{"Line":6}},{"line":339,"address":[7604778],"length":1,"stats":{"Line":2}},{"line":343,"address":[7076498],"length":1,"stats":{"Line":5}},{"line":348,"address":[7047856,7049820,7050872],"length":1,"stats":{"Line":7}},{"line":349,"address":[7047895],"length":1,"stats":{"Line":7}},{"line":350,"address":[6143640],"length":1,"stats":{"Line":7}},{"line":351,"address":[7048003],"length":1,"stats":{"Line":7}},{"line":352,"address":[6006579],"length":1,"stats":{"Line":7}},{"line":353,"address":[7048107],"length":1,"stats":{"Line":7}},{"line":354,"address":[6006771,6006707],"length":1,"stats":{"Line":15}},{"line":355,"address":[7066399,7066762],"length":1,"stats":{"Line":15}},{"line":356,"address":[7594477,7595740,7595717,7596398],"length":1,"stats":{"Line":15}},{"line":357,"address":[8957451],"length":1,"stats":{"Line":8}},{"line":358,"address":[],"length":0,"stats":{"Line":7}},{"line":359,"address":[7068612],"length":1,"stats":{"Line":23}},{"line":360,"address":[7050672,7050722],"length":1,"stats":{"Line":7}},{"line":364,"address":[6298927],"length":1,"stats":{"Line":8}},{"line":365,"address":[7602580],"length":1,"stats":{"Line":4}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[6007851],"length":1,"stats":{"Line":14}},{"line":369,"address":[7067493,7067440],"length":1,"stats":{"Line":13}},{"line":371,"address":[],"length":0,"stats":{"Line":5}},{"line":373,"address":[6007406,6007516],"length":1,"stats":{"Line":2}},{"line":374,"address":[6007567,6007522,6007622],"length":1,"stats":{"Line":3}},{"line":375,"address":[7603020,7603096],"length":1,"stats":{"Line":1}},{"line":379,"address":[7067908,7067484],"length":1,"stats":{"Line":7}},{"line":380,"address":[],"length":0,"stats":{"Line":3}},{"line":381,"address":[6008553],"length":1,"stats":{"Line":3}},{"line":383,"address":[6300054,6299936,6300004],"length":1,"stats":{"Line":8}},{"line":393,"address":[6014778,6010096,6012113],"length":1,"stats":{"Line":3}},{"line":395,"address":[6147416],"length":1,"stats":{"Line":3}},{"line":396,"address":[],"length":0,"stats":{"Line":3}},{"line":398,"address":[6155854,6155840],"length":1,"stats":{"Line":9}},{"line":399,"address":[7605244],"length":1,"stats":{"Line":9}},{"line":401,"address":[],"length":0,"stats":{"Line":7}},{"line":404,"address":[6301934,6301963],"length":1,"stats":{"Line":8}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[6326112,6326121],"length":1,"stats":{"Line":24}},{"line":407,"address":[6010865,6011309,6010943,6010991],"length":1,"stats":{"Line":18}},{"line":408,"address":[6011085,6010949,6011287,6011037],"length":1,"stats":{"Line":12}},{"line":409,"address":[7070587,7070499],"length":1,"stats":{"Line":13}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":13}},{"line":416,"address":[7606165,7606238],"length":1,"stats":{"Line":13}},{"line":417,"address":[7043438,7043318,7043855],"length":1,"stats":{"Line":14}},{"line":418,"address":[],"length":0,"stats":{"Line":2}},{"line":419,"address":[8960297],"length":1,"stats":{"Line":1}},{"line":420,"address":[6011859,6011970],"length":1,"stats":{"Line":2}},{"line":421,"address":[6149188],"length":1,"stats":{"Line":1}},{"line":426,"address":[7598475,7599015],"length":1,"stats":{"Line":11}},{"line":427,"address":[7607074,7607190],"length":1,"stats":{"Line":11}},{"line":428,"address":[8961367,8960909,8960966],"length":1,"stats":{"Line":6}},{"line":429,"address":[7044296],"length":1,"stats":{"Line":1}},{"line":430,"address":[8961092],"length":1,"stats":{"Line":1}},{"line":431,"address":[6012765,6012654],"length":1,"stats":{"Line":2}},{"line":432,"address":[8961263],"length":1,"stats":{"Line":1}},{"line":439,"address":[6156368,6156393],"length":1,"stats":{"Line":18}},{"line":440,"address":[8961592,8961541],"length":1,"stats":{"Line":9}},{"line":441,"address":[7044938],"length":1,"stats":{"Line":1}},{"line":445,"address":[7608058,7608131],"length":1,"stats":{"Line":8}},{"line":446,"address":[7608274],"length":1,"stats":{"Line":4}},{"line":447,"address":[],"length":0,"stats":{"Line":8}},{"line":451,"address":[6013607,6013637],"length":1,"stats":{"Line":2}},{"line":452,"address":[8962171,8962220],"length":1,"stats":{"Line":0}},{"line":456,"address":[6013979,6013719],"length":1,"stats":{"Line":2}},{"line":457,"address":[6151191],"length":1,"stats":{"Line":0}},{"line":458,"address":[6151282],"length":1,"stats":{"Line":0}},{"line":459,"address":[6151383,6151437],"length":1,"stats":{"Line":0}},{"line":460,"address":[8962780],"length":1,"stats":{"Line":0}},{"line":464,"address":[6013757,6013627],"length":1,"stats":{"Line":0}},{"line":465,"address":[7601317],"length":1,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[6014632],"length":1,"stats":{"Line":0}},{"line":473,"address":[6013993],"length":1,"stats":{"Line":1}},{"line":476,"address":[7069280],"length":1,"stats":{"Line":1}},{"line":477,"address":[6325760,6325774],"length":1,"stats":{"Line":3}},{"line":478,"address":[6340622,6340608],"length":1,"stats":{"Line":4}},{"line":479,"address":[7596906],"length":1,"stats":{"Line":1}},{"line":482,"address":[7069455],"length":1,"stats":{"Line":0}},{"line":485,"address":[6009568],"length":1,"stats":{"Line":2}},{"line":486,"address":[6008994],"length":1,"stats":{"Line":2}},{"line":487,"address":[6146832,6146885],"length":1,"stats":{"Line":4}},{"line":488,"address":[8958175],"length":1,"stats":{"Line":2}},{"line":491,"address":[7596574],"length":1,"stats":{"Line":0}},{"line":496,"address":[7063009,7060080,7065801],"length":1,"stats":{"Line":6}},{"line":497,"address":[7036434,7036557],"length":1,"stats":{"Line":5}},{"line":498,"address":[7595688,7595580],"length":1,"stats":{"Line":8}},{"line":500,"address":[6000995],"length":1,"stats":{"Line":6}},{"line":501,"address":[7067088,7067113],"length":1,"stats":{"Line":14}},{"line":503,"address":[6000675,6000857],"length":1,"stats":{"Line":12}},{"line":504,"address":[7060807],"length":1,"stats":{"Line":16}},{"line":505,"address":[7037076],"length":1,"stats":{"Line":18}},{"line":507,"address":[7037139,7037210],"length":1,"stats":{"Line":8}},{"line":508,"address":[7060921,7061048,7065774],"length":1,"stats":{"Line":12}},{"line":510,"address":[6293191],"length":1,"stats":{"Line":6}},{"line":512,"address":[6293453],"length":1,"stats":{"Line":5}},{"line":514,"address":[7040627,7041860],"length":1,"stats":{"Line":5}},{"line":515,"address":[6142653],"length":1,"stats":{"Line":5}},{"line":516,"address":[7592519,7592357],"length":1,"stats":{"Line":10}},{"line":517,"address":[6297125,6297028],"length":1,"stats":{"Line":10}},{"line":518,"address":[7600641],"length":1,"stats":{"Line":2}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[7592748],"length":1,"stats":{"Line":3}},{"line":524,"address":[8954346],"length":1,"stats":{"Line":4}},{"line":525,"address":[7065365],"length":1,"stats":{"Line":3}},{"line":526,"address":[],"length":0,"stats":{"Line":7}},{"line":528,"address":[7601045],"length":1,"stats":{"Line":2}},{"line":530,"address":[8954684],"length":1,"stats":{"Line":2}},{"line":535,"address":[6139363],"length":1,"stats":{"Line":3}},{"line":537,"address":[7589208],"length":1,"stats":{"Line":3}},{"line":538,"address":[7597447,7597361],"length":1,"stats":{"Line":6}},{"line":540,"address":[6002777,6002702],"length":1,"stats":{"Line":3}},{"line":541,"address":[6002228],"length":1,"stats":{"Line":4}},{"line":542,"address":[7061427,7061392],"length":1,"stats":{"Line":7}},{"line":544,"address":[6002978,6002901],"length":1,"stats":{"Line":4}},{"line":546,"address":[6294466,6294397,6294592,6294871],"length":1,"stats":{"Line":0}},{"line":549,"address":[6294884,6296354,6294055],"length":1,"stats":{"Line":6}},{"line":550,"address":[6004165,6004003],"length":1,"stats":{"Line":6}},{"line":551,"address":[6003650,6003855],"length":1,"stats":{"Line":6}},{"line":552,"address":[6004510],"length":1,"stats":{"Line":1}},{"line":553,"address":[7599450,7599359],"length":1,"stats":{"Line":2}},{"line":554,"address":[7591854,7591635],"length":1,"stats":{"Line":2}},{"line":556,"address":[7040371],"length":1,"stats":{"Line":2}},{"line":559,"address":[6003724],"length":1,"stats":{"Line":3}},{"line":563,"address":[6016211,6014816,6016189],"length":1,"stats":{"Line":6}},{"line":564,"address":[6306213],"length":1,"stats":{"Line":7}},{"line":565,"address":[7609767],"length":1,"stats":{"Line":6}},{"line":566,"address":[6014979,6015066],"length":1,"stats":{"Line":14}},{"line":567,"address":[7610143,7610223],"length":1,"stats":{"Line":14}},{"line":569,"address":[6152756,6152562],"length":1,"stats":{"Line":14}},{"line":570,"address":[6152837],"length":1,"stats":{"Line":6}},{"line":571,"address":[6015755,6015665],"length":1,"stats":{"Line":12}},{"line":572,"address":[6307477,6307198],"length":1,"stats":{"Line":12}},{"line":574,"address":[6015382],"length":1,"stats":{"Line":6}}],"covered":132,"coverable":148},{"path":["/","home","dio","knowledge-rs","src","lib.rs"],"content":"//! knowledge-rs  Rust Knowledge Graph System\n//!\n//! Build a knowledge graph from a Rust codebase and query relationships.\n//!\n//! # Features\n//! - File discovery with `.gitignore`/`.ignore` support (deterministic; global excludes off)\n//! - Incremental builds with on-disk cache\n//! - Queries: connected files, function usage, cycles, path, hubs, module centrality, trait impls\n//! - DOT and SVG visualization\n//!\n//! # Quickstart (Library)\n//! ```no_run\n//! use knowledge_rs::graph::KnowledgeGraph;\n//! use knowledge_rs::utils::cache::CacheMode;\n//!\n//! let root = std::path::Path::new(\".\");\n//! // Build with cache and respect ignore rules\n//! let graph = KnowledgeGraph::build_from_directory_with_cache_opts(root, CacheMode::Use, /* no_ignore = */ false)\n//!     .expect(\"build graph\");\n//! println!(\"files: {} relationships: {}\", graph.files.len(), graph.relationships.len());\n//! ```\n//!\n//! # Quickstart (CLI)\n//! ```text\n//! knowledge-rs build --path . --json graph.json\n//! knowledge-rs query connected-files --path . --file src/lib.rs --format text\n//! ```\n//!\n//! # Ignore Behavior\n//! Pass `--no-ignore` in CLI to include ignored files. Env `KNOWLEDGE_RS_NO_IGNORE` remains supported for compatibility.\npub mod graph;\npub mod parser;\npub mod visualization;\npub mod cli;\npub mod utils;\npub mod errors;\npub mod query;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","src","main.rs"],"content":"fn main() {\n    use knowledge_rs::cli::{parse, Commands, QueryCommands};\n    use knowledge_rs::visualization::{DotGenerator, DotOptions, DotTheme, RankDir, EdgeStyle, SvgGenerator, SvgOptions};\n    use knowledge_rs::graph::KnowledgeGraph;\n    use knowledge_rs::query::Query;\n    use std::fs;\n\n    let cli = parse();\n\n    match cli.command {\n        Commands::Build { path, config, no_ignore, no_cache, rebuild, json, dot, svg, dot_clusters, dot_legend, dot_theme, dot_rankdir, dot_splines, dot_rounded, svg_interactive, save } =\u003e {\n            // Determine cache mode\n            let mode = if rebuild {\n                knowledge_rs::utils::cache::CacheMode::Rebuild\n            } else if no_cache {\n                knowledge_rs::utils::cache::CacheMode::Ignore\n            } else {\n                knowledge_rs::utils::cache::CacheMode::Use\n            };\n\n            let build_path = std::path::Path::new(\u0026path);\n            // Clear cache file if rebuild was requested\n            if matches!(mode, knowledge_rs::utils::cache::CacheMode::Rebuild) {\n                knowledge_rs::utils::cache::clear_cache(build_path);\n            }\n\n            // Build with explicit ignore option\n            let graph = match KnowledgeGraph::build_from_directory_with_cache_opts(build_path, mode, no_ignore) {\n                Ok(g) =\u003e g,\n                Err(e) =\u003e {\n                    eprintln!(\"Build failed: {}\", e);\n                    std::process::exit(1);\n                }\n            };\n\n            // Optionally write JSON output\n            if let Some(json_path) = json {\n                let serialized = serde_json::to_string_pretty(\u0026graph)\n                    .expect(\"serialize graph to JSON\");\n                if let Err(e) = fs::write(\u0026json_path, serialized) {\n                    eprintln!(\"Failed to write JSON output {}: {}\", json_path, e);\n                }\n            }\n\n            // Common DOT options from flags\n            let mut clusters = matches!(dot_clusters.as_str(), \"on\");\n            let mut legend = matches!(dot_legend.as_str(), \"on\");\n            let mut theme = match dot_theme.as_str() { \"dark\" =\u003e DotTheme::Dark, _ =\u003e DotTheme::Light };\n            let mut rankdir = match dot_rankdir.as_str() { \"TB\" =\u003e RankDir::TB, _ =\u003e RankDir::LR };\n            let mut splines = match dot_splines.as_str() { \"ortho\" =\u003e EdgeStyle::Ortho, \"polyline\" =\u003e EdgeStyle::Polyline, _ =\u003e EdgeStyle::Curved };\n            let mut rounded = matches!(dot_rounded.as_str(), \"on\");\n            // Apply config overrides if provided\n            if let Some(cfg_path) = config.as_ref() {\n                if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                    if let Some(dot) = cfg.dot {\n                        if let Some(v) = dot.clusters { clusters = v; }\n                        if let Some(v) = dot.legend { legend = v; }\n                        if let Some(v) = dot.theme { theme = if v == \"dark\" { DotTheme::Dark } else { DotTheme::Light }; }\n                        if let Some(v) = dot.rankdir { rankdir = if v == \"TB\" { RankDir::TB } else { RankDir::LR }; }\n                        if let Some(v) = dot.splines { splines = match v.as_str() { \"ortho\" =\u003e EdgeStyle::Ortho, \"polyline\" =\u003e EdgeStyle::Polyline, _ =\u003e EdgeStyle::Curved }; }\n                        if let Some(v) = dot.rounded { rounded = v; }\n                    }\n                }\n            }\n            let dot_opts = DotOptions { clusters, legend, theme, rankdir, splines, rounded };\n\n            // Optionally write DOT output\n            if let Some(dot_path) = dot {\n                match DotGenerator::new().generate_dot_with_options(\u0026graph, dot_opts) {\n                    Ok(content) =\u003e {\n                        if let Err(e) = fs::write(\u0026dot_path, content) {\n                            eprintln!(\"Failed to write DOT output {}: {}\", dot_path, e);\n                        }\n                    }\n                    Err(e) =\u003e eprintln!(\"Visualization error: {}\", e),\n                }\n            }\n\n            // Optionally write SVG output\n            if let Some(svg_path) = svg {\n                let mut interactive = matches!(svg_interactive.as_str(), \"on\");\n                if let Some(cfg_path) = config.as_ref() {\n                    if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                        if let Some(svg) = cfg.svg {\n                            if let Some(v) = svg.interactive { interactive = v; }\n                        }\n                    }\n                }\n                let svg_opts = SvgOptions { dot: dot_opts, interactive };\n                match SvgGenerator::new().generate_svg_with_options(\u0026graph, svg_opts) {\n                    Ok(content) =\u003e {\n                        if let Err(e) = fs::write(\u0026svg_path, content) {\n                            eprintln!(\"Failed to write SVG output {}: {}\", svg_path, e);\n                        }\n                    }\n                    Err(e) =\u003e eprintln!(\"Visualization error: {}\", e),\n                }\n            }\n\n            if let Some(save_path) = save {\n                if let Err(e) = KnowledgeGraph::save_json(\u0026graph, std::path::Path::new(\u0026save_path)) {\n                    eprintln!(\"Failed to save graph JSON {}: {}\", save_path, e);\n                }\n            }\n\n            println!(\"Build completed for path: {}\", path);\n        }\n        Commands::Query { query } =\u003e match query {\n            QueryCommands::ConnectedFiles { path, config, no_ignore, file, graph: graph_path, format } =\u003e {\n                let graph = match graph_path {\n                    Some(p) =\u003e match KnowledgeGraph::load_json(std::path::Path::new(\u0026p)) {\n                        Ok(g) =\u003e g,\n                        Err(e) =\u003e { eprintln!(\"Load graph failed: {}\", e); std::process::exit(1); }\n                    },\n                    None =\u003e {\n                        let res = match KnowledgeGraph::build_from_directory_opts(std::path::Path::new(\u0026path), no_ignore) {\n                            Ok(g) =\u003e g,\n                            Err(e) =\u003e { eprintln!(\"Build failed: {}\", e); std::process::exit(1); }\n                        };\n                        res\n                    }\n                };\n                let q = knowledge_rs::query::ConnectedFilesQuery::new(\u0026file);\n                let results = q.run(\u0026graph);\n                let fmt = if let Some(cfg_path) = config.as_ref() {\n                    if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                        cfg.query.and_then(|q| q.default_format).unwrap_or(format.clone())\n                    } else { format.clone() }\n                } else { format.clone() };\n                if fmt == \"json\" {\n                    let out: Vec\u003cString\u003e = results.into_iter().map(|p| p.display().to_string()).collect();\n                    match serde_json::to_string_pretty(\u0026out) {\n                        Ok(s) =\u003e println!(\"{}\", s),\n                        Err(e) =\u003e { eprintln!(\"JSON encode error: {}\", e); std::process::exit(1); }\n                    }\n                } else {\n                    let rows: Vec\u003cVec\u003cString\u003e\u003e = results\n                        .into_iter()\n                        .enumerate()\n                        .map(|(i,p)| vec![format!(\"{}\", i+1), p.display().to_string()])\n                        .collect();\n                    let table = knowledge_rs::utils::table::render(\u0026[\"#\", \"Path\"], \u0026rows);\n                    println!(\"{}\", table);\n                }\n            }\n            QueryCommands::FunctionUsage { path, config, no_ignore, function, direction, graph: graph_path, format } =\u003e {\n                let graph = match graph_path {\n                    Some(p) =\u003e match KnowledgeGraph::load_json(std::path::Path::new(\u0026p)) {\n                        Ok(g) =\u003e g,\n                        Err(e) =\u003e { eprintln!(\"Load graph failed: {}\", e); std::process::exit(1); }\n                    },\n                    None =\u003e {\n                        if no_ignore { std::env::set_var(\"KNOWLEDGE_RS_NO_IGNORE\", \"1\"); }\n                        let res = match KnowledgeGraph::build_from_directory(std::path::Path::new(\u0026path)) {\n                            Ok(g) =\u003e g,\n                            Err(e) =\u003e { eprintln!(\"Build failed: {}\", e); std::process::exit(1); }\n                        };\n                        if no_ignore { std::env::remove_var(\"KNOWLEDGE_RS_NO_IGNORE\"); }\n                        res\n                    }\n                };\n                let dir = match direction.as_str() {\n                    \"callees\" =\u003e knowledge_rs::query::UsageDirection::Callees,\n                    _ =\u003e knowledge_rs::query::UsageDirection::Callers,\n                };\n                let q = knowledge_rs::query::FunctionUsageQuery { function, direction: dir };\n                let results = q.run(\u0026graph);\n                let fmt = if let Some(cfg_path) = config.as_ref() {\n                    if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                        cfg.query.and_then(|q| q.default_format).unwrap_or(format.clone())\n                    } else { format.clone() }\n                } else { format.clone() };\n                if fmt == \"json\" {\n                    let out: Vec\u003cString\u003e = results.into_iter().map(|p| p.display().to_string()).collect();\n                    match serde_json::to_string_pretty(\u0026out) {\n                        Ok(s) =\u003e println!(\"{}\", s),\n                        Err(e) =\u003e { eprintln!(\"JSON encode error: {}\", e); std::process::exit(1); }\n                    }\n                } else {\n                    for p in results { println!(\"{}\", p.display()); }\n                }\n            }\n            QueryCommands::Cycles { path, config, no_ignore, graph: graph_path, format } =\u003e {\n                let graph = match graph_path {\n                    Some(p) =\u003e match KnowledgeGraph::load_json(std::path::Path::new(\u0026p)) {\n                        Ok(g) =\u003e g,\n                        Err(e) =\u003e { eprintln!(\"Load graph failed: {}\", e); std::process::exit(1); }\n                    },\n                    None =\u003e {\n                        if no_ignore { std::env::set_var(\"KNOWLEDGE_RS_NO_IGNORE\", \"1\"); }\n                        let res = match KnowledgeGraph::build_from_directory(std::path::Path::new(\u0026path)) {\n                            Ok(g) =\u003e g,\n                            Err(e) =\u003e { eprintln!(\"Build failed: {}\", e); std::process::exit(1); }\n                        };\n                        if no_ignore { std::env::remove_var(\"KNOWLEDGE_RS_NO_IGNORE\"); }\n                        res\n                    }\n                };\n                let q = knowledge_rs::query::CycleDetectionQuery::new();\n                let cycles = q.run(\u0026graph);\n                let fmt = if let Some(cfg_path) = config.as_ref() {\n                    if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                        cfg.query.and_then(|q| q.default_format).unwrap_or(format.clone())\n                    } else { format.clone() }\n                } else { format.clone() };\n                if fmt == \"json\" {\n                    let out: Vec\u003cVec\u003cString\u003e\u003e = cycles\n                        .into_iter()\n                        .map(|cyc| cyc.into_iter().map(|p| p.display().to_string()).collect())\n                        .collect();\n                    match serde_json::to_string_pretty(\u0026out) {\n                        Ok(s) =\u003e println!(\"{}\", s),\n                        Err(e) =\u003e { eprintln!(\"JSON encode error: {}\", e); std::process::exit(1); }\n                    }\n                } else {\n                    for cyc in cycles {\n                        let parts: Vec\u003cString\u003e = cyc.iter().map(|p| p.display().to_string()).collect();\n                        println!(\"{}\", parts.join(\" -\u003e \"));\n                    }\n                }\n            }\n            QueryCommands::Path { path, config, no_ignore, from, to, graph: graph_path, format } =\u003e {\n                let graph = match graph_path {\n                    Some(p) =\u003e match KnowledgeGraph::load_json(std::path::Path::new(\u0026p)) {\n                        Ok(g) =\u003e g,\n                        Err(e) =\u003e { eprintln!(\"Load graph failed: {}\", e); std::process::exit(1); }\n                    },\n                    None =\u003e {\n                        if no_ignore { std::env::set_var(\"KNOWLEDGE_RS_NO_IGNORE\", \"1\"); }\n                        let res = match KnowledgeGraph::build_from_directory(std::path::Path::new(\u0026path)) {\n                            Ok(g) =\u003e g,\n                            Err(e) =\u003e { eprintln!(\"Build failed: {}\", e); std::process::exit(1); }\n                        };\n                        if no_ignore { std::env::remove_var(\"KNOWLEDGE_RS_NO_IGNORE\"); }\n                        res\n                    }\n                };\n                let q = knowledge_rs::query::ShortestPathQuery::new(\u0026from, \u0026to);\n                let results = q.run(\u0026graph);\n                let fmt = if let Some(cfg_path) = config.as_ref() {\n                    if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                        cfg.query.and_then(|q| q.default_format).unwrap_or(format.clone())\n                    } else { format.clone() }\n                } else { format.clone() };\n                if fmt == \"json\" {\n                    let out: Vec\u003cString\u003e = results.into_iter().map(|p| p.display().to_string()).collect();\n                    match serde_json::to_string_pretty(\u0026out) {\n                        Ok(s) =\u003e println!(\"{}\", s),\n                        Err(e) =\u003e { eprintln!(\"JSON encode error: {}\", e); std::process::exit(1); }\n                    }\n                } else {\n                    if results.is_empty() {\n                        println!(\"\u003cno path\u003e\");\n                    } else {\n                        let rows: Vec\u003cVec\u003cString\u003e\u003e = results\n                            .into_iter()\n                            .enumerate()\n                            .map(|(i,p)| vec![format!(\"{}\", i+1), p.display().to_string()])\n                            .collect();\n                        let table = knowledge_rs::utils::table::render(\u0026[\"Step\", \"Path\"], \u0026rows);\n                        println!(\"{}\", table);\n                    }\n                }\n            }\n            QueryCommands::Hubs { path, config, no_ignore, graph: graph_path, metric, top, format } =\u003e {\n                use knowledge_rs::query::{HubsQuery, CentralityMetric};\n                let graph = match graph_path {\n                    Some(p) =\u003e match KnowledgeGraph::load_json(std::path::Path::new(\u0026p)) {\n                        Ok(g) =\u003e g,\n                        Err(e) =\u003e { eprintln!(\"Load graph failed: {}\", e); std::process::exit(1); }\n                    },\n                    None =\u003e {\n                        if no_ignore { std::env::set_var(\"KNOWLEDGE_RS_NO_IGNORE\", \"1\"); }\n                        let res = match KnowledgeGraph::build_from_directory(std::path::Path::new(\u0026path)) {\n                            Ok(g) =\u003e g,\n                            Err(e) =\u003e { eprintln!(\"Build failed: {}\", e); std::process::exit(1); }\n                        };\n                        if no_ignore { std::env::remove_var(\"KNOWLEDGE_RS_NO_IGNORE\"); }\n                        res\n                    }\n                };\n                let m = match metric.as_str() {\n                    \"in\" =\u003e CentralityMetric::In,\n                    \"out\" =\u003e CentralityMetric::Out,\n                    _ =\u003e CentralityMetric::Total,\n                };\n                let q = HubsQuery::new(m, top);\n                let rows = q.run(\u0026graph);\n                let fmt = if let Some(cfg_path) = config.as_ref() {\n                    if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                        cfg.query.and_then(|q| q.default_format).unwrap_or(format.clone())\n                    } else { format.clone() }\n                } else { format.clone() };\n                if fmt == \"json\" {\n                    #[derive(serde::Serialize)]\n                    struct HubRow { path: String, indegree: usize, outdegree: usize }\n                    let out: Vec\u003cHubRow\u003e = rows.into_iter().map(|(p,i,o)| HubRow { path: p.display().to_string(), indegree: i, outdegree: o }).collect();\n                    match serde_json::to_string_pretty(\u0026out) {\n                        Ok(s) =\u003e println!(\"{}\", s),\n                        Err(e) =\u003e { eprintln!(\"JSON encode error: {}\", e); std::process::exit(1); }\n                    }\n                } else {\n                    let body: Vec\u003cVec\u003cString\u003e\u003e = rows\n                        .into_iter()\n                        .map(|(p,i,o)| vec![p.display().to_string(), i.to_string(), o.to_string(), (i+o).to_string()])\n                        .collect();\n                    let table = knowledge_rs::utils::table::render(\u0026[\"Path\", \"In\", \"Out\", \"Total\"], \u0026body);\n                    println!(\"{}\", table);\n                }\n            }\n            QueryCommands::ModuleCentrality { path, config, no_ignore, graph: graph_path, metric, top, format } =\u003e {\n                use knowledge_rs::query::{ModuleCentralityQuery, CentralityMetric, Query};\n                let graph = match graph_path {\n                    Some(p) =\u003e match KnowledgeGraph::load_json(std::path::Path::new(\u0026p)) {\n                        Ok(g) =\u003e g,\n                        Err(e) =\u003e { eprintln!(\"Load graph failed: {}\", e); std::process::exit(1); }\n                    },\n                    None =\u003e {\n                        if no_ignore { std::env::set_var(\"KNOWLEDGE_RS_NO_IGNORE\", \"1\"); }\n                        let res = match KnowledgeGraph::build_from_directory(std::path::Path::new(\u0026path)) {\n                            Ok(g) =\u003e g,\n                            Err(e) =\u003e { eprintln!(\"Build failed: {}\", e); std::process::exit(1); }\n                        };\n                        if no_ignore { std::env::remove_var(\"KNOWLEDGE_RS_NO_IGNORE\"); }\n                        res\n                    }\n                };\n                let m = match metric.as_str() {\n                    \"in\" =\u003e CentralityMetric::In,\n                    \"out\" =\u003e CentralityMetric::Out,\n                    _ =\u003e CentralityMetric::Total,\n                };\n                let q = ModuleCentralityQuery::new(m, top);\n                let rows = q.run(\u0026graph);\n                let fmt = if let Some(cfg_path) = config.as_ref() {\n                    if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                        cfg.query.and_then(|q| q.default_format).unwrap_or(format.clone())\n                    } else { format.clone() }\n                } else { format.clone() };\n                if fmt == \"json\" {\n                    #[derive(serde::Serialize)]\n                    struct Row { module: String, indegree: usize, outdegree: usize }\n                    let out: Vec\u003cRow\u003e = rows.into_iter().map(|(p,i,o)| Row { module: p.display().to_string(), indegree: i, outdegree: o }).collect();\n                    match serde_json::to_string_pretty(\u0026out) {\n                        Ok(s) =\u003e println!(\"{}\", s),\n                        Err(e) =\u003e { eprintln!(\"JSON encode error: {}\", e); std::process::exit(1); }\n                    }\n                } else {\n                    let body: Vec\u003cVec\u003cString\u003e\u003e = rows\n                        .into_iter()\n                        .map(|(p,i,o)| vec![p.display().to_string(), i.to_string(), o.to_string(), (i+o).to_string()])\n                        .collect();\n                    let table = knowledge_rs::utils::table::render(\u0026[\"Module\", \"In\", \"Out\", \"Total\"], \u0026body);\n                    println!(\"{}\", table);\n                }\n            }\n            QueryCommands::TraitImpls { path, config, no_ignore, r#trait, graph: graph_path, format } =\u003e {\n                use knowledge_rs::query::{TraitImplsQuery, Query};\n                let graph = match graph_path {\n                    Some(p) =\u003e match KnowledgeGraph::load_json(std::path::Path::new(\u0026p)) {\n                        Ok(g) =\u003e g,\n                        Err(e) =\u003e { eprintln!(\"Load graph failed: {}\", e); std::process::exit(1); }\n                    },\n                    None =\u003e {\n                        if no_ignore { std::env::set_var(\"KNOWLEDGE_RS_NO_IGNORE\", \"1\"); }\n                        let res = match KnowledgeGraph::build_from_directory(std::path::Path::new(\u0026path)) {\n                            Ok(g) =\u003e g,\n                            Err(e) =\u003e { eprintln!(\"Build failed: {}\", e); std::process::exit(1); }\n                        };\n                        if no_ignore { std::env::remove_var(\"KNOWLEDGE_RS_NO_IGNORE\"); }\n                        res\n                    }\n                };\n                let q = TraitImplsQuery::new(\u0026r#trait);\n                let rows = q.run(\u0026graph);\n                let fmt = if let Some(cfg_path) = config.as_ref() {\n                    if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                        cfg.query.and_then(|q| q.default_format).unwrap_or(format.clone())\n                    } else { format.clone() }\n                } else { format.clone() };\n                if fmt == \"json\" {\n                    #[derive(serde::Serialize)]\n                    struct Row { path: String, r#type: String }\n                    let out: Vec\u003cRow\u003e = rows.into_iter().map(|(p,t)| Row { path: p.display().to_string(), r#type: t }).collect();\n                    match serde_json::to_string_pretty(\u0026out) {\n                        Ok(s) =\u003e println!(\"{}\", s),\n                        Err(e) =\u003e { eprintln!(\"JSON encode error: {}\", e); std::process::exit(1); }\n                    }\n                } else {\n                    if rows.is_empty() {\n                        println!(\"\u003cno implementations found\u003e\");\n                    } else {\n                        let body: Vec\u003cVec\u003cString\u003e\u003e = rows\n                            .into_iter()\n                            .map(|(p,t)| vec![p.display().to_string(), t])\n                            .collect();\n                        let table = knowledge_rs::utils::table::render(\u0026[\"Path\", \"Type\"], \u0026body);\n                        println!(\"{}\", table);\n                    }\n                }\n            }\n        },\n    }\n}\n","traces":[{"line":1,"address":[5746181,5737808,5739959,5737840],"length":1,"stats":{"Line":1}},{"line":8,"address":[5737922],"length":1,"stats":{"Line":0}},{"line":10,"address":[5738104],"length":1,"stats":{"Line":0}},{"line":11,"address":[5738211],"length":1,"stats":{"Line":0}},{"line":13,"address":[5738932,5738957],"length":1,"stats":{"Line":0}},{"line":14,"address":[5738949],"length":1,"stats":{"Line":0}},{"line":15,"address":[5738967,5738943],"length":1,"stats":{"Line":0}},{"line":16,"address":[5738969],"length":1,"stats":{"Line":0}},{"line":18,"address":[5738959],"length":1,"stats":{"Line":0}},{"line":21,"address":[5738977,5739094],"length":1,"stats":{"Line":0}},{"line":23,"address":[5739110],"length":1,"stats":{"Line":0}},{"line":24,"address":[5739140,5739209],"length":1,"stats":{"Line":0}},{"line":28,"address":[5739174,5739211],"length":1,"stats":{"Line":0}},{"line":29,"address":[5739338],"length":1,"stats":{"Line":0}},{"line":30,"address":[5739248],"length":1,"stats":{"Line":0}},{"line":31,"address":[5739328,5745860],"length":1,"stats":{"Line":0}},{"line":32,"address":[5745929],"length":1,"stats":{"Line":0}},{"line":37,"address":[5739390],"length":1,"stats":{"Line":0}},{"line":38,"address":[5739467],"length":1,"stats":{"Line":0}},{"line":40,"address":[5739630],"length":1,"stats":{"Line":0}},{"line":41,"address":[5739825,5739716],"length":1,"stats":{"Line":0}},{"line":46,"address":[5739502,5740025],"length":1,"stats":{"Line":0}},{"line":47,"address":[5740075],"length":1,"stats":{"Line":0}},{"line":48,"address":[5740164],"length":1,"stats":{"Line":0}},{"line":49,"address":[5740268],"length":1,"stats":{"Line":0}},{"line":50,"address":[5740372],"length":1,"stats":{"Line":0}},{"line":51,"address":[5740563],"length":1,"stats":{"Line":0}},{"line":53,"address":[5740644],"length":1,"stats":{"Line":0}},{"line":54,"address":[5740933,5740734],"length":1,"stats":{"Line":0}},{"line":55,"address":[5742303,5741019],"length":1,"stats":{"Line":0}},{"line":56,"address":[5741102,5741153],"length":1,"stats":{"Line":0}},{"line":57,"address":[5741181],"length":1,"stats":{"Line":0}},{"line":58,"address":[5741380,5741236],"length":1,"stats":{"Line":0}},{"line":59,"address":[5741665,5741334,5741554],"length":1,"stats":{"Line":0}},{"line":60,"address":[5741883,5741776,5741623],"length":1,"stats":{"Line":0}},{"line":61,"address":[5742259,5741847],"length":1,"stats":{"Line":0}},{"line":65,"address":[5740764],"length":1,"stats":{"Line":0}},{"line":68,"address":[5742374,5740871],"length":1,"stats":{"Line":0}},{"line":69,"address":[5742414,5742515],"length":1,"stats":{"Line":0}},{"line":70,"address":[5742749],"length":1,"stats":{"Line":0}},{"line":71,"address":[5742797],"length":1,"stats":{"Line":0}},{"line":72,"address":[5742992,5742883],"length":1,"stats":{"Line":0}},{"line":75,"address":[5742659,5743126],"length":1,"stats":{"Line":0}},{"line":80,"address":[5743261,5742425],"length":1,"stats":{"Line":0}},{"line":81,"address":[5743438,5743309],"length":1,"stats":{"Line":0}},{"line":82,"address":[5743480],"length":1,"stats":{"Line":0}},{"line":83,"address":[5743671,5743570],"length":1,"stats":{"Line":0}},{"line":84,"address":[5743757],"length":1,"stats":{"Line":0}},{"line":85,"address":[5743798,5743847],"length":1,"stats":{"Line":0}},{"line":89,"address":[5743597],"length":1,"stats":{"Line":0}},{"line":90,"address":[5743641,5743877],"length":1,"stats":{"Line":0}},{"line":91,"address":[5744123],"length":1,"stats":{"Line":0}},{"line":92,"address":[5744171],"length":1,"stats":{"Line":0}},{"line":93,"address":[5744257,5744366],"length":1,"stats":{"Line":0}},{"line":96,"address":[5744500,5744033],"length":1,"stats":{"Line":0}},{"line":100,"address":[5743332,5744635],"length":1,"stats":{"Line":0}},{"line":101,"address":[5744800,5744675],"length":1,"stats":{"Line":0}},{"line":102,"address":[5744927,5745052],"length":1,"stats":{"Line":0}},{"line":106,"address":[5745166,5744710],"length":1,"stats":{"Line":0}},{"line":108,"address":[5738141],"length":1,"stats":{"Line":0}},{"line":109,"address":[5746196],"length":1,"stats":{"Line":0}},{"line":110,"address":[5746459],"length":1,"stats":{"Line":0}},{"line":111,"address":[5749054,5748463],"length":1,"stats":{"Line":0}},{"line":112,"address":[5749252],"length":1,"stats":{"Line":0}},{"line":113,"address":[5751583,5749110],"length":1,"stats":{"Line":0}},{"line":116,"address":[5748533,5748635],"length":1,"stats":{"Line":0}},{"line":117,"address":[5748784],"length":1,"stats":{"Line":0}},{"line":118,"address":[5748862,5748697],"length":1,"stats":{"Line":0}},{"line":120,"address":[5748810],"length":1,"stats":{"Line":0}},{"line":123,"address":[5748852],"length":1,"stats":{"Line":0}},{"line":124,"address":[5749430,5749354],"length":1,"stats":{"Line":0}},{"line":125,"address":[5749438,5749511],"length":1,"stats":{"Line":0}},{"line":126,"address":[5749646,5749566],"length":1,"stats":{"Line":0}},{"line":127,"address":[5749868,5749910,5750110,5749732],"length":1,"stats":{"Line":0}},{"line":128,"address":[5750018,5750132,5749999,5749787],"length":1,"stats":{"Line":0}},{"line":129,"address":[5749593,5750156],"length":1,"stats":{"Line":0}},{"line":130,"address":[5750081,5750209],"length":1,"stats":{"Line":0}},{"line":131,"address":[5750751,5750282],"length":1,"stats":{"Line":0}},{"line":132,"address":[5750848,5750797],"length":1,"stats":{"Line":0}},{"line":133,"address":[5750927],"length":1,"stats":{"Line":0}},{"line":134,"address":[5750885,5751429],"length":1,"stats":{"Line":0}},{"line":137,"address":[5750215],"length":1,"stats":{"Line":0}},{"line":140,"address":[5687257,5687232],"length":1,"stats":{"Line":0}},{"line":142,"address":[5750508,5750429],"length":1,"stats":{"Line":0}},{"line":143,"address":[5750539,5750610],"length":1,"stats":{"Line":0}},{"line":146,"address":[5746505],"length":1,"stats":{"Line":0}},{"line":147,"address":[5746824],"length":1,"stats":{"Line":0}},{"line":148,"address":[5752454,5751715],"length":1,"stats":{"Line":0}},{"line":149,"address":[5752652],"length":1,"stats":{"Line":0}},{"line":150,"address":[5752510,5755279],"length":1,"stats":{"Line":0}},{"line":153,"address":[5751908,5751792,5751833],"length":1,"stats":{"Line":0}},{"line":154,"address":[5751926,5751798],"length":1,"stats":{"Line":0}},{"line":155,"address":[5752072],"length":1,"stats":{"Line":0}},{"line":156,"address":[5752262,5751982],"length":1,"stats":{"Line":0}},{"line":158,"address":[5752226,5752163,5752131],"length":1,"stats":{"Line":0}},{"line":159,"address":[5752135],"length":1,"stats":{"Line":0}},{"line":162,"address":[5752236],"length":1,"stats":{"Line":0}},{"line":163,"address":[5752770,5752819],"length":1,"stats":{"Line":0}},{"line":164,"address":[5752809],"length":1,"stats":{"Line":0}},{"line":166,"address":[5752827],"length":1,"stats":{"Line":0}},{"line":167,"address":[5752992,5752913],"length":1,"stats":{"Line":0}},{"line":168,"address":[5753000,5753073],"length":1,"stats":{"Line":0}},{"line":169,"address":[5753128,5753208],"length":1,"stats":{"Line":0}},{"line":170,"address":[5691011,5691008],"length":1,"stats":{"Line":0}},{"line":171,"address":[5753580,5753694,5753561,5753349],"length":1,"stats":{"Line":0}},{"line":172,"address":[5753155,5753718],"length":1,"stats":{"Line":0}},{"line":173,"address":[5753643,5753771],"length":1,"stats":{"Line":0}},{"line":174,"address":[5753844,5754439],"length":1,"stats":{"Line":0}},{"line":175,"address":[5754485,5754536],"length":1,"stats":{"Line":0}},{"line":176,"address":[5754615],"length":1,"stats":{"Line":0}},{"line":177,"address":[5755125,5754573],"length":1,"stats":{"Line":0}},{"line":180,"address":[5753914,5754190,5753777],"length":1,"stats":{"Line":0}},{"line":183,"address":[5746870],"length":1,"stats":{"Line":0}},{"line":184,"address":[5747085],"length":1,"stats":{"Line":0}},{"line":185,"address":[5755452,5756171],"length":1,"stats":{"Line":0}},{"line":186,"address":[5756369],"length":1,"stats":{"Line":0}},{"line":187,"address":[5758932,5756227],"length":1,"stats":{"Line":0}},{"line":190,"address":[5755529,5755645,5755570],"length":1,"stats":{"Line":0}},{"line":191,"address":[5755663,5755535],"length":1,"stats":{"Line":0}},{"line":192,"address":[5755809],"length":1,"stats":{"Line":0}},{"line":193,"address":[5755719,5755979],"length":1,"stats":{"Line":0}},{"line":195,"address":[5755900,5755963,5755868],"length":1,"stats":{"Line":0}},{"line":196,"address":[5755872],"length":1,"stats":{"Line":0}},{"line":199,"address":[5755965],"length":1,"stats":{"Line":0}},{"line":200,"address":[5756471],"length":1,"stats":{"Line":0}},{"line":201,"address":[5756514,5756590],"length":1,"stats":{"Line":0}},{"line":202,"address":[5756725,5756645],"length":1,"stats":{"Line":0}},{"line":203,"address":[5689136,5689139],"length":1,"stats":{"Line":0}},{"line":204,"address":[5757078,5757097,5756866,5757211],"length":1,"stats":{"Line":0}},{"line":205,"address":[5757235,5756672],"length":1,"stats":{"Line":0}},{"line":206,"address":[5757288,5757160],"length":1,"stats":{"Line":0}},{"line":207,"address":[5757357],"length":1,"stats":{"Line":0}},{"line":209,"address":[5684416,5689568,5684448,5689536],"length":1,"stats":{"Line":0}},{"line":211,"address":[5758237,5758284],"length":1,"stats":{"Line":0}},{"line":212,"address":[5758363],"length":1,"stats":{"Line":0}},{"line":213,"address":[5758321,5758778],"length":1,"stats":{"Line":0}},{"line":216,"address":[5757550,5757294,5757423],"length":1,"stats":{"Line":0}},{"line":217,"address":[5757619,5757751],"length":1,"stats":{"Line":0}},{"line":218,"address":[5757848,5757943],"length":1,"stats":{"Line":0}},{"line":222,"address":[5747131],"length":1,"stats":{"Line":0}},{"line":223,"address":[5747442],"length":1,"stats":{"Line":0}},{"line":224,"address":[5759803,5759064],"length":1,"stats":{"Line":0}},{"line":225,"address":[5760001],"length":1,"stats":{"Line":0}},{"line":226,"address":[5762506,5759859],"length":1,"stats":{"Line":0}},{"line":229,"address":[5759141,5759182,5759257],"length":1,"stats":{"Line":0}},{"line":230,"address":[5759147,5759275],"length":1,"stats":{"Line":0}},{"line":231,"address":[5759421],"length":1,"stats":{"Line":0}},{"line":232,"address":[5759611,5759331],"length":1,"stats":{"Line":0}},{"line":234,"address":[5759512,5759575,5759480],"length":1,"stats":{"Line":0}},{"line":235,"address":[5759484],"length":1,"stats":{"Line":0}},{"line":238,"address":[5759601],"length":1,"stats":{"Line":0}},{"line":239,"address":[5760179,5760103],"length":1,"stats":{"Line":0}},{"line":240,"address":[5760187,5760260],"length":1,"stats":{"Line":0}},{"line":241,"address":[5760395,5760315],"length":1,"stats":{"Line":0}},{"line":242,"address":[5760481,5760659,5760859,5760617],"length":1,"stats":{"Line":0}},{"line":243,"address":[5760748,5760881,5760536,5760767],"length":1,"stats":{"Line":0}},{"line":244,"address":[5760342,5760905],"length":1,"stats":{"Line":0}},{"line":245,"address":[5760958,5760830],"length":1,"stats":{"Line":0}},{"line":246,"address":[5691040,5691072],"length":1,"stats":{"Line":0}},{"line":247,"address":[5761682,5761631],"length":1,"stats":{"Line":0}},{"line":248,"address":[5761761],"length":1,"stats":{"Line":0}},{"line":249,"address":[5761719,5762352],"length":1,"stats":{"Line":0}},{"line":252,"address":[5761063,5760972],"length":1,"stats":{"Line":0}},{"line":253,"address":[5761548,5761136],"length":1,"stats":{"Line":0}},{"line":255,"address":[5761069],"length":1,"stats":{"Line":0}},{"line":258,"address":[5761204],"length":1,"stats":{"Line":0}},{"line":260,"address":[5761321,5761242],"length":1,"stats":{"Line":0}},{"line":261,"address":[5761423,5761352],"length":1,"stats":{"Line":0}},{"line":265,"address":[5747488],"length":1,"stats":{"Line":0}},{"line":267,"address":[5747775],"length":1,"stats":{"Line":0}},{"line":268,"address":[5763377,5762638],"length":1,"stats":{"Line":0}},{"line":269,"address":[5763575],"length":1,"stats":{"Line":0}},{"line":270,"address":[5763433,5766038],"length":1,"stats":{"Line":0}},{"line":273,"address":[5762756,5762831,5762715],"length":1,"stats":{"Line":0}},{"line":274,"address":[5762849,5762721],"length":1,"stats":{"Line":0}},{"line":275,"address":[5762995],"length":1,"stats":{"Line":0}},{"line":276,"address":[5763185,5762905],"length":1,"stats":{"Line":0}},{"line":278,"address":[5763054,5763086,5763149],"length":1,"stats":{"Line":0}},{"line":279,"address":[5763058],"length":1,"stats":{"Line":0}},{"line":282,"address":[5763159,5763693],"length":1,"stats":{"Line":0}},{"line":283,"address":[5763715,5763796],"length":1,"stats":{"Line":0}},{"line":284,"address":[5763829,5763770,5763813],"length":1,"stats":{"Line":0}},{"line":285,"address":[5763819],"length":1,"stats":{"Line":0}},{"line":287,"address":[5763845],"length":1,"stats":{"Line":0}},{"line":288,"address":[5763909],"length":1,"stats":{"Line":0}},{"line":289,"address":[5764028,5763952],"length":1,"stats":{"Line":0}},{"line":290,"address":[5764083,5764163],"length":1,"stats":{"Line":0}},{"line":291,"address":[5764427,5764627,5764249,5764385],"length":1,"stats":{"Line":0}},{"line":292,"address":[5764304,5764516,5764535,5764649],"length":1,"stats":{"Line":0}},{"line":293,"address":[5764673,5764110],"length":1,"stats":{"Line":0}},{"line":294,"address":[5764598,5764726],"length":1,"stats":{"Line":0}},{"line":297,"address":[5765237,5764795],"length":1,"stats":{"Line":0}},{"line":298,"address":[5765330,5765283],"length":1,"stats":{"Line":0}},{"line":299,"address":[5765409],"length":1,"stats":{"Line":0}},{"line":300,"address":[5765367,5765884],"length":1,"stats":{"Line":0}},{"line":303,"address":[5764732],"length":1,"stats":{"Line":0}},{"line":305,"address":[5683049,5683024],"length":1,"stats":{"Line":0}},{"line":307,"address":[5764915,5764994],"length":1,"stats":{"Line":0}},{"line":308,"address":[5765025,5765096],"length":1,"stats":{"Line":0}},{"line":311,"address":[5747821],"length":1,"stats":{"Line":0}},{"line":313,"address":[5748108],"length":1,"stats":{"Line":0}},{"line":314,"address":[5766909,5766170],"length":1,"stats":{"Line":0}},{"line":315,"address":[5767107],"length":1,"stats":{"Line":0}},{"line":316,"address":[5766965,5769570],"length":1,"stats":{"Line":0}},{"line":319,"address":[5766288,5766363,5766247],"length":1,"stats":{"Line":0}},{"line":320,"address":[5766253,5766381],"length":1,"stats":{"Line":0}},{"line":321,"address":[5766527],"length":1,"stats":{"Line":0}},{"line":322,"address":[5766437,5766717],"length":1,"stats":{"Line":0}},{"line":324,"address":[5766618,5766586,5766681],"length":1,"stats":{"Line":0}},{"line":325,"address":[5766590],"length":1,"stats":{"Line":0}},{"line":328,"address":[5766691,5767225],"length":1,"stats":{"Line":0}},{"line":329,"address":[5767247,5767328],"length":1,"stats":{"Line":0}},{"line":330,"address":[5767361,5767302,5767345],"length":1,"stats":{"Line":0}},{"line":331,"address":[5767351],"length":1,"stats":{"Line":0}},{"line":333,"address":[5767377],"length":1,"stats":{"Line":0}},{"line":334,"address":[5767441],"length":1,"stats":{"Line":0}},{"line":335,"address":[5767560,5767484],"length":1,"stats":{"Line":0}},{"line":336,"address":[5767615,5767695],"length":1,"stats":{"Line":0}},{"line":337,"address":[5682899,5682896],"length":1,"stats":{"Line":0}},{"line":338,"address":[5767836,5768067,5768181,5768048],"length":1,"stats":{"Line":0}},{"line":339,"address":[5767642,5768205],"length":1,"stats":{"Line":0}},{"line":340,"address":[5768130,5768258],"length":1,"stats":{"Line":0}},{"line":343,"address":[5689753,5689728],"length":1,"stats":{"Line":0}},{"line":344,"address":[5768815,5768862],"length":1,"stats":{"Line":0}},{"line":345,"address":[5768941],"length":1,"stats":{"Line":0}},{"line":346,"address":[5768899,5769416],"length":1,"stats":{"Line":0}},{"line":349,"address":[5768264],"length":1,"stats":{"Line":0}},{"line":351,"address":[5768409],"length":1,"stats":{"Line":0}},{"line":353,"address":[5768526,5768447],"length":1,"stats":{"Line":0}},{"line":354,"address":[5768628,5768557],"length":1,"stats":{"Line":0}},{"line":357,"address":[5748154],"length":1,"stats":{"Line":0}},{"line":359,"address":[5748417],"length":1,"stats":{"Line":0}},{"line":360,"address":[5769702,5770411],"length":1,"stats":{"Line":0}},{"line":361,"address":[5770600],"length":1,"stats":{"Line":0}},{"line":362,"address":[5772977,5770467],"length":1,"stats":{"Line":0}},{"line":365,"address":[5769773,5769808,5769883],"length":1,"stats":{"Line":0}},{"line":366,"address":[5769895,5769779],"length":1,"stats":{"Line":0}},{"line":367,"address":[5770041],"length":1,"stats":{"Line":0}},{"line":368,"address":[5769951,5770225],"length":1,"stats":{"Line":0}},{"line":370,"address":[5770100,5770132,5770195],"length":1,"stats":{"Line":0}},{"line":371,"address":[5770104],"length":1,"stats":{"Line":0}},{"line":374,"address":[5770703,5770205],"length":1,"stats":{"Line":0}},{"line":375,"address":[5770798,5770722],"length":1,"stats":{"Line":0}},{"line":376,"address":[5770873,5770806],"length":1,"stats":{"Line":0}},{"line":377,"address":[5770928,5770996],"length":1,"stats":{"Line":0}},{"line":378,"address":[5690976,5690979],"length":1,"stats":{"Line":0}},{"line":379,"address":[5771349,5771479,5771137,5771368],"length":1,"stats":{"Line":0}},{"line":380,"address":[5770949,5771503],"length":1,"stats":{"Line":0}},{"line":381,"address":[5771553,5771431],"length":1,"stats":{"Line":0}},{"line":384,"address":[5689168,5689193],"length":1,"stats":{"Line":0}},{"line":385,"address":[5772221,5772174],"length":1,"stats":{"Line":0}},{"line":386,"address":[5772300],"length":1,"stats":{"Line":0}},{"line":387,"address":[5772823,5772258],"length":1,"stats":{"Line":0}},{"line":390,"address":[5771567,5771648],"length":1,"stats":{"Line":0}},{"line":391,"address":[5772091,5771717],"length":1,"stats":{"Line":0}},{"line":393,"address":[5771654],"length":1,"stats":{"Line":0}},{"line":395,"address":[5683824,5683849],"length":1,"stats":{"Line":0}},{"line":397,"address":[5771800,5771867],"length":1,"stats":{"Line":0}},{"line":398,"address":[5771898,5771966],"length":1,"stats":{"Line":0}}],"covered":1,"coverable":259},{"path":["/","home","dio","knowledge-rs","src","parser","mod.rs"],"content":"use crate::errors::ParseError;\nuse crate::graph::{FileMetrics, FileNode, Import, Item, ItemId, ItemType, Location, Visibility};\nuse regex::Regex;\nuse std::path::Path;\n\n#[derive(Debug, Default)]\npub struct RustParser {\n    patterns: RegexPatterns,\n}\n\n#[derive(Debug)]\npub struct RegexPatterns {\n    pub fn_sig: Regex,\n    pub struct_def: Regex,\n    pub enum_def: Regex,\n    pub vis_pub_in: Regex,\n    pub import_stmt: Regex,\n}\n\nimpl RegexPatterns {\n    pub fn compile() -\u003e Self {\n        // Simple, conservative regexes to avoid catastrophic backtracking\n        let fn_sig = Regex::new(r\"(?m)^\\s*(?P\u003cvis\u003epub(?:\\([^)]*\\))?\\s+)?(?:async\\s+)?(?:const\\s+)?fn\\s+(?P\u003cname\u003e[a-zA-Z_][a-zA-Z0-9_]*)\\s*\\(\").unwrap();\n        let struct_def = Regex::new(r\"(?m)^\\s*(?P\u003cvis\u003epub(?:\\([^)]*\\))?\\s+)?struct\\s+(?P\u003cname\u003e[A-Za-z_][A-Za-z0-9_]*)\").unwrap();\n        let enum_def = Regex::new(r\"(?m)^\\s*(?P\u003cvis\u003epub(?:\\([^)]*\\))?\\s+)?enum\\s+(?P\u003cname\u003e[A-Za-z_][A-Za-z0-9_]*)\").unwrap();\n        let vis_pub_in = Regex::new(r\"^pub\\((?P\u003csc\u003e[^)]+)\\)$\").unwrap();\n        let import_stmt = Regex::new(r\"(?m)^\\s*(?:pub\\s+)?use\\s+([^;{]+?)(?:\\s+as\\s+([A-Za-z_][A-Za-z0-9_]*))?\\s*;\\s*$\").unwrap();\n        Self { fn_sig, struct_def, enum_def, vis_pub_in, import_stmt }\n    }\n}\n\nimpl Default for RegexPatterns {\n    fn default() -\u003e Self { Self::compile() }\n}\n\nimpl RustParser {\n    pub fn new() -\u003e Self {\n        Self { patterns: RegexPatterns::compile() }\n    }\n\n    pub fn parse_file(\u0026self, content: \u0026str, path: \u0026Path) -\u003e Result\u003cFileNode, ParseError\u003e {\n        let items = self.extract_items(content, path);\n        let imports = self.extract_imports(content);\n        let metrics = FileMetrics { item_count: items.len(), import_count: imports.len() };\n        Ok(FileNode { path: path.to_path_buf(), items, imports, metrics })\n    }\n\n    fn extract_items(\u0026self, content: \u0026str, path: \u0026Path) -\u003e Vec\u003cItem\u003e {\n        let mut out = Vec::new();\n\n        for cap in self.patterns.fn_sig.captures_iter(content) {\n            let name = cap.name(\"name\").map(|m| m.as_str()).unwrap_or(\"\").to_string();\n            let vis = cap.name(\"vis\").map(|m| m.as_str().trim()).unwrap_or(\"\");\n            let visibility = parse_visibility(\u0026self.patterns.vis_pub_in, vis);\n            let line = line_number_for(content, cap.get(0).map(|m| m.start()).unwrap_or(0));\n            out.push(Item {\n                id: ItemId(format!(\"fn:{}:{}\", name, line)),\n                item_type: ItemType::Function { is_async: content[..cap.get(0).unwrap().end()].contains(\"async \"), is_const: content[..cap.get(0).unwrap().end()].contains(\"const \") },\n                name,\n                visibility,\n                location: Location { file: path.to_path_buf(), line_start: line, line_end: line },\n                attributes: vec![],\n            });\n        }\n\n        for cap in self.patterns.struct_def.captures_iter(content) {\n            let name = cap.name(\"name\").map(|m| m.as_str()).unwrap_or(\"\").to_string();\n            let vis = cap.name(\"vis\").map(|m| m.as_str().trim()).unwrap_or(\"\");\n            let visibility = parse_visibility(\u0026self.patterns.vis_pub_in, vis);\n            let line = line_number_for(content, cap.get(0).map(|m| m.start()).unwrap_or(0));\n            out.push(Item {\n                id: ItemId(format!(\"struct:{}:{}\", name, line)),\n                item_type: ItemType::Struct { is_tuple: false },\n                name,\n                visibility,\n                location: Location { file: path.to_path_buf(), line_start: line, line_end: line },\n                attributes: vec![],\n            });\n        }\n\n        for cap in self.patterns.enum_def.captures_iter(content) {\n            let name = cap.name(\"name\").map(|m| m.as_str()).unwrap_or(\"\").to_string();\n            let vis = cap.name(\"vis\").map(|m| m.as_str().trim()).unwrap_or(\"\");\n            let visibility = parse_visibility(\u0026self.patterns.vis_pub_in, vis);\n            let line = line_number_for(content, cap.get(0).map(|m| m.start()).unwrap_or(0));\n            out.push(Item {\n                id: ItemId(format!(\"enum:{}:{}\", name, line)),\n                item_type: ItemType::Enum { variant_count: 0 },\n                name,\n                visibility,\n                location: Location { file: path.to_path_buf(), line_start: line, line_end: line },\n                attributes: vec![],\n            });\n        }\n\n        out\n    }\n\n    fn extract_imports(\u0026self, content: \u0026str) -\u003e Vec\u003cImport\u003e {\n        let mut out = Vec::new();\n        for cap in self.patterns.import_stmt.captures_iter(content) {\n            let path = cap.get(1).map(|m| m.as_str().trim()).unwrap_or(\"\").to_string();\n            let alias = cap.get(2).map(|m| m.as_str().to_string());\n            out.push(Import { path, alias });\n        }\n        out\n    }\n}\n\nfn parse_visibility(vis_pub_in: \u0026Regex, vis: \u0026str) -\u003e Visibility {\n    let v = vis.trim();\n    if v.is_empty() { return Visibility::Private; }\n    if v == \"pub\" { return Visibility::Public; }\n    if v == \"pub(crate)\" { return Visibility::PubCrate; }\n    if v == \"pub(super)\" { return Visibility::PubSuper; }\n    if let Some(c) = vis_pub_in.captures(v) {\n        return Visibility::PubIn(c.name(\"sc\").map(|m| m.as_str().to_string()).unwrap_or_default());\n    }\n    Visibility::Private\n}\n\nfn line_number_for(content: \u0026str, byte_idx: usize) -\u003e usize {\n    // 1-based line number\n    content[..byte_idx].bytes().filter(|\u0026b| b == b'\\n').count() + 1\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_extract_fn_struct_enum_and_visibility() {\n        let src = r#\"\n        pub fn top() {}\n        fn hidden() {}\n        pub(crate) struct S;\n        pub(super) enum E { A, B }\n        \"#;\n        let parser = RustParser::new();\n        let file = std::path::Path::new(\"/tmp/test.rs\");\n        let node = parser.parse_file(src, file).expect(\"parse\");\n        // items: 2 fn + 1 struct + 1 enum\n        assert_eq!(node.items.len(), 4);\n        // check visibility parsing\n        let mut names: Vec\u003c(String, Visibility)\u003e = node.items.iter().map(|i| (i.name.clone(), i.visibility.clone())).collect();\n        names.sort_by(|a,b| a.0.cmp(\u0026b.0));\n        assert!(names.iter().any(|(n,v)| n == \"top\" \u0026\u0026 matches!(v, Visibility::Public)));\n        assert!(names.iter().any(|(n,v)| n == \"hidden\" \u0026\u0026 matches!(v, Visibility::Private)));\n        assert!(names.iter().any(|(n,v)| n == \"S\" \u0026\u0026 matches!(v, Visibility::PubCrate)));\n        assert!(names.iter().any(|(n,v)| n == \"E\" \u0026\u0026 matches!(v, Visibility::PubSuper)));\n    }\n\n    #[test]\n    fn test_extract_imports_with_alias() {\n        let src = r#\"\n        use std::collections::HashMap;\n        pub use crate::module::Thing as Alias;\n        \"#;\n        let parser = RustParser::new();\n        let node = parser.parse_file(src, std::path::Path::new(\"/x.rs\")).unwrap();\n        assert_eq!(node.imports.len(), 2);\n        assert!(node.imports.iter().any(|im| im.path.contains(\"std::collections::HashMap\") \u0026\u0026 im.alias.is_none()));\n        assert!(node.imports.iter().any(|im| im.path.contains(\"crate::module::Thing\") \u0026\u0026 im.alias.as_deref() == Some(\"Alias\")));\n    }\n\n    #[test]\n    fn test_async_const_functions_and_tuple_struct() {\n        let src = r#\"\n        pub async fn af() {}\n        pub const fn cf() -\u003e i32 { 0 }\n        pub struct TS(u32, u32);\n        pub(self) fn scoped() {}\n        \"#;\n        let parser = RustParser::new();\n        let node = parser.parse_file(src, std::path::Path::new(\"/y.rs\")).unwrap();\n        let names: Vec\u003c_\u003e = node.items.iter().map(|i| i.name.as_str()).collect();\n        assert!(names.contains(\u0026\"af\"));\n        assert!(names.contains(\u0026\"cf\"));\n        assert!(names.contains(\u0026\"TS\"));\n        // Ensure vis pub(in ..) patterns are accepted and mapped\n        let scoped = node.items.iter().find(|i| i.name == \"scoped\").expect(\"scoped present\");\n        match scoped.visibility {\n            Visibility::PubIn(ref s) =\u003e assert_eq!(s, \"self\"),\n            _ =\u003e panic!(\"expected Visibility::PubIn('self') for scoped\"),\n        }\n        // Sanity: counts align (2 fns + 1 tuple struct + 1 scoped fn)\n        assert_eq!(node.items.len(), 4);\n    }\n}\n","traces":[{"line":21,"address":[7712621,7711616,7712615],"length":1,"stats":{"Line":6}},{"line":23,"address":[10331690],"length":1,"stats":{"Line":6}},{"line":24,"address":[7721525,7721460],"length":1,"stats":{"Line":11}},{"line":25,"address":[9290584,9290885,9291340,9290522,9290725],"length":1,"stats":{"Line":11}},{"line":26,"address":[6782187,6782259],"length":1,"stats":{"Line":10}},{"line":27,"address":[9301075,9301749,9301611,9301056],"length":1,"stats":{"Line":10}},{"line":32,"address":[9273063],"length":1,"stats":{"Line":0}},{"line":33,"address":[7714832,7714840],"length":1,"stats":{"Line":0}},{"line":37,"address":[6652592],"length":1,"stats":{"Line":6}},{"line":38,"address":[7708929],"length":1,"stats":{"Line":6}},{"line":41,"address":[10330893],"length":1,"stats":{"Line":5}},{"line":42,"address":[9353357,9353289,9353428,9353579],"length":1,"stats":{"Line":5}},{"line":43,"address":[7702672],"length":1,"stats":{"Line":5}},{"line":44,"address":[9289563],"length":1,"stats":{"Line":10}},{"line":45,"address":[7702836],"length":1,"stats":{"Line":5}},{"line":48,"address":[9299808],"length":1,"stats":{"Line":5}},{"line":49,"address":[9135446],"length":1,"stats":{"Line":5}},{"line":51,"address":[6656183,6656234,6656354],"length":1,"stats":{"Line":15}},{"line":52,"address":[6689489,6689488],"length":1,"stats":{"Line":16}},{"line":53,"address":[9352506],"length":1,"stats":{"Line":16}},{"line":54,"address":[6780362],"length":1,"stats":{"Line":4}},{"line":55,"address":[7620416,7620417],"length":1,"stats":{"Line":16}},{"line":56,"address":[6781497],"length":1,"stats":{"Line":4}},{"line":57,"address":[10340259],"length":1,"stats":{"Line":4}},{"line":58,"address":[7720280,7720331],"length":1,"stats":{"Line":8}},{"line":59,"address":[7720699],"length":1,"stats":{"Line":4}},{"line":60,"address":[7710979],"length":1,"stats":{"Line":4}},{"line":61,"address":[7711082,7711019],"length":1,"stats":{"Line":8}},{"line":62,"address":[6651690],"length":1,"stats":{"Line":4}},{"line":66,"address":[9289267],"length":1,"stats":{"Line":10}},{"line":67,"address":[6689344,6689345],"length":1,"stats":{"Line":4}},{"line":68,"address":[6533856,6533857],"length":1,"stats":{"Line":4}},{"line":69,"address":[6648509],"length":1,"stats":{"Line":1}},{"line":70,"address":[6659244,6659196],"length":1,"stats":{"Line":4}},{"line":71,"address":[7719079],"length":1,"stats":{"Line":1}},{"line":72,"address":[7708789],"length":1,"stats":{"Line":1}},{"line":73,"address":[7718783],"length":1,"stats":{"Line":1}},{"line":74,"address":[7705321],"length":1,"stats":{"Line":1}},{"line":75,"address":[9139041],"length":1,"stats":{"Line":1}},{"line":76,"address":[9139144,9139081],"length":1,"stats":{"Line":2}},{"line":77,"address":[6241072],"length":1,"stats":{"Line":1}},{"line":81,"address":[9136370,9136231],"length":1,"stats":{"Line":10}},{"line":82,"address":[7629024,7629025],"length":1,"stats":{"Line":4}},{"line":83,"address":[6777099,6777175],"length":1,"stats":{"Line":5}},{"line":84,"address":[6647556],"length":1,"stats":{"Line":3}},{"line":85,"address":[10795474],"length":1,"stats":{"Line":5}},{"line":86,"address":[9768630],"length":1,"stats":{"Line":2}},{"line":87,"address":[6777532],"length":1,"stats":{"Line":1}},{"line":88,"address":[6777766],"length":1,"stats":{"Line":3}},{"line":89,"address":[7703780],"length":1,"stats":{"Line":1}},{"line":90,"address":[9757360,9757493,9758160,9758784,9756968,9757488,9758166,9758803,9756960,9757392],"length":1,"stats":{"Line":9}},{"line":91,"address":[6239444,6239503],"length":1,"stats":{"Line":2}},{"line":92,"address":[6648259],"length":1,"stats":{"Line":1}},{"line":96,"address":[7706596],"length":1,"stats":{"Line":5}},{"line":99,"address":[6774432,6775329,6775335],"length":1,"stats":{"Line":5}},{"line":100,"address":[10795888],"length":1,"stats":{"Line":7}},{"line":101,"address":[7700509,7700569,7700683],"length":1,"stats":{"Line":15}},{"line":102,"address":[10799314],"length":1,"stats":{"Line":10}},{"line":103,"address":[6534064,6534091],"length":1,"stats":{"Line":6}},{"line":104,"address":[7701126],"length":1,"stats":{"Line":2}},{"line":106,"address":[12229600],"length":1,"stats":{"Line":7}},{"line":110,"address":[6643712,6644320,6644326],"length":1,"stats":{"Line":4}},{"line":111,"address":[6643190],"length":1,"stats":{"Line":4}},{"line":112,"address":[9758615,9758659],"length":1,"stats":{"Line":5}},{"line":113,"address":[6245208,6245284],"length":1,"stats":{"Line":8}},{"line":114,"address":[9740473],"length":1,"stats":{"Line":2}},{"line":115,"address":[6644014,6643910],"length":1,"stats":{"Line":2}},{"line":116,"address":[7713178,7713248],"length":1,"stats":{"Line":2}},{"line":117,"address":[7703655,7703553],"length":1,"stats":{"Line":4}},{"line":119,"address":[9133545],"length":1,"stats":{"Line":0}},{"line":122,"address":[7714928],"length":1,"stats":{"Line":4}},{"line":124,"address":[7624160,7624170],"length":1,"stats":{"Line":10}}],"covered":69,"coverable":72},{"path":["/","home","dio","knowledge-rs","src","query","mod.rs"],"content":"use std::collections::{HashMap, HashSet};\nuse std::path::{Path, PathBuf};\n\nuse crate::graph::{ItemId, KnowledgeGraph};\n\n/// Query trait implemented by all query types.\n///\n/// Given an immutable reference to a `KnowledgeGraph`, returns a result of type `R`.\npub trait Query\u003cR\u003e {\n    fn run(\u0026self, graph: \u0026KnowledgeGraph) -\u003e R;\n}\n\n/// List types implementing a given trait name.\n///\n/// Returns rows as `(file_path, type_name)` sorted by file then type.\npub struct TraitImplsQuery {\n    pub trait_name: String,\n}\n\nimpl TraitImplsQuery {\n    /// Create a new query for the provided trait name (e.g., \"Display\").\n    pub fn new(trait_name: \u0026str) -\u003e Self { Self { trait_name: trait_name.to_string() } }\n}\n\n// Returns Vec of (file_path, type_name)\nimpl Query\u003cVec\u003c(PathBuf, String)\u003e\u003e for TraitImplsQuery {\n    fn run(\u0026self, graph: \u0026KnowledgeGraph) -\u003e Vec\u003c(PathBuf, String)\u003e {\n        let mut out: Vec\u003c(PathBuf, String)\u003e = Vec::new();\n        for (path, file) in \u0026graph.files {\n            for it in \u0026file.items {\n                if let crate::graph::ItemType::Impl { trait_name, type_name } = \u0026it.item_type {\n                    if let Some(tn) = trait_name {\n                        if tn == \u0026self.trait_name {\n                            out.push((path.clone(), type_name.clone()));\n                        }\n                    }\n                }\n            }\n        }\n        // Stable sort by file then type\n        out.sort_by(|a, b| a.0.cmp(\u0026b.0).then_with(|| a.1.cmp(\u0026b.1)));\n        out\n    }\n}\n\n/// Return the set of files directly connected to a target file by any relationship\n/// involving items defined in that file (edge endpoints at item-level are projected to file-level).\npub struct ConnectedFilesQuery {\n    pub file: PathBuf,\n}\n\nimpl ConnectedFilesQuery {\n    /// Construct a query targeting the specified file path.\n    pub fn new\u003cP: AsRef\u003cPath\u003e\u003e(file: P) -\u003e Self {\n        Self { file: file.as_ref().to_path_buf() }\n    }\n}\n\nimpl Query\u003cVec\u003cPathBuf\u003e\u003e for ConnectedFilesQuery {\n    fn run(\u0026self, graph: \u0026KnowledgeGraph) -\u003e Vec\u003cPathBuf\u003e {\n        // Build item -\u003e file index and file -\u003e items index\n        let mut item_to_file: HashMap\u003cItemId, PathBuf\u003e = HashMap::new();\n        let mut file_to_items: HashMap\u003cPathBuf, Vec\u003cItemId\u003e\u003e = HashMap::new();\n        for (path, file) in \u0026graph.files {\n            let ids: Vec\u003cItemId\u003e = file.items.iter().map(|i| i.id.clone()).collect();\n            for id in \u0026ids {\n                item_to_file.insert(id.clone(), path.clone());\n            }\n            file_to_items.insert(path.clone(), ids);\n        }\n\n        // Resolve the canonical path in the graph map\n        let Some((target_path, _node)) = graph.files.iter().find(|(p, _)| p == \u0026\u0026self.file) else {\n            return Vec::new();\n        };\n\n        let Some(target_items) = file_to_items.get(target_path) else { return Vec::new(); };\n        let target_set: HashSet\u003cItemId\u003e = target_items.iter().cloned().collect();\n\n        let mut out: HashSet\u003cPathBuf\u003e = HashSet::new();\n        for rel in \u0026graph.relationships {\n            // If edge touches any item in the target file, add the opposing file\n            if target_set.contains(\u0026rel.from_item) {\n                if let Some(fp) = item_to_file.get(\u0026rel.to_item) {\n                    if fp != target_path {\n                        out.insert(fp.clone());\n                    }\n                }\n            }\n            if target_set.contains(\u0026rel.to_item) {\n                if let Some(fp) = item_to_file.get(\u0026rel.from_item) {\n                    if fp != target_path {\n                        out.insert(fp.clone());\n                    }\n                }\n            }\n        }\n\n        let mut v: Vec\u003cPathBuf\u003e = out.into_iter().collect();\n        v.sort();\n        v\n    }\n}\n\n/// Direction for `FunctionUsageQuery`.\npub enum UsageDirection { Callers, Callees }\n\n/// Find callers or callees for a given function name, returning unique file paths.\npub struct FunctionUsageQuery {\n    pub function: String,\n    pub direction: UsageDirection,\n}\n\nimpl FunctionUsageQuery {\n    /// Query files containing callers of the specified function name.\n    pub fn callers(function: \u0026str) -\u003e Self { Self { function: function.to_string(), direction: UsageDirection::Callers } }\n    /// Query files containing callees called by the specified function name.\n    pub fn callees(function: \u0026str) -\u003e Self { Self { function: function.to_string(), direction: UsageDirection::Callees } }\n}\n\nimpl Query\u003cVec\u003cPathBuf\u003e\u003e for FunctionUsageQuery {\n    fn run(\u0026self, graph: \u0026KnowledgeGraph) -\u003e Vec\u003cPathBuf\u003e {\n        // Build indices\n        let mut item_to_file: HashMap\u003cItemId, PathBuf\u003e = HashMap::new();\n        let mut func_name_to_ids: HashMap\u003cString, Vec\u003cItemId\u003e\u003e = HashMap::new();\n        for (path, file) in \u0026graph.files {\n            for item in \u0026file.items {\n                item_to_file.insert(item.id.clone(), path.clone());\n                // crude: function ids contain prefix \"fn:\"; but better match by type and name\n                if let crate::graph::ItemType::Function { .. } = item.item_type {\n                    func_name_to_ids.entry(item.name.clone()).or_default().push(item.id.clone());\n                }\n            }\n        }\n\n        let Some(target_ids) = func_name_to_ids.get(\u0026self.function) else { return Vec::new(); };\n        let target_set: HashSet\u003cItemId\u003e = target_ids.iter().cloned().collect();\n\n        let mut out: HashSet\u003cPathBuf\u003e = HashSet::new();\n        for rel in \u0026graph.relationships {\n            match self.direction {\n                UsageDirection::Callers =\u003e {\n                    if target_set.contains(\u0026rel.to_item) {\n                        if let Some(fp) = item_to_file.get(\u0026rel.from_item) { out.insert(fp.clone()); }\n                    }\n                }\n                UsageDirection::Callees =\u003e {\n                    if target_set.contains(\u0026rel.from_item) {\n                        if let Some(fp) = item_to_file.get(\u0026rel.to_item) { out.insert(fp.clone()); }\n                    }\n                }\n            }\n        }\n\n        let mut v: Vec\u003cPathBuf\u003e = out.into_iter().collect();\n        v.sort();\n        v\n    }\n}\n\n/// Detect cycles over the file-level projection of the graph.\npub struct CycleDetectionQuery;\n\nimpl CycleDetectionQuery {\n    /// Construct a cycle detection query.\n    pub fn new() -\u003e Self { Self }\n}\n\nimpl Query\u003cVec\u003cVec\u003cPathBuf\u003e\u003e\u003e for CycleDetectionQuery {\n    fn run(\u0026self, graph: \u0026KnowledgeGraph) -\u003e Vec\u003cVec\u003cPathBuf\u003e\u003e {\n        // Build file-level adjacency ignoring self loops\n        let mut file_ids: Vec\u003cPathBuf\u003e = graph.files.keys().cloned().collect();\n        file_ids.sort();\n        let index: HashMap\u003cPathBuf, usize\u003e = file_ids.iter().cloned().enumerate().map(|(i, p)| (p, i)).collect();\n\n        // Map each relationship to file-\u003efile edge\n        let mut adj: Vec\u003cVec\u003cusize\u003e\u003e = vec![Vec::new(); file_ids.len()];\n        // Prepare item-\u003efile map\n        let mut item_to_file: HashMap\u003cItemId, usize\u003e = HashMap::new();\n        for (path, file) in \u0026graph.files {\n            if let Some(\u0026i) = index.get(path) {\n                for it in \u0026file.items { item_to_file.insert(it.id.clone(), i); }\n            }\n        }\n        for rel in \u0026graph.relationships {\n            if let (Some(\u0026u), Some(\u0026v)) = (item_to_file.get(\u0026rel.from_item), item_to_file.get(\u0026rel.to_item)) {\n                if u != v { adj[u].push(v); }\n            }\n        }\n\n        // DFS to find simple cycles (not necessarily unique, limited dedup)\n        let mut visited = vec![false; file_ids.len()];\n        let mut stack = vec![false; file_ids.len()];\n        let mut path: Vec\u003cusize\u003e = Vec::new();\n        let mut cycles: Vec\u003cVec\u003cPathBuf\u003e\u003e = Vec::new();\n\n        fn dfs(u: usize, adj: \u0026Vec\u003cVec\u003cusize\u003e\u003e, visited: \u0026mut [bool], stack: \u0026mut [bool], path: \u0026mut Vec\u003cusize\u003e, out: \u0026mut Vec\u003cVec\u003cPathBuf\u003e\u003e, names: \u0026Vec\u003cPathBuf\u003e) {\n            visited[u] = true;\n            stack[u] = true;\n            path.push(u);\n            for \u0026v in \u0026adj[u] {\n                if !visited[v] {\n                    dfs(v, adj, visited, stack, path, out, names);\n                } else if stack[v] {\n                    // Found a cycle; extract from v to end\n                    if let Some(pos) = path.iter().position(|\u0026x| x == v) {\n                        let cyc: Vec\u003cPathBuf\u003e = path[pos..].iter().map(|\u0026i| names[i].clone()).collect();\n                        out.push(cyc);\n                    }\n                }\n            }\n            path.pop();\n            stack[u] = false;\n        }\n\n        for u in 0..file_ids.len() {\n            if !visited[u] { dfs(u, \u0026adj, \u0026mut visited, \u0026mut stack, \u0026mut path, \u0026mut cycles, \u0026file_ids); }\n        }\n\n        cycles\n    }\n}\n\n/// Compute shortest path between two files (directed edges) on the file-level projection.\npub struct ShortestPathQuery {\n    pub from: PathBuf,\n    pub to: PathBuf,\n}\n\nimpl ShortestPathQuery {\n    /// Create a shortest path query from `from` to `to` (file paths).\n    pub fn new\u003cP: AsRef\u003cPath\u003e, Q: AsRef\u003cPath\u003e\u003e(from: P, to: Q) -\u003e Self {\n        Self { from: from.as_ref().to_path_buf(), to: to.as_ref().to_path_buf() }\n    }\n}\n\nimpl Query\u003cVec\u003cPathBuf\u003e\u003e for ShortestPathQuery {\n    fn run(\u0026self, graph: \u0026KnowledgeGraph) -\u003e Vec\u003cPathBuf\u003e {\n        // Map files to indices\n        let mut files: Vec\u003cPathBuf\u003e = graph.files.keys().cloned().collect();\n        files.sort();\n        let idx: HashMap\u003cPathBuf, usize\u003e = files.iter().cloned().enumerate().map(|(i, p)| (p, i)).collect();\n\n        let (Some(\u0026src), Some(\u0026dst)) = (idx.get(\u0026self.from), idx.get(\u0026self.to)) else { return Vec::new(); };\n\n        // Build item-\u003efile index and adjacency list\n        let mut item_to_file: HashMap\u003cItemId, usize\u003e = HashMap::new();\n        for (path, file) in \u0026graph.files {\n            if let Some(\u0026i) = idx.get(path) {\n                for it in \u0026file.items { item_to_file.insert(it.id.clone(), i); }\n            }\n        }\n        let mut adj: Vec\u003cVec\u003cusize\u003e\u003e = vec![Vec::new(); files.len()];\n        for rel in \u0026graph.relationships {\n            if let (Some(\u0026u), Some(\u0026v)) = (item_to_file.get(\u0026rel.from_item), item_to_file.get(\u0026rel.to_item)) {\n                if u != v { adj[u].push(v); }\n            }\n        }\n\n        // BFS\n        let mut prev: Vec\u003cOption\u003cusize\u003e\u003e = vec![None; files.len()];\n        let mut q: std::collections::VecDeque\u003cusize\u003e = std::collections::VecDeque::new();\n        let mut visited = vec![false; files.len()];\n        visited[src] = true;\n        q.push_back(src);\n        while let Some(u) = q.pop_front() {\n            if u == dst { break; }\n            for \u0026v in \u0026adj[u] {\n                if !visited[v] {\n                    visited[v] = true;\n                    prev[v] = Some(u);\n                    q.push_back(v);\n                }\n            }\n        }\n\n        if !visited[dst] { return Vec::new(); }\n\n        // Reconstruct path\n        let mut path_indices: Vec\u003cusize\u003e = Vec::new();\n        let mut cur = dst;\n        while let Some(p) = prev[cur] {\n            path_indices.push(cur);\n            cur = p;\n        }\n        path_indices.push(src);\n        path_indices.reverse();\n\n        path_indices.into_iter().map(|i| files[i].clone()).collect()\n    }\n}\n\n/// Metric for degree centrality used by `HubsQuery` and `ModuleCentralityQuery`.\npub enum CentralityMetric { In, Out, Total }\n\n/// Compute top-N files by degree centrality.\npub struct HubsQuery {\n    pub metric: CentralityMetric,\n    pub top: usize,\n}\n\nimpl HubsQuery {\n    /// Create a hubs query for the given metric and number of results.\n    pub fn new(metric: CentralityMetric, top: usize) -\u003e Self { Self { metric, top } }\n}\n\nimpl Query\u003cVec\u003c(PathBuf, usize, usize)\u003e\u003e for HubsQuery {\n    fn run(\u0026self, graph: \u0026KnowledgeGraph) -\u003e Vec\u003c(PathBuf, usize, usize)\u003e {\n        // Map files to indices\n        let mut files: Vec\u003cPathBuf\u003e = graph.files.keys().cloned().collect();\n        files.sort();\n        let idx: HashMap\u003cPathBuf, usize\u003e = files.iter().cloned().enumerate().map(|(i, p)| (p, i)).collect();\n\n        // Build item-\u003efile index and degree counters\n        let mut item_to_file: HashMap\u003cItemId, usize\u003e = HashMap::new();\n        for (path, file) in \u0026graph.files {\n            if let Some(\u0026i) = idx.get(path) {\n                for it in \u0026file.items { item_to_file.insert(it.id.clone(), i); }\n            }\n        }\n        let n = files.len();\n        let mut indeg = vec![0usize; n];\n        let mut outdeg = vec![0usize; n];\n\n        // Count edges at file level; ignore self-loops\n        for rel in \u0026graph.relationships {\n            if let (Some(\u0026u), Some(\u0026v)) = (item_to_file.get(\u0026rel.from_item), item_to_file.get(\u0026rel.to_item)) {\n                if u != v {\n                    outdeg[u] += 1;\n                    indeg[v] += 1;\n                }\n            }\n        }\n\n        let mut rows: Vec\u003c(PathBuf, usize, usize)\u003e = (0..n)\n            .map(|i| (files[i].clone(), indeg[i], outdeg[i]))\n            .collect();\n\n        // Sort by chosen metric desc, then by path asc for stability\n        rows.sort_by(|a, b| {\n            let (ai, ao) = (a.1, a.2);\n            let (bi, bo) = (b.1, b.2);\n            let ak = match self.metric { CentralityMetric::In =\u003e ai, CentralityMetric::Out =\u003e ao, CentralityMetric::Total =\u003e ai + ao };\n            let bk = match self.metric { CentralityMetric::In =\u003e bi, CentralityMetric::Out =\u003e bo, CentralityMetric::Total =\u003e bi + bo };\n            bk.cmp(\u0026ak).then_with(|| a.0.cmp(\u0026b.0))\n        });\n\n        rows.truncate(self.top);\n        rows\n    }\n}\n\n/// Compute top-N modules (by directory) by degree centrality.\npub struct ModuleCentralityQuery {\n    pub metric: CentralityMetric,\n    pub top: usize,\n}\n\nimpl ModuleCentralityQuery {\n    /// Create a module centrality query for the given metric and number of results.\n    pub fn new(metric: CentralityMetric, top: usize) -\u003e Self { Self { metric, top } }\n}\n\nimpl Query\u003cVec\u003c(PathBuf, usize, usize)\u003e\u003e for ModuleCentralityQuery {\n    fn run(\u0026self, graph: \u0026KnowledgeGraph) -\u003e Vec\u003c(PathBuf, usize, usize)\u003e {\n        // Build list of modules identified by parent directory of file\n        let mut modules: HashSet\u003cPathBuf\u003e = HashSet::new();\n        let mut file_to_module: HashMap\u003cPathBuf, PathBuf\u003e = HashMap::new();\n        for p in graph.files.keys() {\n            let m = p.parent().map(|x| x.to_path_buf()).unwrap_or_else(|| PathBuf::from(\".\"));\n            modules.insert(m.clone());\n            file_to_module.insert(p.clone(), m);\n        }\n\n        let mut mods: Vec\u003cPathBuf\u003e = modules.into_iter().collect();\n        mods.sort();\n        let midx: HashMap\u003cPathBuf, usize\u003e = mods.iter().cloned().enumerate().map(|(i, p)| (p, i)).collect();\n\n        // Map items to module index\n        let mut item_to_mod: HashMap\u003cItemId, usize\u003e = HashMap::new();\n        for (path, file) in \u0026graph.files {\n            let Some(module_path) = file_to_module.get(path) else { continue };\n            if let Some(\u0026mi) = midx.get(module_path) {\n                for it in \u0026file.items { item_to_mod.insert(it.id.clone(), mi); }\n            }\n        }\n\n        let n = mods.len();\n        let mut indeg = vec![0usize; n];\n        let mut outdeg = vec![0usize; n];\n\n        // Count inter-module edges\n        for rel in \u0026graph.relationships {\n            if let (Some(\u0026u), Some(\u0026v)) = (item_to_mod.get(\u0026rel.from_item), item_to_mod.get(\u0026rel.to_item)) {\n                if u != v { outdeg[u] += 1; indeg[v] += 1; }\n            }\n        }\n\n        let mut rows: Vec\u003c(PathBuf, usize, usize)\u003e = (0..n)\n            .map(|i| (mods[i].clone(), indeg[i], outdeg[i]))\n            .collect();\n\n        rows.sort_by(|a, b| {\n            let (ai, ao) = (a.1, a.2);\n            let (bi, bo) = (b.1, b.2);\n            let ak = match self.metric { CentralityMetric::In =\u003e ai, CentralityMetric::Out =\u003e ao, CentralityMetric::Total =\u003e ai + ao };\n            let bk = match self.metric { CentralityMetric::In =\u003e bi, CentralityMetric::Out =\u003e bo, CentralityMetric::Total =\u003e bi + bo };\n            bk.cmp(\u0026ak).then_with(|| a.0.cmp(\u0026b.0))\n        });\n\n        rows.truncate(self.top);\n        rows\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::graph::{FileNode, Item, ItemType, Relationship, RelationshipType};\n\n    fn make_fn(path: \u0026PathBuf, id_prefix: \u0026str, name: \u0026str) -\u003e Item {\n        Item {\n            id: ItemId(format!(\"fn:{}:{}\", name, id_prefix)),\n            item_type: ItemType::Function { is_async: false, is_const: false },\n            name: name.to_string(),\n            visibility: crate::graph::Visibility::Public,\n            location: crate::graph::Location { file: path.clone(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        }\n    }\n\n    // Build a small graph:\n    // src/a.rs (A) -\u003e calls -\u003e src/b.rs (B)\n    // src/b.rs (B) -\u003e calls -\u003e src/c.rs (C)\n    // Optional cycle: c -\u003e a\n    fn graph_fixture(with_cycle: bool) -\u003e KnowledgeGraph {\n        let mut g = KnowledgeGraph::default();\n        let a_path = PathBuf::from(\"src/a.rs\");\n        let b_path = PathBuf::from(\"src/b.rs\");\n        let c_path = PathBuf::from(\"src/c.rs\");\n\n        let a_item = make_fn(\u0026a_path, \"1\", \"fa\");\n        let b_item = make_fn(\u0026b_path, \"2\", \"fb\");\n        let c_item = make_fn(\u0026c_path, \"3\", \"fc\");\n\n        g.files.insert(\n            a_path.clone(),\n            FileNode { path: a_path.clone(), items: vec![a_item.clone()], imports: vec![], metrics: Default::default() },\n        );\n        g.files.insert(\n            b_path.clone(),\n            FileNode { path: b_path.clone(), items: vec![b_item.clone()], imports: vec![], metrics: Default::default() },\n        );\n        g.files.insert(\n            c_path.clone(),\n            FileNode { path: c_path.clone(), items: vec![c_item.clone()], imports: vec![], metrics: Default::default() },\n        );\n\n        g.relationships.push(Relationship {\n            from_item: a_item.id.clone(),\n            to_item: b_item.id.clone(),\n            relationship_type: RelationshipType::Calls { call_type: \"test\".to_string() },\n            strength: 1.0,\n            context: String::new(),\n        });\n        g.relationships.push(Relationship {\n            from_item: b_item.id.clone(),\n            to_item: c_item.id.clone(),\n            relationship_type: RelationshipType::Calls { call_type: \"test\".to_string() },\n            strength: 1.0,\n            context: String::new(),\n        });\n        if with_cycle {\n            g.relationships.push(Relationship {\n                from_item: c_item.id.clone(),\n                to_item: a_item.id.clone(),\n                relationship_type: RelationshipType::Calls { call_type: \"test\".to_string() },\n                strength: 1.0,\n                context: String::new(),\n            });\n        }\n        g\n    }\n\n    #[test]\n    fn connected_files_query_basic() {\n        let g = graph_fixture(false);\n        let q = ConnectedFilesQuery::new(\"src/a.rs\");\n        let res = q.run(\u0026g);\n        // a is connected to b\n        assert!(res.contains(\u0026PathBuf::from(\"src/b.rs\")));\n        // b is connected to a and c as well, but for a we expect only b because c is reached via b (no direct edge)\n        assert!(!res.contains(\u0026PathBuf::from(\"src/c.rs\")));\n    }\n\n    #[test]\n    fn function_usage_callers_and_callees() {\n        let g = graph_fixture(false);\n        // callees of fa should include file of fb\n        let q_callees = FunctionUsageQuery::callees(\"fa\");\n        let callees = q_callees.run(\u0026g);\n        assert!(callees.contains(\u0026PathBuf::from(\"src/b.rs\")));\n\n        // callers of fb should include file of fa\n        let q_callers = FunctionUsageQuery::callers(\"fb\");\n        let callers = q_callers.run(\u0026g);\n        assert!(callers.contains(\u0026PathBuf::from(\"src/a.rs\")));\n    }\n\n    #[test]\n    fn cycle_detection_detects_simple_cycle() {\n        let g = graph_fixture(true);\n        let q = CycleDetectionQuery::new();\n        let cycles = q.run(\u0026g);\n        // Expect at least one cycle involving a -\u003e b -\u003e c -\u003e a\n        assert!(cycles.iter().any(|cyc| {\n            // convert to set for containment check\n            let names: std::collections::HashSet\u003c_\u003e = cyc.iter().cloned().collect();\n            names.contains(\u0026PathBuf::from(\"src/a.rs\")) \u0026\u0026\n            names.contains(\u0026PathBuf::from(\"src/b.rs\")) \u0026\u0026\n            names.contains(\u0026PathBuf::from(\"src/c.rs\"))\n        }));\n    }\n\n    #[test]\n    fn trait_impls_basic() {\n        let mut g = KnowledgeGraph::default();\n        let p = PathBuf::from(\"src/x.rs\");\n        let impl_item = Item {\n            id: ItemId(\"impl:X:Display\".to_string()),\n            item_type: ItemType::Impl { trait_name: Some(\"Display\".to_string()), type_name: \"X\".to_string() },\n            name: \"impl Display for X\".to_string(),\n            visibility: crate::graph::Visibility::PubCrate,\n            location: crate::graph::Location { file: p.clone(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        };\n        g.files.insert(p.clone(), FileNode { path: p.clone(), items: vec![impl_item], imports: vec![], metrics: Default::default() });\n\n        let q = TraitImplsQuery::new(\"Display\");\n        let rows = q.run(\u0026g);\n        assert_eq!(rows.len(), 1);\n        assert_eq!(rows[0].0, p);\n        assert_eq!(rows[0].1, \"X\");\n    }\n}\n","traces":[{"line":22,"address":[6797136,6797159],"length":1,"stats":{"Line":2}},{"line":27,"address":[7182137,7181200,7182131],"length":1,"stats":{"Line":1}},{"line":28,"address":[7192203],"length":1,"stats":{"Line":1}},{"line":29,"address":[7330788,7330721],"length":1,"stats":{"Line":2}},{"line":30,"address":[7192579,7192441],"length":1,"stats":{"Line":2}},{"line":31,"address":[7331179],"length":1,"stats":{"Line":1}},{"line":32,"address":[7331282],"length":1,"stats":{"Line":1}},{"line":33,"address":[7192841],"length":1,"stats":{"Line":1}},{"line":34,"address":[7192906],"length":1,"stats":{"Line":1}},{"line":41,"address":[7861317,7859550,7859536,7861264],"length":1,"stats":{"Line":1}},{"line":42,"address":[7192526],"length":1,"stats":{"Line":1}},{"line":54,"address":[5659290,5659136],"length":1,"stats":{"Line":2}},{"line":55,"address":[5719155,5719217],"length":1,"stats":{"Line":4}},{"line":60,"address":[7193280,7195928,7194780],"length":1,"stats":{"Line":2}},{"line":62,"address":[6799863],"length":1,"stats":{"Line":2}},{"line":63,"address":[7331872],"length":1,"stats":{"Line":2}},{"line":64,"address":[7334226,7332007,7331943],"length":1,"stats":{"Line":6}},{"line":65,"address":[6114992,6115027],"length":1,"stats":{"Line":8}},{"line":66,"address":[7195481,7195401],"length":1,"stats":{"Line":4}},{"line":67,"address":[7195587,7195743,7195766],"length":1,"stats":{"Line":4}},{"line":69,"address":[7195613],"length":1,"stats":{"Line":2}},{"line":73,"address":[6791454,6791440],"length":1,"stats":{"Line":6}},{"line":74,"address":[7332417,7333771],"length":1,"stats":{"Line":0}},{"line":77,"address":[7194033,7195254,7193943,7193878],"length":1,"stats":{"Line":4}},{"line":78,"address":[6800486,6800547],"length":1,"stats":{"Line":4}},{"line":80,"address":[7183208],"length":1,"stats":{"Line":2}},{"line":81,"address":[6800703,6800788],"length":1,"stats":{"Line":4}},{"line":83,"address":[7194790,7194439],"length":1,"stats":{"Line":4}},{"line":84,"address":[6801259],"length":1,"stats":{"Line":2}},{"line":85,"address":[7183964],"length":1,"stats":{"Line":2}},{"line":86,"address":[7194968],"length":1,"stats":{"Line":1}},{"line":90,"address":[7183841,7184067],"length":1,"stats":{"Line":4}},{"line":91,"address":[7195041],"length":1,"stats":{"Line":1}},{"line":92,"address":[7184173],"length":1,"stats":{"Line":1}},{"line":93,"address":[7333673],"length":1,"stats":{"Line":1}},{"line":99,"address":[7183509],"length":1,"stats":{"Line":2}},{"line":100,"address":[7194579,7194662],"length":1,"stats":{"Line":4}},{"line":101,"address":[6801117],"length":1,"stats":{"Line":2}},{"line":116,"address":[7182240,7182263],"length":1,"stats":{"Line":2}},{"line":118,"address":[7190007,7189984],"length":1,"stats":{"Line":2}},{"line":122,"address":[7187728,7188990,7189957],"length":1,"stats":{"Line":1}},{"line":124,"address":[7337239],"length":1,"stats":{"Line":1}},{"line":125,"address":[7187816],"length":1,"stats":{"Line":1}},{"line":126,"address":[7198911,7198847],"length":1,"stats":{"Line":2}},{"line":127,"address":[7200413,7199075],"length":1,"stats":{"Line":2}},{"line":128,"address":[7189608,7189935,7189570],"length":1,"stats":{"Line":1}},{"line":130,"address":[7189732],"length":1,"stats":{"Line":1}},{"line":131,"address":[6793422],"length":1,"stats":{"Line":1}},{"line":136,"address":[7199242,7199117],"length":1,"stats":{"Line":1}},{"line":137,"address":[6791975,6792036],"length":1,"stats":{"Line":2}},{"line":139,"address":[7337849],"length":1,"stats":{"Line":1}},{"line":140,"address":[7199424,7199501],"length":1,"stats":{"Line":2}},{"line":141,"address":[7199614],"length":1,"stats":{"Line":1}},{"line":143,"address":[7338492],"length":1,"stats":{"Line":1}},{"line":144,"address":[7200041],"length":1,"stats":{"Line":1}},{"line":148,"address":[6792672,6792879],"length":1,"stats":{"Line":2}},{"line":149,"address":[7189238],"length":1,"stats":{"Line":1}},{"line":155,"address":[7199639],"length":1,"stats":{"Line":1}},{"line":156,"address":[7199832,7199749],"length":1,"stats":{"Line":2}},{"line":157,"address":[6792571],"length":1,"stats":{"Line":1}},{"line":166,"address":[7334448],"length":1,"stats":{"Line":1}},{"line":170,"address":[7198669,7198106,7195968],"length":1,"stats":{"Line":1}},{"line":172,"address":[7196026],"length":1,"stats":{"Line":1}},{"line":173,"address":[6797456,6797373],"length":1,"stats":{"Line":2}},{"line":174,"address":[6800400,6800408],"length":1,"stats":{"Line":3}},{"line":177,"address":[7185485,7185548,7185583,7187687],"length":1,"stats":{"Line":2}},{"line":179,"address":[7185679],"length":1,"stats":{"Line":1}},{"line":180,"address":[7196710,7196774],"length":1,"stats":{"Line":2}},{"line":181,"address":[7187421,7185978],"length":1,"stats":{"Line":2}},{"line":182,"address":[7198456],"length":1,"stats":{"Line":1}},{"line":185,"address":[7196976],"length":1,"stats":{"Line":1}},{"line":186,"address":[6798301,6799252],"length":1,"stats":{"Line":2}},{"line":187,"address":[6799423],"length":1,"stats":{"Line":1}},{"line":192,"address":[7186207],"length":1,"stats":{"Line":1}},{"line":193,"address":[7186349,7186270],"length":1,"stats":{"Line":2}},{"line":194,"address":[7335833],"length":1,"stats":{"Line":1}},{"line":195,"address":[7186437],"length":1,"stats":{"Line":1}},{"line":197,"address":[7191360],"length":1,"stats":{"Line":1}},{"line":198,"address":[7180524,7180565],"length":1,"stats":{"Line":1}},{"line":199,"address":[7330049,7330120,7330004],"length":1,"stats":{"Line":2}},{"line":200,"address":[7330053],"length":1,"stats":{"Line":1}},{"line":201,"address":[7191580,7191637],"length":1,"stats":{"Line":2}},{"line":202,"address":[7330195,7330280],"length":1,"stats":{"Line":2}},{"line":203,"address":[7330356],"length":1,"stats":{"Line":1}},{"line":204,"address":[7330390],"length":1,"stats":{"Line":1}},{"line":206,"address":[7180990],"length":1,"stats":{"Line":3}},{"line":207,"address":[6806040],"length":1,"stats":{"Line":3}},{"line":208,"address":[7181172],"length":1,"stats":{"Line":1}},{"line":212,"address":[6805696],"length":1,"stats":{"Line":1}},{"line":213,"address":[7191766,7191729],"length":1,"stats":{"Line":1}},{"line":216,"address":[7335953,7336029],"length":1,"stats":{"Line":2}},{"line":217,"address":[6798845,6799053],"length":1,"stats":{"Line":2}},{"line":220,"address":[7336242],"length":1,"stats":{"Line":1}},{"line":232,"address":[5671056,5671336,5671342],"length":1,"stats":{"Line":1}},{"line":233,"address":[5718935,5718875],"length":1,"stats":{"Line":2}},{"line":238,"address":[6797105,6796538,6793584],"length":1,"stats":{"Line":1}},{"line":240,"address":[7201090],"length":1,"stats":{"Line":1}},{"line":241,"address":[6793757,6793840],"length":1,"stats":{"Line":2}},{"line":242,"address":[7339803],"length":1,"stats":{"Line":3}},{"line":244,"address":[7190565,7190644,7193769],"length":1,"stats":{"Line":2}},{"line":247,"address":[7340301],"length":1,"stats":{"Line":1}},{"line":248,"address":[7201899,7201832],"length":1,"stats":{"Line":2}},{"line":249,"address":[7342959,7340559],"length":1,"stats":{"Line":2}},{"line":250,"address":[7204538],"length":1,"stats":{"Line":1}},{"line":253,"address":[7191187,7193473,7191133],"length":1,"stats":{"Line":1}},{"line":254,"address":[6794817,6794738],"length":1,"stats":{"Line":2}},{"line":255,"address":[7340951,7342676],"length":1,"stats":{"Line":2}},{"line":256,"address":[7193395],"length":1,"stats":{"Line":1}},{"line":261,"address":[7340985],"length":1,"stats":{"Line":1}},{"line":262,"address":[7202554],"length":1,"stats":{"Line":1}},{"line":263,"address":[7202617,7202693],"length":1,"stats":{"Line":2}},{"line":264,"address":[6795267,6795173],"length":1,"stats":{"Line":2}},{"line":265,"address":[6795270],"length":1,"stats":{"Line":1}},{"line":266,"address":[7191894],"length":1,"stats":{"Line":1}},{"line":267,"address":[7202967],"length":1,"stats":{"Line":1}},{"line":268,"address":[6795461],"length":1,"stats":{"Line":1}},{"line":269,"address":[7192268],"length":1,"stats":{"Line":1}},{"line":270,"address":[7341780],"length":1,"stats":{"Line":1}},{"line":271,"address":[6795760],"length":1,"stats":{"Line":1}},{"line":272,"address":[6795816],"length":1,"stats":{"Line":1}},{"line":277,"address":[7341476,7341923],"length":1,"stats":{"Line":2}},{"line":280,"address":[7192491],"length":1,"stats":{"Line":1}},{"line":281,"address":[6795999],"length":1,"stats":{"Line":1}},{"line":282,"address":[7192848,7192651,7192736],"length":1,"stats":{"Line":3}},{"line":283,"address":[7203727],"length":1,"stats":{"Line":1}},{"line":284,"address":[7342296],"length":1,"stats":{"Line":1}},{"line":286,"address":[7203769],"length":1,"stats":{"Line":1}},{"line":287,"address":[6796213],"length":1,"stats":{"Line":1}},{"line":289,"address":[6791312,6791347],"length":1,"stats":{"Line":3}},{"line":304,"address":[6790464,6790479],"length":1,"stats":{"Line":2}},{"line":308,"address":[7206358,7207015,7204784],"length":1,"stats":{"Line":1}},{"line":310,"address":[7343346],"length":1,"stats":{"Line":1}},{"line":311,"address":[7343449,7343536],"length":1,"stats":{"Line":2}},{"line":312,"address":[6939208,6939200],"length":1,"stats":{"Line":3}},{"line":315,"address":[7343757],"length":1,"stats":{"Line":1}},{"line":316,"address":[6788840,6788896],"length":1,"stats":{"Line":2}},{"line":317,"address":[7345245,7344056],"length":1,"stats":{"Line":2}},{"line":318,"address":[7195864],"length":1,"stats":{"Line":1}},{"line":321,"address":[7194630],"length":1,"stats":{"Line":1}},{"line":322,"address":[7194673],"length":1,"stats":{"Line":1}},{"line":323,"address":[7194709],"length":1,"stats":{"Line":1}},{"line":326,"address":[7205749,7205833],"length":1,"stats":{"Line":2}},{"line":327,"address":[6789424,6789813],"length":1,"stats":{"Line":2}},{"line":328,"address":[7345214,7345037],"length":1,"stats":{"Line":2}},{"line":329,"address":[6789995,6790100],"length":1,"stats":{"Line":1}},{"line":330,"address":[7195763,7195725,7195669],"length":1,"stats":{"Line":2}},{"line":336,"address":[6939706,6939664],"length":1,"stats":{"Line":3}},{"line":340,"address":[7859760],"length":1,"stats":{"Line":3}},{"line":341,"address":[6113560],"length":1,"stats":{"Line":1}},{"line":342,"address":[7846346],"length":1,"stats":{"Line":1}},{"line":343,"address":[6790464,6790332],"length":1,"stats":{"Line":2}},{"line":344,"address":[6790425,6790489,6790583],"length":1,"stats":{"Line":3}},{"line":345,"address":[6939952,6939592,6939966],"length":1,"stats":{"Line":3}},{"line":348,"address":[7206199],"length":1,"stats":{"Line":1}},{"line":349,"address":[7195269],"length":1,"stats":{"Line":1}},{"line":361,"address":[7345536,7345551],"length":1,"stats":{"Line":2}},{"line":365,"address":[6804240,6805314,6802400],"length":1,"stats":{"Line":1}},{"line":367,"address":[7188295],"length":1,"stats":{"Line":1}},{"line":368,"address":[6802500],"length":1,"stats":{"Line":1}},{"line":369,"address":[6802556,6802628,6805287],"length":1,"stats":{"Line":3}},{"line":370,"address":[7847078,7848032,7848044,7847056],"length":1,"stats":{"Line":4}},{"line":371,"address":[6805087,6805151],"length":1,"stats":{"Line":2}},{"line":372,"address":[7180218],"length":1,"stats":{"Line":1}},{"line":375,"address":[6802781],"length":1,"stats":{"Line":1}},{"line":376,"address":[7177795,7177890],"length":1,"stats":{"Line":2}},{"line":377,"address":[6802200,6802192],"length":1,"stats":{"Line":3}},{"line":380,"address":[6803183],"length":1,"stats":{"Line":1}},{"line":381,"address":[6803294,6803238],"length":1,"stats":{"Line":2}},{"line":382,"address":[7189370,7190609],"length":1,"stats":{"Line":2}},{"line":383,"address":[7190668],"length":1,"stats":{"Line":1}},{"line":384,"address":[6804792],"length":1,"stats":{"Line":1}},{"line":388,"address":[7178440],"length":1,"stats":{"Line":1}},{"line":389,"address":[7327939],"length":1,"stats":{"Line":1}},{"line":390,"address":[6803555],"length":1,"stats":{"Line":1}},{"line":393,"address":[7178599,7178683],"length":1,"stats":{"Line":2}},{"line":394,"address":[6804254,6803825],"length":1,"stats":{"Line":2}},{"line":395,"address":[7179441],"length":1,"stats":{"Line":1}},{"line":400,"address":[6791056,6791098],"length":1,"stats":{"Line":3}},{"line":403,"address":[7190002,7189905],"length":1,"stats":{"Line":3}},{"line":404,"address":[6114088],"length":1,"stats":{"Line":1}},{"line":405,"address":[6791418],"length":1,"stats":{"Line":1}},{"line":406,"address":[7847500,7847632],"length":1,"stats":{"Line":2}},{"line":407,"address":[9281431,9281273,9281337],"length":1,"stats":{"Line":2}},{"line":408,"address":[7861192,7861632,7861646],"length":1,"stats":{"Line":3}},{"line":411,"address":[7179061],"length":1,"stats":{"Line":1}},{"line":412,"address":[7179091],"length":1,"stats":{"Line":1}}],"covered":185,"coverable":186},{"path":["/","home","dio","knowledge-rs","src","utils","mod.rs"],"content":"// Utilities module placeholder per design\npub mod table {\n    // Render a simple ASCII table given headers and rows\n    pub fn render(headers: \u0026[\u0026str], rows: \u0026[Vec\u003cString\u003e]) -\u003e String {\n        let cols = headers.len();\n        let mut widths: Vec\u003cusize\u003e = headers.iter().map(|h| h.len()).collect();\n        for row in rows {\n            for c in 0..cols { widths[c] = widths[c].max(row.get(c).map(|s| s.len()).unwrap_or(0)); }\n        }\n        fn sep(widths: \u0026[usize]) -\u003e String {\n            let mut s = String::from(\"+\");\n            for w in widths { s.push_str(\u0026\"-\".repeat(w + 2)); s.push('+'); }\n            s\n        }\n        fn line(cells: Vec\u003cString\u003e, widths: \u0026[usize]) -\u003e String {\n            let mut s = String::from(\"|\");\n            for (i, cell) in cells.into_iter().enumerate() {\n                let w = widths[i];\n                s.push(' ');\n                s.push_str(\u0026cell);\n                if cell.len() \u003c w { s.push_str(\u0026\" \".repeat(w - cell.len())); }\n                s.push(' ');\n                s.push('|');\n            }\n            s\n        }\n\n        let mut out = String::new();\n        out.push_str(\u0026sep(\u0026widths)); out.push('\\n');\n        out.push_str(\u0026line(headers.iter().map(|s| s.to_string()).collect(), \u0026widths)); out.push('\\n');\n        out.push_str(\u0026sep(\u0026widths)); out.push('\\n');\n        for row in rows {\n            let mut cells = Vec::with_capacity(cols);\n            for i in 0..cols { cells.push(row.get(i).cloned().unwrap_or_default()); }\n            out.push_str(\u0026line(cells, \u0026widths)); out.push('\\n');\n        }\n        out.push_str(\u0026sep(\u0026widths));\n        out\n    }\n}\n\npub mod config {\n    use serde::Deserialize;\n    use std::fs;\n    use std::path::{Path, PathBuf};\n\n    #[derive(Debug, Clone, Deserialize, Default)]\n    pub struct DotConfig {\n        pub clusters: Option\u003cbool\u003e,\n        pub legend: Option\u003cbool\u003e,\n        pub theme: Option\u003cString\u003e,     // \"light\" | \"dark\"\n        pub rankdir: Option\u003cString\u003e,   // \"LR\" | \"TB\"\n        pub splines: Option\u003cString\u003e,   // \"curved\" | \"ortho\" | \"polyline\"\n        pub rounded: Option\u003cbool\u003e,\n    }\n\n    #[derive(Debug, Clone, Deserialize, Default)]\n    pub struct SvgConfig {\n        pub interactive: Option\u003cbool\u003e,\n    }\n\n    #[derive(Debug, Clone, Deserialize, Default)]\n    pub struct QueryConfig {\n        pub default_format: Option\u003cString\u003e, // \"text\" | \"json\"\n    }\n\n    #[derive(Debug, Clone, Deserialize, Default)]\n    pub struct Config {\n        pub root: Option\u003cString\u003e,\n        pub dot: Option\u003cDotConfig\u003e,\n        pub svg: Option\u003cSvgConfig\u003e,\n        pub query: Option\u003cQueryConfig\u003e,\n    }\n\n    fn default_config_path(root: \u0026Path) -\u003e PathBuf {\n        root.join(\"knowledge-rs.toml\")\n    }\n\n    pub fn load_config_at(path: \u0026Path) -\u003e Option\u003cConfig\u003e {\n        let data = fs::read_to_string(path).ok()?;\n        toml::from_str::\u003cConfig\u003e(\u0026data).ok()\n    }\n\n    pub fn load_config_near(root: \u0026Path) -\u003e Option\u003cConfig\u003e {\n        let p = default_config_path(root);\n        if p.exists() { load_config_at(\u0026p) } else { None }\n    }\n}\n\npub mod cache {\n    use serde::{Deserialize, Serialize};\n    use std::collections::HashMap;\n    use std::path::{Path, PathBuf};\n\n    use crate::graph::FileNode;\n\n    #[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq, Eq)]\n    pub struct CacheEntryMeta {\n        pub mtime: u64,\n        pub len: u64,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, Default)]\n    pub struct CacheEntry {\n        pub meta: CacheEntryMeta,\n        pub node: FileNode,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, Default)]\n    pub struct Cache {\n        pub entries: HashMap\u003cPathBuf, CacheEntry\u003e,\n    }\n\n    #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n    pub enum CacheMode {\n        Use,\n        Ignore,\n        Rebuild,\n    }\n\n    fn cache_path(root: \u0026Path) -\u003e PathBuf {\n        root.join(\".knowledge_cache.json\")\n    }\n\n    pub fn load_cache(root: \u0026Path) -\u003e Option\u003cCache\u003e {\n        let path = cache_path(root);\n        let data = std::fs::read_to_string(path).ok()?;\n        serde_json::from_str::\u003cCache\u003e(\u0026data).ok()\n    }\n\n    pub fn save_cache(root: \u0026Path, cache: \u0026Cache) {\n        let path = cache_path(root);\n        if let Ok(data) = serde_json::to_string_pretty(cache) {\n            let _ = std::fs::write(path, data);\n        }\n    }\n\n    pub fn clear_cache(root: \u0026Path) {\n        let path = cache_path(root);\n        let _ = std::fs::remove_file(path);\n    }\n}\n\npub mod file_walker {\n    /// Discover Rust source files under `root`, with an option to bypass ignore rules.\n    pub fn rust_files_with_options(root: \u0026str, no_ignore: bool) -\u003e Vec\u003cString\u003e {\n        let mut out = Vec::new();\n        let mut walker = ignore::WalkBuilder::new(root);\n        // Explicitly enable .gitignore/.ignore support and parent traversal (unless bypassed)\n        walker\n            .follow_links(false)\n            .git_ignore(!no_ignore)\n            .git_global(false)\n            .git_exclude(false)\n            .ignore(!no_ignore)\n            .parents(true);\n        // Build a Gitignore matcher from root-level ignore files for explicit checks (unless bypassed)\n        let root_path = std::path::Path::new(root);\n        let matcher = if no_ignore {\n            None\n        } else {\n            let mut gi_builder = ignore::gitignore::GitignoreBuilder::new(root_path);\n            let gi = root_path.join(\".gitignore\");\n            if gi.exists() { let _ = gi_builder.add(gi); }\n            let ign = root_path.join(\".ignore\");\n            if ign.exists() { let _ = gi_builder.add(ign); }\n            gi_builder.build().ok()\n        };\n        for result in walker.build() {\n            if let Ok(entry) = result {\n                if entry.file_type().map(|t| t.is_file()).unwrap_or(false) {\n                    // Explicit filter using matcher (in addition to WalkBuilder's own filtering)\n                    if let Some(m) = \u0026matcher {\n                        if m.matched(entry.path(), false).is_ignore() { continue; }\n                    }\n                    if entry.path().extension() == Some(std::ffi::OsStr::new(\"rs\")) {\n                        if let Some(s) = entry.path().to_str() {\n                            out.push(s.to_string());\n                        }\n                    }\n                }\n            }\n        }\n        out\n    }\n\n    /// Backward-compatible helper that reads env var and delegates to rust_files_with_options.\n    pub fn rust_files(root: \u0026str) -\u003e Vec\u003cString\u003e {\n        let no_ignore = std::env::var(\"KNOWLEDGE_RS_NO_IGNORE\")\n            .map(|v| v == \"1\" || v.eq_ignore_ascii_case(\"true\"))\n            .unwrap_or(false);\n        rust_files_with_options(root, no_ignore)\n    }\n}\n","traces":[{"line":4,"address":[6757674,6755824,6758850],"length":1,"stats":{"Line":1}},{"line":5,"address":[7695405],"length":1,"stats":{"Line":1}},{"line":6,"address":[8235408,8235422],"length":1,"stats":{"Line":3}},{"line":7,"address":[7352545,7352628],"length":1,"stats":{"Line":2}},{"line":8,"address":[7354980,7352746],"length":1,"stats":{"Line":4}},{"line":10,"address":[6760468,6760474,6759984],"length":1,"stats":{"Line":1}},{"line":11,"address":[7355387],"length":1,"stats":{"Line":1}},{"line":12,"address":[6760059,6760131,6760295],"length":1,"stats":{"Line":3}},{"line":13,"address":[6760256],"length":1,"stats":{"Line":1}},{"line":15,"address":[7699410,7698336],"length":1,"stats":{"Line":1}},{"line":16,"address":[7698384],"length":1,"stats":{"Line":1}},{"line":17,"address":[7698566,7698470,7698717],"length":1,"stats":{"Line":3}},{"line":18,"address":[6759442,6759356,6759493],"length":1,"stats":{"Line":2}},{"line":19,"address":[6759459],"length":1,"stats":{"Line":1}},{"line":20,"address":[6759565],"length":1,"stats":{"Line":1}},{"line":21,"address":[6759619,6759681],"length":1,"stats":{"Line":2}},{"line":22,"address":[6759646],"length":1,"stats":{"Line":1}},{"line":23,"address":[7699364],"length":1,"stats":{"Line":1}},{"line":25,"address":[6759392],"length":1,"stats":{"Line":1}},{"line":28,"address":[6756276],"length":1,"stats":{"Line":1}},{"line":29,"address":[6756283,6756386],"length":1,"stats":{"Line":2}},{"line":30,"address":[7208483,7208448],"length":1,"stats":{"Line":3}},{"line":31,"address":[6756968],"length":1,"stats":{"Line":1}},{"line":32,"address":[7354775,7353713],"length":1,"stats":{"Line":2}},{"line":33,"address":[6757374,6757688],"length":1,"stats":{"Line":2}},{"line":34,"address":[6758334,6757696,6757784],"length":1,"stats":{"Line":3}},{"line":35,"address":[6757943,6758026,6758288],"length":1,"stats":{"Line":1}},{"line":37,"address":[6757403],"length":1,"stats":{"Line":1}},{"line":38,"address":[7697081],"length":1,"stats":{"Line":1}},{"line":75,"address":[6634528],"length":1,"stats":{"Line":1}},{"line":76,"address":[6560693],"length":1,"stats":{"Line":1}},{"line":79,"address":[7627369,7627375,7627056],"length":1,"stats":{"Line":1}},{"line":80,"address":[6635777],"length":1,"stats":{"Line":1}},{"line":81,"address":[7627239,7627302],"length":1,"stats":{"Line":2}},{"line":84,"address":[7620912,7621134,7621128],"length":1,"stats":{"Line":1}},{"line":85,"address":[7625778],"length":1,"stats":{"Line":1}},{"line":86,"address":[6635066,6635004,6635163],"length":1,"stats":{"Line":3}},{"line":121,"address":[7183248],"length":1,"stats":{"Line":5}},{"line":122,"address":[8232357],"length":1,"stats":{"Line":6}},{"line":125,"address":[8240918,8240576,8240912],"length":1,"stats":{"Line":5}},{"line":126,"address":[7181441],"length":1,"stats":{"Line":6}},{"line":127,"address":[9660811],"length":1,"stats":{"Line":5}},{"line":128,"address":[7170652,7170717],"length":1,"stats":{"Line":2}},{"line":131,"address":[7321355,7321326,7320912],"length":1,"stats":{"Line":3}},{"line":132,"address":[7171901],"length":1,"stats":{"Line":3}},{"line":133,"address":[8227974,8228031,8228081],"length":1,"stats":{"Line":9}},{"line":134,"address":[8228218,8228101],"length":1,"stats":{"Line":6}},{"line":138,"address":[7183024],"length":1,"stats":{"Line":1}},{"line":139,"address":[7183044],"length":1,"stats":{"Line":1}},{"line":140,"address":[7172094],"length":1,"stats":{"Line":1}},{"line":146,"address":[6533206,6534684,6531856],"length":1,"stats":{"Line":6}},{"line":147,"address":[6520969],"length":1,"stats":{"Line":4}},{"line":148,"address":[7032106],"length":1,"stats":{"Line":6}},{"line":152,"address":[7032251],"length":1,"stats":{"Line":6}},{"line":155,"address":[9011599],"length":1,"stats":{"Line":6}},{"line":158,"address":[6153230],"length":1,"stats":{"Line":5}},{"line":159,"address":[6521412,6521469],"length":1,"stats":{"Line":6}},{"line":160,"address":[6532411],"length":1,"stats":{"Line":1}},{"line":162,"address":[6532392],"length":1,"stats":{"Line":5}},{"line":163,"address":[6651554,6651630],"length":1,"stats":{"Line":10}},{"line":164,"address":[9011902,9011979,9012054],"length":1,"stats":{"Line":14}},{"line":165,"address":[6521831,6521702],"length":1,"stats":{"Line":14}},{"line":166,"address":[6521981,6521847,6521927],"length":1,"stats":{"Line":15}},{"line":167,"address":[7610827,7610706],"length":1,"stats":{"Line":12}},{"line":169,"address":[6652382,6652261,6652502],"length":1,"stats":{"Line":20}},{"line":170,"address":[7033564,7033754],"length":1,"stats":{"Line":13}},{"line":171,"address":[7712900,7712896],"length":1,"stats":{"Line":26}},{"line":173,"address":[6653032],"length":1,"stats":{"Line":6}},{"line":174,"address":[7034093,7034164],"length":1,"stats":{"Line":13}},{"line":176,"address":[6154914,6155182],"length":1,"stats":{"Line":13}},{"line":177,"address":[6523475],"length":1,"stats":{"Line":7}},{"line":178,"address":[6653686],"length":1,"stats":{"Line":6}},{"line":184,"address":[9012872],"length":1,"stats":{"Line":7}},{"line":188,"address":[6534720],"length":1,"stats":{"Line":1}},{"line":189,"address":[7612546],"length":1,"stats":{"Line":1}},{"line":190,"address":[6523817],"length":1,"stats":{"Line":1}},{"line":192,"address":[7034942],"length":1,"stats":{"Line":1}}],"covered":77,"coverable":77},{"path":["/","home","dio","knowledge-rs","src","visualization","mod.rs"],"content":"use crate::errors::KnowledgeGraphError;\nuse crate::graph::{ItemType, KnowledgeGraph, RelationshipType};\nuse std::collections::HashSet;\n\n#[derive(Debug, Clone, Copy)]\npub enum DotTheme { Light, Dark }\n\n#[derive(Debug, Clone, Copy)]\npub enum RankDir { LR, TB }\n\n#[derive(Debug, Clone, Copy)]\npub enum EdgeStyle { Curved, Ortho, Polyline }\n\n#[derive(Debug, Clone, Copy)]\npub struct DotOptions {\n    pub clusters: bool,\n    pub legend: bool,\n    pub theme: DotTheme,\n    pub rankdir: RankDir,\n    pub splines: EdgeStyle,\n    pub rounded: bool,\n}\n\nimpl Default for DotOptions {\n    fn default() -\u003e Self {\n        Self { clusters: true, legend: true, theme: DotTheme::Light, rankdir: RankDir::LR, splines: EdgeStyle::Curved, rounded: true }\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\npub struct SvgOptions {\n    pub dot: DotOptions,\n    pub interactive: bool,\n}\n\nimpl Default for SvgOptions {\n    fn default() -\u003e Self { Self { dot: DotOptions::default(), interactive: true } }\n}\n\n#[derive(Debug, Default)]\npub struct SvgGenerator;\n\nimpl SvgGenerator {\n    pub fn new() -\u003e Self { Self {} }\n\n    pub fn generate_svg_with_options(\u0026self, graph: \u0026KnowledgeGraph, opts: SvgOptions) -\u003e Result\u003cString, KnowledgeGraphError\u003e {\n        let dot = DotGenerator::new().generate_dot_with_options(graph, opts.dot)?;\n        // Render with Graphviz `dot -Tsvg`\n        let output = std::process::Command::new(\"dot\")\n            .arg(\"-Tsvg\")\n            .stdin(std::process::Stdio::piped())\n            .stdout(std::process::Stdio::piped())\n            .spawn()\n            .and_then(|mut child| {\n                use std::io::Write;\n                if let Some(stdin) = child.stdin.as_mut() {\n                    stdin.write_all(dot.as_bytes())?;\n                }\n                child.wait_with_output()\n            })\n            .map_err(|e| KnowledgeGraphError::Visualization(format!(\"Failed to run graphviz 'dot': {}\", e)))?;\n        if !output.status.success() {\n            return Err(KnowledgeGraphError::Visualization(format!(\"Graphviz 'dot' failed with code {:?}\", output.status.code())));\n        }\n        let mut svg = String::from_utf8(output.stdout).map_err(|e| KnowledgeGraphError::Visualization(format!(\"Invalid UTF-8 from dot: {}\", e)))?;\n        if opts.interactive {\n            svg = enhance_svg(\u0026svg);\n        }\n        Ok(svg)\n    }\n}\n\nfn enhance_svg(svg: \u0026str) -\u003e String {\n    // Inject minimal CSS/JS for hover highlight and clickable nodes\n    let injection = r#\"\n\u003cstyle\u003e\nsvg .node:hover ellipse, svg .node:hover polygon, svg .node:hover path, svg .node:hover rect { filter: brightness(1.15); stroke-width: 2; }\nsvg .edge:hover path { stroke-width: 2.2; }\n\u003c/style\u003e\n\u003cscript\u003e\u003c![CDATA[\n(function(){\n  document.querySelectorAll('g.node a').forEach(function(a){\n    a.addEventListener('click', function(ev){\n      ev.preventDefault();\n      const href = a.getAttribute('xlink:href') || a.getAttribute('href');\n      if (href) { console.log('clicked', href); }\n    });\n  });\n})();\n]]\u003e\u003c/script\u003e\n\"#;\n    if let Some(pos) = svg.rfind(\"\u003c/svg\u003e\") {\n        let mut out = String::with_capacity(svg.len() + injection.len());\n        out.push_str(\u0026svg[..pos]);\n        out.push_str(injection);\n        out.push_str(\u0026svg[pos..]);\n        out\n    } else {\n        let mut out = svg.to_string();\n        out.push_str(injection);\n        out\n    }\n}\n\n#[derive(Debug, Default)]\npub struct DotGenerator;\n\nimpl DotGenerator {\n    pub fn new() -\u003e Self { Self {} }\n\n    pub fn generate_dot(\u0026self, graph: \u0026KnowledgeGraph) -\u003e Result\u003cString, KnowledgeGraphError\u003e {\n        self.generate_dot_with_options(graph, DotOptions::default())\n    }\n\n    pub fn generate_dot_with_options(\u0026self, graph: \u0026KnowledgeGraph, opts: DotOptions) -\u003e Result\u003cString, KnowledgeGraphError\u003e {\n        let mut s = String::new();\n        s.push_str(\"digraph KnowledgeRS {\\n\");\n        let rank = match opts.rankdir { RankDir::LR =\u003e \"LR\", RankDir::TB =\u003e \"TB\" };\n        let splines = match opts.splines { EdgeStyle::Curved =\u003e \"curved\", EdgeStyle::Ortho =\u003e \"ortho\", EdgeStyle::Polyline =\u003e \"polyline\" };\n        let node_style = if opts.rounded { \"filled,rounded\" } else { \"filled\" };\n        s.push_str(\u0026format!(\"  rankdir={};\\n  graph [fontname=Helvetica, splines={}] ;\\n  node [shape=box, fontsize=10, style={}] ;\\n  edge [fontname=Helvetica, fontsize=9];\\n\", rank, splines, node_style));\n\n        if opts.clusters {\n            // Build hierarchical clusters from module roots\n            let mut visited: HashSet\u003cString\u003e = HashSet::new();\n            // Identify roots: files without a module parent\n            let mut roots: Vec\u003c_\u003e = graph\n                .files\n                .keys()\n                .filter(|p| graph.get_module_parent(*p).is_none())\n                .cloned()\n                .collect();\n            // Stable order for determinism\n            roots.sort();\n            for root in roots {\n                self.write_module_cluster(graph, \u0026root, \u0026mut s, \u0026mut visited, opts.theme);\n            }\n        } else {\n            // No clusters: emit all nodes flat\n            let mut paths: Vec\u003c_\u003e = graph.files.keys().cloned().collect();\n            paths.sort();\n            for path in paths {\n                if let Some(file) = graph.files.get(\u0026path) {\n                    for item in \u0026file.items {\n                        let node_id = sanitize_id(\u0026item.id.0);\n                        let (fill, shape) = style_for_item_with_theme(\u0026item.item_type, opts.theme);\n                        let url = format!(\"item://{}\", node_id);\n                        let tooltip = escape_label(\u0026item.name);\n                        s.push_str(\u0026format!(\n                            \"  \\\"{}\\\" [label=\\\"{}\\\", fillcolor=\\\"{}\\\", shape=\\\"{}\\\", URL=\\\"{}\\\", tooltip=\\\"{}\\\"];\\n\",\n                            node_id,\n                            escape_label(\u0026item.name),\n                            fill,\n                            shape,\n                            url,\n                            tooltip\n                        ));\n                    }\n                }\n            }\n        }\n\n        // Emit edges (relationships)\n        for rel in \u0026graph.relationships {\n            let from = sanitize_id(\u0026rel.from_item.0);\n            let to = sanitize_id(\u0026rel.to_item.0);\n            let (label, color, style) = match \u0026rel.relationship_type {\n                RelationshipType::Uses { import_type } =\u003e (format!(\"uses:{}\", import_type), \"#1f77b4\", \"dashed\"),\n                RelationshipType::Implements { trait_name } =\u003e (format!(\"impl:{}\", trait_name), \"#2ca02c\", \"dotted\"),\n                RelationshipType::Contains { containment_type } =\u003e (format!(\"contains:{}\", containment_type), \"#7f7f7f\", \"solid\"),\n                RelationshipType::Extends { extension_type } =\u003e (format!(\"extends:{}\", extension_type), \"#9467bd\", \"dashed\"),\n                RelationshipType::Calls { call_type } =\u003e (format!(\"calls:{}\", call_type), \"#d62728\", \"solid\"),\n            };\n            let penwidth = 0.8_f64.max(rel.strength).min(3.0);\n            s.push_str(\u0026format!(\n                \"  \\\"{}\\\" -\u003e \\\"{}\\\" [label=\\\"{}\\\", color=\\\"{}\\\", style=\\\"{}\\\", penwidth={}];\\n\",\n                from,\n                to,\n                escape_label(\u0026label),\n                color,\n                style,\n                penwidth\n            ));\n        }\n\n        if opts.legend {\n            // Legend cluster\n            s.push_str(\"  subgraph cluster_legend {\\n    label=\\\"Legend\\\";\\n    color=grey;\\n\");\n            let legend_items = [\n                (\"Module\", ItemType::Module { is_inline: false }),\n                (\"Function\", ItemType::Function { is_async: false, is_const: false }),\n                (\"Struct\", ItemType::Struct { is_tuple: false }),\n                (\"Enum\", ItemType::Enum { variant_count: 0 }),\n                (\"Trait\", ItemType::Trait { is_object_safe: false }),\n            ];\n            for (name, t) in legend_items {\n                let (fill, shape) = style_for_item_with_theme(\u0026t, opts.theme);\n                let id = sanitize_id(\u0026format!(\"legend_{}\", name));\n                s.push_str(\u0026format!(\"    \\\"{}\\\" [label=\\\"{}\\\", fillcolor=\\\"{}\\\", shape=\\\"{}\\\"];\\n\", id, name, fill, shape));\n            }\n            s.push_str(\"  }\\n\");\n        }\n\n        s.push_str(\"}\\n\");\n        Ok(s)\n    }\n\n    fn write_module_cluster(\n        \u0026self,\n        graph: \u0026KnowledgeGraph,\n        path: \u0026std::path::PathBuf,\n        out: \u0026mut String,\n        visited: \u0026mut HashSet\u003cString\u003e,\n        theme: DotTheme,\n    ) {\n        let key = path.to_string_lossy().to_string();\n        if !visited.insert(key.clone()) {\n            return;\n        }\n        let cluster_id = format!(\"cluster_{}\", sanitize_id(\u0026key));\n        let label = path.file_name().and_then(|p| p.to_str()).unwrap_or(\"\");\n        out.push_str(\u0026format!(\"  subgraph \\\"{}\\\" {{\\n    label=\\\"{}\\\";\\n    color=lightgrey;\\n\", cluster_id, escape_label(label)));\n\n        if let Some(file) = graph.files.get(path) {\n            for item in \u0026file.items {\n                let node_id = sanitize_id(\u0026item.id.0);\n                let (fill, shape) = style_for_item_with_theme(\u0026item.item_type, theme);\n                let url = format!(\"item://{}\", node_id);\n                let tooltip = escape_label(\u0026item.name);\n                out.push_str(\u0026format!(\n                    \"    \\\"{}\\\" [label=\\\"{}\\\", fillcolor=\\\"{}\\\", shape=\\\"{}\\\", URL=\\\"{}\\\", tooltip=\\\"{}\\\"];\\n\",\n                    node_id,\n                    escape_label(\u0026item.name),\n                    fill,\n                    shape,\n                    url,\n                    tooltip\n                ));\n            }\n        }\n\n        // Children\n        for child in graph.get_module_children(path).iter() {\n            self.write_module_cluster(graph, child, out, visited, theme);\n        }\n        out.push_str(\"  }\\n\");\n    }\n}\n\nfn sanitize_id(s: \u0026str) -\u003e String {\n    s.chars()\n        .map(|c| match c {\n            'a'..='z' | 'A'..='Z' | '0'..='9' | '_' =\u003e c,\n            _ =\u003e '_',\n        })\n        .collect()\n}\n\nfn escape_label(s: \u0026str) -\u003e String {\n    s.replace('\"', \"\\\\\\\"\")\n}\n\nfn style_for_item_with_theme(t: \u0026ItemType, theme: DotTheme) -\u003e (\u0026'static str, \u0026'static str) {\n    match (theme, t) {\n        (DotTheme::Light, ItemType::Module { .. }) =\u003e (\"#e0f3ff\", \"component\"),\n        (DotTheme::Light, ItemType::Function { .. }) =\u003e (\"#e8ffe0\", \"oval\"),\n        (DotTheme::Light, ItemType::Struct { .. }) =\u003e (\"#fff4e0\", \"box\"),\n        (DotTheme::Light, ItemType::Enum { .. }) =\u003e (\"#ffe0f0\", \"hexagon\"),\n        (DotTheme::Light, ItemType::Trait { .. }) =\u003e (\"#f0e0ff\", \"parallelogram\"),\n        (DotTheme::Light, ItemType::Impl { .. }) =\u003e (\"#f0fff0\", \"box3d\"),\n        (DotTheme::Light, ItemType::Const) =\u003e (\"#ffffe0\", \"note\"),\n        (DotTheme::Light, ItemType::Static { .. }) =\u003e (\"#ffffe0\", \"folder\"),\n        (DotTheme::Light, ItemType::Type) =\u003e (\"#f0ffff\", \"box\"),\n        (DotTheme::Light, ItemType::Macro) =\u003e (\"#e0ffe8\", \"cds\"),\n\n        (DotTheme::Dark, ItemType::Module { .. }) =\u003e (\"#124559\", \"component\"),\n        (DotTheme::Dark, ItemType::Function { .. }) =\u003e (\"#0b6e4f\", \"oval\"),\n        (DotTheme::Dark, ItemType::Struct { .. }) =\u003e (\"#7a4c00\", \"box\"),\n        (DotTheme::Dark, ItemType::Enum { .. }) =\u003e (\"#6a1e44\", \"hexagon\"),\n        (DotTheme::Dark, ItemType::Trait { .. }) =\u003e (\"#3c2a5a\", \"parallelogram\"),\n        (DotTheme::Dark, ItemType::Impl { .. }) =\u003e (\"#1a5e1a\", \"box3d\"),\n        (DotTheme::Dark, ItemType::Const) =\u003e (\"#6b6b00\", \"note\"),\n        (DotTheme::Dark, ItemType::Static { .. }) =\u003e (\"#6b6b00\", \"folder\"),\n        (DotTheme::Dark, ItemType::Type) =\u003e (\"#004f4f\", \"box\"),\n        (DotTheme::Dark, ItemType::Macro) =\u003e (\"#0f5e3a\", \"cds\"),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::graph::ItemType;\n\n    #[test]\n    fn test_sanitize_id_basic() {\n        let s = \"file:/path/to:thing.rs#1\";\n        let got = sanitize_id(s);\n        // Allowed: letters, numbers, underscore; others -\u003e underscore\n        assert_eq!(got, \"file__path_to_thing_rs_1\");\n        assert_eq!(sanitize_id(\"abc_DEF012\"), \"abc_DEF012\");\n    }\n\n    #[test]\n    fn test_escape_label_quotes() {\n        let s = \"a\\\"b\\\"c\";\n        let got = escape_label(s);\n        assert_eq!(got, \"a\\\\\\\"b\\\\\\\"c\");\n    }\n\n    #[test]\n    fn test_style_for_item_with_theme_all_variants() {\n        // Light theme expectations\n        let cases_light: Vec\u003c(ItemType, (\u0026str, \u0026str))\u003e = vec![\n            (ItemType::Module { is_inline: false }, (\"#e0f3ff\", \"component\")),\n            (ItemType::Function { is_async: false, is_const: false }, (\"#e8ffe0\", \"oval\")),\n            (ItemType::Struct { is_tuple: false }, (\"#fff4e0\", \"box\")),\n            (ItemType::Enum { variant_count: 0 }, (\"#ffe0f0\", \"hexagon\")),\n            (ItemType::Trait { is_object_safe: false }, (\"#f0e0ff\", \"parallelogram\")),\n            (ItemType::Impl { trait_name: None, type_name: \"T\".into() }, (\"#f0fff0\", \"box3d\")),\n            (ItemType::Const, (\"#ffffe0\", \"note\")),\n            (ItemType::Static { is_mut: false }, (\"#ffffe0\", \"folder\")),\n            (ItemType::Type, (\"#f0ffff\", \"box\")),\n            (ItemType::Macro, (\"#e0ffe8\", \"cds\")),\n        ];\n        for (t, expected) in cases_light {\n            assert_eq!(style_for_item_with_theme(\u0026t, DotTheme::Light), expected);\n        }\n\n        // Dark theme expectations\n        let cases_dark: Vec\u003c(ItemType, (\u0026str, \u0026str))\u003e = vec![\n            (ItemType::Module { is_inline: false }, (\"#124559\", \"component\")),\n            (ItemType::Function { is_async: false, is_const: false }, (\"#0b6e4f\", \"oval\")),\n            (ItemType::Struct { is_tuple: false }, (\"#7a4c00\", \"box\")),\n            (ItemType::Enum { variant_count: 0 }, (\"#6a1e44\", \"hexagon\")),\n            (ItemType::Trait { is_object_safe: false }, (\"#3c2a5a\", \"parallelogram\")),\n            (ItemType::Impl { trait_name: None, type_name: \"T\".into() }, (\"#1a5e1a\", \"box3d\")),\n            (ItemType::Const, (\"#6b6b00\", \"note\")),\n            (ItemType::Static { is_mut: false }, (\"#6b6b00\", \"folder\")),\n            (ItemType::Type, (\"#004f4f\", \"box\")),\n            (ItemType::Macro, (\"#0f5e3a\", \"cds\")),\n        ];\n        for (t, expected) in cases_dark {\n            assert_eq!(style_for_item_with_theme(\u0026t, DotTheme::Dark), expected);\n        }\n    }\n\n    #[test]\n    fn test_enhance_svg_injection() {\n        let minimal = \"\u003csvg\u003e\u003c/svg\u003e\";\n        let out = enhance_svg(minimal);\n        assert!(out.contains(\"\u003cstyle\u003e\"));\n        assert!(out.ends_with(\"\u003c/svg\u003e\"));\n\n        // No closing tag case\n        let no_close = \"\u003csvg\u003e\";\n        let out2 = enhance_svg(no_close);\n        assert!(out2.contains(\"\u003cstyle\u003e\"));\n    }\n}\n","traces":[{"line":37,"address":[7272816,7272820],"length":1,"stats":{"Line":0}},{"line":44,"address":[8342448],"length":1,"stats":{"Line":0}},{"line":46,"address":[6922407,6922233,6920192],"length":1,"stats":{"Line":0}},{"line":47,"address":[8335923],"length":1,"stats":{"Line":0}},{"line":49,"address":[6920995,6920885,6920565],"length":1,"stats":{"Line":0}},{"line":51,"address":[8346250],"length":1,"stats":{"Line":0}},{"line":52,"address":[8336406],"length":1,"stats":{"Line":0}},{"line":54,"address":[7335889],"length":1,"stats":{"Line":0}},{"line":56,"address":[7299357,7299275],"length":1,"stats":{"Line":0}},{"line":57,"address":[7365665,7365751],"length":1,"stats":{"Line":0}},{"line":59,"address":[8326500,8326304],"length":1,"stats":{"Line":0}},{"line":61,"address":[7271344,7271366],"length":1,"stats":{"Line":0}},{"line":62,"address":[8346756],"length":1,"stats":{"Line":0}},{"line":63,"address":[8333489,8333586],"length":1,"stats":{"Line":0}},{"line":65,"address":[7296655,7295688,7296005],"length":1,"stats":{"Line":0}},{"line":66,"address":[7278388,7278057],"length":1,"stats":{"Line":0}},{"line":67,"address":[8347583,8347609,8347506],"length":1,"stats":{"Line":0}},{"line":69,"address":[8334117],"length":1,"stats":{"Line":0}},{"line":73,"address":[7297671,7297665,7297104],"length":1,"stats":{"Line":1}},{"line":75,"address":[8348283],"length":1,"stats":{"Line":1}},{"line":92,"address":[8338422,8338997],"length":1,"stats":{"Line":2}},{"line":93,"address":[7279210,7279162,7279033],"length":1,"stats":{"Line":2}},{"line":94,"address":[8338638,8338730],"length":1,"stats":{"Line":2}},{"line":95,"address":[7297517],"length":1,"stats":{"Line":1}},{"line":96,"address":[7279339],"length":1,"stats":{"Line":1}},{"line":97,"address":[6923207],"length":1,"stats":{"Line":1}},{"line":99,"address":[9768824],"length":1,"stats":{"Line":1}},{"line":100,"address":[8338579],"length":1,"stats":{"Line":1}},{"line":101,"address":[8348850],"length":1,"stats":{"Line":1}},{"line":109,"address":[8349488],"length":1,"stats":{"Line":0}},{"line":111,"address":[7302304],"length":1,"stats":{"Line":0}},{"line":112,"address":[7326577],"length":1,"stats":{"Line":0}},{"line":115,"address":[7280976,7284011,7289579],"length":1,"stats":{"Line":0}},{"line":116,"address":[9770828],"length":1,"stats":{"Line":0}},{"line":117,"address":[7310329],"length":1,"stats":{"Line":0}},{"line":118,"address":[7310399],"length":1,"stats":{"Line":0}},{"line":119,"address":[8350635],"length":1,"stats":{"Line":0}},{"line":120,"address":[6925227],"length":1,"stats":{"Line":0}},{"line":121,"address":[8337541],"length":1,"stats":{"Line":0}},{"line":123,"address":[7311062],"length":1,"stats":{"Line":0}},{"line":125,"address":[9771647],"length":1,"stats":{"Line":0}},{"line":127,"address":[7302271],"length":1,"stats":{"Line":0}},{"line":130,"address":[7329798],"length":1,"stats":{"Line":0}},{"line":134,"address":[7302435,7302527],"length":1,"stats":{"Line":0}},{"line":135,"address":[8340564,8340362],"length":1,"stats":{"Line":0}},{"line":136,"address":[7302825],"length":1,"stats":{"Line":0}},{"line":140,"address":[8341352,8341397],"length":1,"stats":{"Line":0}},{"line":141,"address":[7282095,7282003],"length":1,"stats":{"Line":0}},{"line":142,"address":[7311492,7311290],"length":1,"stats":{"Line":0}},{"line":143,"address":[7311569,7311717],"length":1,"stats":{"Line":0}},{"line":144,"address":[9772316,9772385],"length":1,"stats":{"Line":0}},{"line":145,"address":[7328443],"length":1,"stats":{"Line":0}},{"line":146,"address":[7282833,7282907],"length":1,"stats":{"Line":0}},{"line":147,"address":[7312155],"length":1,"stats":{"Line":0}},{"line":148,"address":[7301425,7301330],"length":1,"stats":{"Line":0}},{"line":149,"address":[7302134,7301550],"length":1,"stats":{"Line":0}},{"line":152,"address":[7283311,7283216],"length":1,"stats":{"Line":0}},{"line":164,"address":[8341907,8344165],"length":1,"stats":{"Line":0}},{"line":165,"address":[8343149,8340868],"length":1,"stats":{"Line":0}},{"line":166,"address":[7287113,7287196],"length":1,"stats":{"Line":0}},{"line":167,"address":[7305432,7305947],"length":1,"stats":{"Line":0}},{"line":168,"address":[8356586,8356860],"length":1,"stats":{"Line":0}},{"line":169,"address":[8347304,8346745],"length":1,"stats":{"Line":0}},{"line":170,"address":[7306279,7305560],"length":1,"stats":{"Line":0}},{"line":171,"address":[8356727,8357606],"length":1,"stats":{"Line":0}},{"line":172,"address":[8344517,8343478],"length":1,"stats":{"Line":0}},{"line":174,"address":[8344782,8343867],"length":1,"stats":{"Line":0}},{"line":175,"address":[7288820,7289390],"length":1,"stats":{"Line":0}},{"line":179,"address":[8358114],"length":1,"stats":{"Line":0}},{"line":186,"address":[7330476],"length":1,"stats":{"Line":0}},{"line":188,"address":[7303115],"length":1,"stats":{"Line":0}},{"line":189,"address":[9775170],"length":1,"stats":{"Line":0}},{"line":190,"address":[6928733],"length":1,"stats":{"Line":0}},{"line":191,"address":[7330658],"length":1,"stats":{"Line":0}},{"line":192,"address":[7285135],"length":1,"stats":{"Line":0}},{"line":193,"address":[8354580],"length":1,"stats":{"Line":0}},{"line":194,"address":[8341389],"length":1,"stats":{"Line":0}},{"line":196,"address":[7304110,7303986],"length":1,"stats":{"Line":0}},{"line":197,"address":[9775982,9775731],"length":1,"stats":{"Line":0}},{"line":198,"address":[9776046],"length":1,"stats":{"Line":0}},{"line":199,"address":[7315794],"length":1,"stats":{"Line":0}},{"line":201,"address":[7331672],"length":1,"stats":{"Line":0}},{"line":204,"address":[7330486],"length":1,"stats":{"Line":0}},{"line":205,"address":[9775839],"length":1,"stats":{"Line":0}},{"line":208,"address":[8345381,8342608,8345696],"length":1,"stats":{"Line":0}},{"line":216,"address":[6917189],"length":1,"stats":{"Line":0}},{"line":217,"address":[8342888],"length":1,"stats":{"Line":0}},{"line":220,"address":[7302833,7302888],"length":1,"stats":{"Line":0}},{"line":221,"address":[8333365,8333448],"length":1,"stats":{"Line":0}},{"line":222,"address":[8333608],"length":1,"stats":{"Line":0}},{"line":224,"address":[7303748],"length":1,"stats":{"Line":0}},{"line":225,"address":[7303927,7303834],"length":1,"stats":{"Line":0}},{"line":226,"address":[8330900],"length":1,"stats":{"Line":0}},{"line":227,"address":[7293202,7293130],"length":1,"stats":{"Line":0}},{"line":228,"address":[9764770],"length":1,"stats":{"Line":0}},{"line":229,"address":[8334713,8334630],"length":1,"stats":{"Line":0}},{"line":230,"address":[7293588,7294168],"length":1,"stats":{"Line":0}},{"line":233,"address":[7342141,7342061],"length":1,"stats":{"Line":0}},{"line":243,"address":[7292921,7294283],"length":1,"stats":{"Line":0}},{"line":244,"address":[7305444,7305531],"length":1,"stats":{"Line":0}},{"line":246,"address":[8332331],"length":1,"stats":{"Line":0}},{"line":250,"address":[7308960],"length":1,"stats":{"Line":1}},{"line":251,"address":[7298050],"length":1,"stats":{"Line":1}},{"line":252,"address":[9760774,9760688],"length":1,"stats":{"Line":3}},{"line":253,"address":[7364973,7365010,7365057],"length":1,"stats":{"Line":3}},{"line":254,"address":[7365064],"length":1,"stats":{"Line":1}},{"line":259,"address":[7279552],"length":1,"stats":{"Line":1}},{"line":260,"address":[7279573],"length":1,"stats":{"Line":1}},{"line":263,"address":[8339328],"length":1,"stats":{"Line":1}},{"line":264,"address":[9769631],"length":1,"stats":{"Line":1}},{"line":265,"address":[9769775],"length":1,"stats":{"Line":1}},{"line":266,"address":[6923902],"length":1,"stats":{"Line":1}},{"line":267,"address":[9769869],"length":1,"stats":{"Line":1}},{"line":268,"address":[7280188],"length":1,"stats":{"Line":1}},{"line":269,"address":[7280235],"length":1,"stats":{"Line":1}},{"line":270,"address":[7280282],"length":1,"stats":{"Line":1}},{"line":271,"address":[7338009],"length":1,"stats":{"Line":1}},{"line":272,"address":[8336424],"length":1,"stats":{"Line":1}},{"line":273,"address":[8349764],"length":1,"stats":{"Line":1}},{"line":274,"address":[8339920],"length":1,"stats":{"Line":1}},{"line":276,"address":[7338192],"length":1,"stats":{"Line":1}},{"line":277,"address":[7338236],"length":1,"stats":{"Line":1}},{"line":278,"address":[8340056],"length":1,"stats":{"Line":1}},{"line":279,"address":[6924455],"length":1,"stats":{"Line":1}},{"line":280,"address":[8336742],"length":1,"stats":{"Line":1}},{"line":281,"address":[8340197],"length":1,"stats":{"Line":1}},{"line":282,"address":[8336836],"length":1,"stats":{"Line":1}},{"line":283,"address":[7338515],"length":1,"stats":{"Line":1}},{"line":284,"address":[6924690],"length":1,"stats":{"Line":1}},{"line":285,"address":[7299153],"length":1,"stats":{"Line":1}}],"covered":40,"coverable":130},{"path":["/","home","dio","knowledge-rs","tests","cache_modes.rs"],"content":"use knowledge_rs::graph::KnowledgeGraph;\nuse knowledge_rs::utils::cache::{self, CacheMode};\nuse std::fs::{self, File};\nuse std::io::Write;\nuse std::path::{Path, PathBuf};\nuse std::thread;\nuse std::time::Duration;\n\nfn write_file(path: \u0026Path, content: \u0026str) {\n    if let Some(parent) = path.parent() { let _ = fs::create_dir_all(parent); }\n    let mut f = File::create(path).unwrap();\n    f.write_all(content.as_bytes()).unwrap();\n    f.flush().unwrap();\n}\n\nfn read_cache_meta_len(root: \u0026Path, rel: \u0026str) -\u003e Option\u003c(u64, u64)\u003e {\n    let cache = cache::load_cache(root)?;\n    let key = root.join(rel);\n    let entry = cache.entries.get(\u0026key)?;\n    Some((entry.meta.mtime, entry.meta.len))\n}\n\nfn count_cache_entries(root: \u0026Path) -\u003e usize {\n    cache::load_cache(root).map(|c| c.entries.len()).unwrap_or(0)\n}\n\nfn make_proj(tmp: \u0026Path) -\u003e PathBuf {\n    let root = tmp.join(\"proj\");\n    // minimal Rust sources\n    write_file(\u0026root.join(\"src/lib.rs\"), \"pub fn a() {}\\npub mod m;\\n\");\n    write_file(\u0026root.join(\"src/m.rs\"), \"pub fn b() {}\\n\");\n    root\n}\n\n#[test]\nfn cache_mode_use_detects_changes_and_prunes_removed() {\n    let tmp = tempfile::tempdir().unwrap();\n    let root = make_proj(tmp.path());\n\n    // First build: creates cache with 2 files\n    let g1 = KnowledgeGraph::build_from_directory_with_cache(\u0026root, CacheMode::Use).unwrap();\n    assert!(g1.files.len() \u003e= 2);\n    assert_eq!(count_cache_entries(\u0026root), 2);\n\n    // Record meta of m.rs\n    let m1 = read_cache_meta_len(\u0026root, \"src/m.rs\").unwrap();\n\n    // Touch change in m.rs (ensure mtime changes)\n    thread::sleep(Duration::from_millis(1100));\n    write_file(\u0026root.join(\"src/m.rs\"), \"pub fn b() {}\\npub fn c() {}\\n\");\n\n    // Second build with Use should reuse lib.rs and reparse m.rs\n    let _g2 = KnowledgeGraph::build_from_directory_with_cache(\u0026root, CacheMode::Use).unwrap();\n    let m2 = read_cache_meta_len(\u0026root, \"src/m.rs\").unwrap();\n    assert_ne!(m1, m2, \"cache entry for modified file should update\");\n    assert_eq!(count_cache_entries(\u0026root), 2);\n\n    // Remove m.rs; build again should prune\n    fs::remove_file(root.join(\"src/m.rs\")).unwrap();\n    let _g3 = KnowledgeGraph::build_from_directory_with_cache(\u0026root, CacheMode::Use).unwrap();\n    assert_eq!(count_cache_entries(\u0026root), 1);\n}\n\n#[test]\nfn cache_mode_ignore_rebuilds_without_reuse() {\n    let tmp = tempfile::tempdir().unwrap();\n    let root = make_proj(tmp.path());\n\n    // Seed cache by a normal build\n    let _ = KnowledgeGraph::build_from_directory_with_cache(\u0026root, CacheMode::Use).unwrap();\n    let before = read_cache_meta_len(\u0026root, \"src/m.rs\").unwrap();\n\n    thread::sleep(Duration::from_millis(1100));\n    // Build with Ignore even if file unchanged should still parse and rewrite cache (mtime may or may not change depending on FS; ensure len change)\n    write_file(\u0026root.join(\"src/lib.rs\"), \"pub fn a() {}\\npub mod m;\\npub fn z() {}\\n\");\n    let _ = KnowledgeGraph::build_from_directory_with_cache(\u0026root, CacheMode::Ignore).unwrap();\n    let after = read_cache_meta_len(\u0026root, \"src/m.rs\").unwrap();\n    // m.rs unchanged so meta can be equal; ensure entries count preserved and lib.rs updated len\n    assert_eq!(count_cache_entries(\u0026root), 2);\n    let lib = read_cache_meta_len(\u0026root, \"src/lib.rs\").unwrap();\n    assert!(lib.1 \u003e 0);\n    assert!(before.1 \u003e 0);\n    // just sanity check access\n    let _ = after;\n}\n\n#[test]\nfn cache_mode_rebuild_clears_cache_file() {\n    let tmp = tempfile::tempdir().unwrap();\n    let root = make_proj(tmp.path());\n\n    let _ = KnowledgeGraph::build_from_directory_with_cache(\u0026root, CacheMode::Use).unwrap();\n    assert_eq!(count_cache_entries(\u0026root), 2);\n\n    // Rebuild should remove old cache then recreate\n    cache::clear_cache(\u0026root);\n    assert_eq!(count_cache_entries(\u0026root), 0);\n    let _ = KnowledgeGraph::build_from_directory_with_cache(\u0026root, CacheMode::Rebuild).unwrap();\n    assert_eq!(count_cache_entries(\u0026root), 2);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","cli_cache_modes.rs"],"content":"use assert_cmd::prelude::*;\nuse std::fs;\nuse std::io::Write;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse tempfile::tempdir;\n\n#[test]\nfn cli_build_cache_modes_succeed() {\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    // Minimal crate\n    write_file(\u0026src.join(\"lib.rs\"), r#\"\n        pub fn f() {}\n    \"#);\n\n    let json = root.join(\"graph.json\");\n\n    // Default (Use cache)\n    let mut use_cache = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    use_cache.arg(\"build\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--json\").arg(\u0026json);\n    use_cache.assert().success();\n    assert!(json.exists());\n\n    // Rebuild\n    let mut rebuild = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    rebuild.arg(\"build\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--json\").arg(\u0026json)\n        .arg(\"--rebuild\");\n    rebuild.assert().success();\n    assert!(json.exists());\n\n    // No-cache\n    let mut no_cache = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    no_cache.arg(\"build\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--json\").arg(\u0026json)\n        .arg(\"--no-cache\");\n    no_cache.assert().success();\n    assert!(json.exists());\n}\n\nfn write_file(path: \u0026PathBuf, content: \u0026str) {\n    let mut f = fs::File::create(path).unwrap();\n    f.write_all(content.as_bytes()).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","cli_more_coverage.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::fs;\nuse std::io::Write;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse tempfile::tempdir;\n\nfn write_file(path: \u0026PathBuf, content: \u0026str) {\n    if let Some(parent) = path.parent() { let _ = fs::create_dir_all(parent); }\n    let mut f = fs::File::create(path).unwrap();\n    f.write_all(content.as_bytes()).unwrap();\n}\n\n#[test]\nfn build_uses_config_overrides_and_save() {\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    // simple crate\n    write_file(\u0026src.join(\"lib.rs\"), \"pub fn top() {}\\n\");\n\n    // config file overriding DOT and SVG options + query defaults\n    let cfg_path = root.join(\"knowledge-rs.toml\");\n    write_file(\u0026cfg_path, r#\"\n[dot]\nclusters = true\nlegend = true\ntheme = \"dark\"\nrankdir = \"TB\"\nsplines = \"polyline\"\nrounded = false\n\n[svg]\ninteractive = true\n\n[query]\ndefault_format = \"json\"\n\"#);\n\n    let dot_out = root.join(\"graph.dot\");\n    let svg_out = root.join(\"graph.svg\");\n    let json_out = root.join(\"graph.json\");\n\n    // run build with config and outputs and save\n    let mut cmd = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    cmd.arg(\"build\")\n        .arg(\"--path\").arg(\u0026root)\n        .arg(\"--config\").arg(\u0026cfg_path)\n        .arg(\"--dot\").arg(\u0026dot_out)\n        .arg(\"--json\").arg(\u0026json_out)\n        .arg(\"--save\").arg(root.join(\"saved.json\"));\n    // Append svg flag only if graphviz dot is present\n    let dot_available = Command::new(\"dot\").arg(\"-V\").output().is_ok();\n    if dot_available {\n        cmd.arg(\"--svg\").arg(\u0026svg_out);\n    }\n    cmd.assert().success().stdout(predicate::str::contains(\"Build completed for path\"));\n\n    // dot reflects config overrides\n    let dot_str = fs::read_to_string(\u0026dot_out).unwrap();\n    assert!(dot_str.contains(\"rankdir=TB\"));\n    assert!(dot_str.contains(\"splines=polyline\"));\n\n    // svg produced if dot is available\n    if dot_available {\n        assert!(svg_out.exists());\n    }\n    assert!(json_out.exists());\n}\n\n#[test]\nfn queries_without_graph_build_from_path_and_text_formats() {\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    write_file(\u0026src.join(\"lib.rs\"), \"mod a; mod b; pub use a::foo;\\n\");\n    write_file(\u0026src.join(\"a.rs\"), \"pub fn foo() {}\\n\");\n    write_file(\u0026src.join(\"b.rs\"), \"pub fn bar() { crate::a::foo(); }\\n\");\n\n    // connected-files text output via table (no --graph)\n    let mut cf = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    cf.arg(\"query\").arg(\"connected-files\")\n        .arg(\"--path\").arg(\u0026root)\n        .arg(\"--file\").arg(src.join(\"a.rs\"))\n        .arg(\"--format\").arg(\"text\");\n    cf.assert().success().stdout(predicate::str::contains(\"#\").and(predicate::str::contains(\"Path\")));\n\n    // function-usage callees branch (no --graph)\n    let mut fu = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    fu.arg(\"query\").arg(\"function-usage\")\n        .arg(\"--path\").arg(\u0026root)\n        .arg(\"--function\").arg(\"bar\")\n        .arg(\"--direction\").arg(\"callees\")\n        .arg(\"--format\").arg(\"text\");\n    fu.assert().success();\n\n    // hubs with metric in and text output\n    let mut hubs = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    hubs.arg(\"query\").arg(\"hubs\")\n        .arg(\"--path\").arg(\u0026root)\n        .arg(\"--metric\").arg(\"in\")\n        .arg(\"--top\").arg(\"5\")\n        .arg(\"--format\").arg(\"text\");\n    hubs.assert().success().stdout(predicate::str::contains(\"In\").and(predicate::str::contains(\"Out\")));\n\n    // module-centrality with metric out and text output\n    let mut mc = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    mc.arg(\"query\").arg(\"module-centrality\")\n        .arg(\"--path\").arg(\u0026root)\n        .arg(\"--metric\").arg(\"out\")\n        .arg(\"--top\").arg(\"5\")\n        .arg(\"--format\").arg(\"text\");\n    mc.assert().success().stdout(predicate::str::contains(\"Module\").and(predicate::str::contains(\"Total\")));\n\n    // path query no path branch should print \u003cno path\u003e\n    let mut pathq = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    pathq.arg(\"query\").arg(\"path\")\n        .arg(\"--path\").arg(\u0026root)\n        .arg(\"--from\").arg(src.join(\"a.rs\"))\n        .arg(\"--to\").arg(src.join(\"b.rs\"))\n        .arg(\"--format\").arg(\"text\");\n    pathq.assert().success().stdout(predicate::str::contains(\"\u003cno path\u003e\"));\n}\n\n#[test]\nfn cycles_text_output_branch() {\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    // small project likely without cycles; text output still goes through branch\n    write_file(\u0026src.join(\"lib.rs\"), \"mod a; mod b;\\n\");\n    write_file(\u0026src.join(\"a.rs\"), \"pub fn fa() {}\\n\");\n    write_file(\u0026src.join(\"b.rs\"), \"pub fn fb() { }\\n\");\n\n    let mut cy = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    cy.arg(\"query\").arg(\"cycles\")\n        .arg(\"--path\").arg(\u0026root)\n        .arg(\"--format\").arg(\"text\");\n    cy.assert().success();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","cli_outputs.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::fs;\nuse std::io::Write;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse tempfile::tempdir;\n\n#[test]\nfn cli_build_produces_dot_and_json_and_hubs_query_works() {\n    // Arrange: temp project with two files and a simple call relationship\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    write_file(\u0026src.join(\"lib.rs\"), r#\"\n        pub mod a;\n        pub fn top() {}\n    \"#);\n    write_file(\u0026src.join(\"a.rs\"), r#\"\n        use crate::top;\n        pub fn child() { top(); }\n    \"#);\n\n    // Act: run build with dot and json outputs\n    let mut cmd = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    cmd.arg(\"build\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--json\").arg(root.join(\"graph.json\"))\n        .arg(\"--dot\").arg(root.join(\"graph.dot\"));\n    cmd.assert().success();\n\n    // Assert: outputs exist and are non-empty\n    let json_path = root.join(\"graph.json\");\n    let dot_path = root.join(\"graph.dot\");\n    assert!(json_path.exists());\n    assert!(dot_path.exists());\n    assert!(fs::metadata(\u0026json_path).unwrap().len() \u003e 0);\n    assert!(fs::metadata(\u0026dot_path).unwrap().len() \u003e 0);\n\n    // Act: run hubs query on saved graph\n    let mut q = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    q.arg(\"query\").arg(\"hubs\")\n        .arg(\"--graph\").arg(\u0026json_path)\n        .arg(\"--metric\").arg(\"total\")\n        .arg(\"--top\").arg(\"5\")\n        .arg(\"--format\").arg(\"json\");\n    q.assert().success().stdout(predicate::str::contains(\"[\"));\n}\n\nfn write_file(path: \u0026PathBuf, content: \u0026str) {\n    let mut f = fs::File::create(path).unwrap();\n    f.write_all(content.as_bytes()).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","cli_smoke.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::fs;\nuse std::io::Write;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse tempfile::tempdir;\n\n// Bottom-up: simple CLI smoke test for build and a query\n#[test]\nfn cli_build_and_connected_files_smoke() {\n    // Arrange: temp project with two files and a simple import\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    // Create lib.rs and a.rs\n    write_file(\u0026src.join(\"lib.rs\"), r#\"\n        pub mod a;\n        pub fn top() {}\n    \"#);\n    write_file(\u0026src.join(\"a.rs\"), r#\"\n        use crate::top;\n        pub fn child() { top(); }\n    \"#);\n\n    // Act: run build command\n    let mut cmd = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    cmd.arg(\"build\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--json\").arg(root.join(\"graph.json\"));\n    cmd.assert().success();\n\n    // Assert: graph file exists and contains the module\n    let json_path = root.join(\"graph.json\");\n    assert!(json_path.exists());\n    let content = fs::read_to_string(\u0026json_path).unwrap();\n    assert!(content.contains(\"lib.rs\"));\n\n    // Act: run query connected-files\n    let mut cmd2 = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    cmd2.arg(\"query\").arg(\"connected-files\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--file\").arg(src.join(\"a.rs\"))\n        .arg(\"--format\").arg(\"json\");\n    cmd2.assert().success().stdout(predicate::str::contains(\"lib.rs\"));\n}\n\nfn write_file(path: \u0026PathBuf, content: \u0026str) {\n    let mut f = fs::File::create(path).unwrap();\n    f.write_all(content.as_bytes()).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","cli_svg_and_queries.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::fs;\nuse std::io::Write;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse tempfile::tempdir;\n\n#[test]\nfn cli_build_svg_when_graphviz_available() {\n    // Only run if Graphviz dot is available\n    let dot_available = Command::new(\"dot\").arg(\"-V\").output().is_ok();\n    if !dot_available {\n        eprintln!(\"Skipping SVG test: graphviz 'dot' not found\");\n        return;\n    }\n\n#[test]\nfn cli_query_module_centrality_trait_impls_and_cycles() {\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    // Create two modules and a trait impl to exercise the queries\n    write_file(\u0026src.join(\"lib.rs\"), r#\"\n        mod m1; mod m2;\n        pub use m1::X;\n        pub trait T { fn f(\u0026self) {} }\n    \"#);\n    write_file(\u0026src.join(\"m1.rs\"), r#\"\n        use crate::T;\n        pub struct X;\n        impl T for X { fn f(\u0026self) {} }\n    \"#);\n    write_file(\u0026src.join(\"m2.rs\"), r#\"\n        use crate::m1::X;\n        pub fn use_x() { let _ = X; }\n    \"#);\n\n    // Build graph JSON\n    let mut build = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    build.arg(\"build\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--json\").arg(root.join(\"graph.json\"));\n    build.assert().success();\n    let graph_path = root.join(\"graph.json\");\n\n    // module-centrality: expect some output rows\n    let mut mc = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    mc.arg(\"query\").arg(\"module-centrality\")\n        .arg(\"--graph\").arg(\u0026graph_path)\n        .arg(\"--metric\").arg(\"total\")\n        .arg(\"--top\").arg(\"5\")\n        .arg(\"--format\").arg(\"json\");\n    mc.assert().success().stdout(predicate::str::contains(\"[\"));\n\n    // trait-impls: expect at least one row for trait T\n    let mut ti = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    ti.arg(\"query\").arg(\"trait-impls\")\n        .arg(\"--graph\").arg(\u0026graph_path)\n        .arg(\"--trait\").arg(\"T\")\n        .arg(\"--format\").arg(\"json\");\n    ti.assert().success().stdout(predicate::str::contains(\"X\"));\n\n    // cycles: command should succeed; output may be empty which is acceptable\n    let mut cy = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    cy.arg(\"query\").arg(\"cycles\")\n        .arg(\"--graph\").arg(\u0026graph_path)\n        .arg(\"--format\").arg(\"json\");\n    cy.assert().success().stdout(predicate::str::contains(\"[\"));\n}\n\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    write_file(\u0026src.join(\"lib.rs\"), r#\"\n        pub fn top() {}\n    \"#);\n\n    let mut cmd = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    cmd.arg(\"build\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--svg\").arg(root.join(\"graph.svg\"));\n    cmd.assert().success();\n\n    let svg_path = root.join(\"graph.svg\");\n    assert!(svg_path.exists());\n    assert!(fs::metadata(\u0026svg_path).unwrap().len() \u003e 0);\n}\n\n#[test]\nfn cli_query_path_and_function_usage() {\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    write_file(\u0026src.join(\"lib.rs\"), r#\"\n        mod a; mod b;\n        pub use a::foo;\n    \"#);\n    write_file(\u0026src.join(\"a.rs\"), r#\"\n        pub fn foo() {}\n    \"#);\n    write_file(\u0026src.join(\"b.rs\"), r#\"\n        pub fn bar() { crate::a::foo(); }\n    \"#);\n\n    // Build graph JSON to speed queries\n    let mut build = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    build.arg(\"build\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--json\").arg(root.join(\"graph.json\"));\n    build.assert().success();\n    let graph_path = root.join(\"graph.json\");\n\n    // path query: expect a path from b.rs to a.rs\n    let mut pathq = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    pathq.arg(\"query\").arg(\"path\")\n        .arg(\"--graph\").arg(\u0026graph_path)\n        .arg(\"--from\").arg(src.join(\"b.rs\"))\n        .arg(\"--to\").arg(src.join(\"a.rs\"))\n        .arg(\"--format\").arg(\"json\");\n    pathq.assert().success().stdout(predicate::str::contains(\"a.rs\"));\n\n    // function-usage: callers of foo should include b.rs\n    let mut funcq = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    funcq.arg(\"query\").arg(\"function-usage\")\n        .arg(\"--graph\").arg(\u0026graph_path)\n        .arg(\"--function\").arg(\"foo\")\n        .arg(\"--direction\").arg(\"callers\")\n        .arg(\"--format\").arg(\"json\");\n    funcq.assert().success().stdout(predicate::str::contains(\"b.rs\"));\n}\n\nfn write_file(path: \u0026PathBuf, content: \u0026str) {\n    let mut f = fs::File::create(path).unwrap();\n    f.write_all(content.as_bytes()).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","config_loading.rs"],"content":"use knowledge_rs::utils::config::{self};\nuse std::fs;\nuse std::path::Path;\n\nfn write(path: \u0026Path, content: \u0026str) {\n    if let Some(parent) = path.parent() { let _ = fs::create_dir_all(parent); }\n    fs::write(path, content).unwrap();\n}\n\n#[test]\nfn parses_full_config_file() {\n    let tmp = tempfile::tempdir().unwrap();\n    let cfg_path = tmp.path().join(\"knowledge-rs.toml\");\n    let data = r#\"\n[dot]\nclusters = true\nlegend = false\ntheme = \"dark\"\nrankdir = \"TB\"\nsplines = \"ortho\"\nrounded = true\n\n[svg]\ninteractive = true\n\n[query]\ndefault_format = \"json\"\n\"#;\n    write(\u0026cfg_path, data);\n\n    let cfg = config::load_config_at(\u0026cfg_path).expect(\"config parsed\");\n    assert_eq!(cfg.dot.as_ref().and_then(|d| d.clusters), Some(true));\n    assert_eq!(cfg.dot.as_ref().and_then(|d| d.legend), Some(false));\n    assert_eq!(cfg.dot.as_ref().and_then(|d| d.theme.as_ref()).map(|s| s.as_str()), Some(\"dark\"));\n    assert_eq!(cfg.dot.as_ref().and_then(|d| d.rankdir.as_ref()).map(|s| s.as_str()), Some(\"TB\"));\n    assert_eq!(cfg.dot.as_ref().and_then(|d| d.splines.as_ref()).map(|s| s.as_str()), Some(\"ortho\"));\n    assert_eq!(cfg.dot.as_ref().and_then(|d| d.rounded), Some(true));\n\n    assert_eq!(cfg.svg.as_ref().and_then(|s| s.interactive), Some(true));\n    assert_eq!(cfg.query.as_ref().and_then(|q| q.default_format.as_ref()).map(|s| s.as_str()), Some(\"json\"));\n}\n\n#[test]\nfn load_config_near_looks_for_default_name() {\n    let tmp = tempfile::tempdir().unwrap();\n    // create default location\n    let default_path = tmp.path().join(\"knowledge-rs.toml\");\n    write(\u0026default_path, \"[query]\\ndefault_format = 'text'\\n\");\n\n    let cfg = config::load_config_near(tmp.path()).expect(\"found default config\");\n    assert_eq!(cfg.query.and_then(|q| q.default_format), Some(\"text\".to_string()));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","ignore_patterns.rs"],"content":"use std::fs;\nuse std::path::PathBuf;\n\nuse knowledge_rs::graph::KnowledgeGraph;\n\nfn make_temp_project(entries: Vec\u003c(\u0026str, \u0026str)\u003e) -\u003e PathBuf {\n    let base = std::env::temp_dir()\n        .join(format!(\n            \"knowledge_rs_ignore_{}_{}\",\n            std::process::id(),\n            std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_nanos()\n        ));\n    fs::create_dir_all(base.join(\"src\")).unwrap();\n    for (rel, body) in entries {\n        let p = base.join(rel);\n        if let Some(par) = p.parent() { fs::create_dir_all(par).unwrap(); }\n\n#[test]\nfn multiple_ignore_files_with_negations() {\n    // Root ignores *.rs but subdir re-includes a specific file via negation\n    let root = make_temp_project(vec![\n        (\"src/.gitignore\", \"*.rs\\n!lib.rs\\n\"),\n        (\"src/a/.ignore\", \"*.rs\\n!keep.rs\\n\"),\n        (\"src/lib.rs\", \"mod a; pub fn root() {}\"),\n        (\"src/a/keep.rs\", \"pub fn k() {}\"),\n        (\"src/a/gone.rs\", \"pub fn g() {}\"),\n    ]);\n\n    let graph = KnowledgeGraph::build_from_directory(\u0026root.join(\"src\")).expect(\"build graph\");\n    // lib.rs is re-included by root-level negation\n    assert!(graph.files.keys().any(|p| p.ends_with(\"lib.rs\")));\n    // keep.rs is re-included by subdir negation\n    assert!(graph.files.keys().any(|p| p.ends_with(\"a/keep.rs\")));\n    // gone.rs remains ignored\n    assert!(!graph.files.keys().any(|p| p.ends_with(\"a/gone.rs\")));\n}\n        fs::write(p, body).unwrap();\n    }\n    base\n}\n\n#[test]\nfn ignores_files_listed_in_gitignore() {\n    let root = make_temp_project(vec![\n        (\"src/.ignore\", \"ignored.rs\\n\"),\n        (\"src/lib.rs\", \"mod kept; mod ignored; pub fn root() { kept::k(); }\"),\n        (\"src/kept.rs\", \"pub fn k() {}\"),\n        (\"src/ignored.rs\", \"pub fn x() {}\"),\n    ]);\n\n    // Build graph from src; the ignored file should not be parsed or present\n    let graph = KnowledgeGraph::build_from_directory(\u0026root.join(\"src\")).expect(\"build graph\");\n\n    // Ensure kept.rs exists\n    assert!(graph.files.keys().any(|p| p.ends_with(\"kept.rs\")));\n    // Ensure ignored.rs is not present due to .gitignore\n    assert!(!graph.files.keys().any(|p| p.ends_with(\"ignored.rs\")));\n}\n\n#[test]\nfn nested_ignore_file_in_subdir() {\n    let root = make_temp_project(vec![\n        (\"src/.ignore\", \"\"),\n        (\"src/a/.ignore\", \"skip.rs\\n\"),\n        (\"src/a/keep.rs\", \"pub fn k() {}\"),\n        (\"src/a/skip.rs\", \"pub fn s() {}\"),\n        (\"src/lib.rs\", \"pub fn root() {}\"),\n    ]);\n\n    let graph = KnowledgeGraph::build_from_directory(\u0026root.join(\"src\")).expect(\"build graph\");\n    assert!(graph.files.keys().any(|p| p.ends_with(\"a/keep.rs\")));\n    assert!(!graph.files.keys().any(|p| p.ends_with(\"a/skip.rs\")));\n}\n\n#[test]\nfn gitignore_negation_pattern() {\n    let root = make_temp_project(vec![\n        (\"src/.gitignore\", \"*.rs\\n!keep.rs\\n\"),\n        (\"src/keep.rs\", \"pub fn k() {}\"),\n        (\"src/gone.rs\", \"pub fn g() {}\"),\n        (\"src/lib.rs\", \"pub fn root() {}\"),\n    ]);\n\n    let graph = KnowledgeGraph::build_from_directory(\u0026root.join(\"src\")).expect(\"build graph\");\n    assert!(graph.files.keys().any(|p| p.ends_with(\"keep.rs\")));\n    assert!(!graph.files.keys().any(|p| p.ends_with(\"gone.rs\")));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","integration_queries.rs"],"content":"use std::fs;\nuse std::path::PathBuf;\n\nuse knowledge_rs::graph::KnowledgeGraph;\nuse knowledge_rs::query::{ConnectedFilesQuery, Query, CycleDetectionQuery};\n\nfn make_temp_project(contents: Vec\u003c(\u0026str, \u0026str)\u003e) -\u003e PathBuf {\n    let base = std::env::temp_dir()\n        .join(format!(\"knowledge_rs_it_{}_{}\", std::process::id(), std::time::SystemTime::now().elapsed().unwrap().as_nanos()));\n    fs::create_dir_all(base.join(\"src\")).unwrap();\n    for (path, body) in contents {\n        let p = base.join(path);\n        if let Some(parent) = p.parent() { fs::create_dir_all(parent).unwrap(); }\n        fs::write(p, body).unwrap();\n    }\n    base\n}\n\n#[test]\nfn integration_connected_files() {\n    let root = make_temp_project(vec![\n        (\"src/lib.rs\", r#\"\n            mod a;\n            mod b;\n            use crate::a::foo;\n            pub fn root() { foo(); }\n        \"#),\n        (\"src/a.rs\", r#\"\n            pub fn foo() {}\n        \"#),\n        (\"src/b.rs\", r#\"\n            pub fn bar() { crate::a::foo(); }\n        \"#),\n    ]);\n\n    let graph = KnowledgeGraph::build_from_directory(\u0026root.join(\"src\")).expect(\"build graph\");\n\n    // Connected files for a.rs should include lib.rs due to import use from lib\n    let connected = ConnectedFilesQuery::new(root.join(\"src/a.rs\")).run(\u0026graph);\n    assert!(connected.contains(\u0026root.join(\"src/lib.rs\")));\n}\n\n#[test]\n#[ignore = \"Call-graph extraction is simplistic and may not detect cycles from source yet; enable when improved.\"]\nfn integration_cycle_detection_simple() {\n    let root = make_temp_project(vec![\n        (\"src/lib.rs\", r#\"\n            mod a;\n            mod b;\n        \"#),\n        (\"src/a.rs\", r#\"\n            pub fn foo() { crate::b::bar(); }\n        \"#),\n        (\"src/b.rs\", r#\"\n            pub fn bar() { crate::a::foo(); }\n        \"#),\n    ]);\n\n    let graph = KnowledgeGraph::build_from_directory(\u0026root.join(\"src\")).expect(\"build graph\");\n    let cycles = CycleDetectionQuery::new().run(\u0026graph);\n    assert!(cycles.iter().any(|cyc| cyc.len() \u003e= 2));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","parser_props.rs"],"content":"use proptest::prelude::*;\nuse knowledge_rs::parser::RustParser;\n\n// Bottom-up property-based tests: parser robustness on arbitrary inputs\nproptest! {\n    // The parser should never panic on arbitrary UTF-8 input\n    #[test]\n    fn parser_never_panics_on_arbitrary_input(s in \".*\") {\n        let parser = RustParser::new();\n        let _ = parser.parse_file(\u0026s, std::path::Path::new(\"/prop.rs\"));\n        // No assertion needed: the test passes if it doesn't panic\n    }\n\n    // Basic invariant: item/import counts are finite and consistent\n    #[test]\n    fn parser_produces_reasonable_counts(s in \".*\") {\n        let parser = RustParser::new();\n        if let Ok(node) = parser.parse_file(\u0026s, std::path::Path::new(\"/prop.rs\")) {\n            // Items and imports should be non-negative (Vec len) and not overflow typical bounds\n            prop_assert!(node.items.len() \u003c= s.len() + 1);\n            prop_assert!(node.imports.len() \u003c= s.len() + 1);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","query_additional.rs"],"content":"use knowledge_rs::graph::{KnowledgeGraph, FileNode, Item, ItemType, Relationship, RelationshipType, Visibility, Location, ItemId};\nuse knowledge_rs::query::{ShortestPathQuery, HubsQuery, ModuleCentralityQuery, CentralityMetric, Query};\nuse std::path::PathBuf;\n\nfn make_fn(path: \u0026PathBuf, name: \u0026str) -\u003e Item {\n    Item {\n        id: ItemId(format!(\"fn:{}:{}\", name, path.display())),\n        item_type: ItemType::Function { is_async: false, is_const: false },\n        name: name.to_string(),\n        visibility: Visibility::Public,\n        location: Location { file: path.clone(), line_start: 1, line_end: 1 },\n        attributes: vec![],\n    }\n}\n\nfn graph_chain() -\u003e KnowledgeGraph {\n    // a -\u003e b, b -\u003e c, c isolated to module m2 with d\n    let mut g = KnowledgeGraph::default();\n    let a = PathBuf::from(\"src/a.rs\");\n    let b = PathBuf::from(\"src/b.rs\");\n    let c = PathBuf::from(\"src/m1/c.rs\");\n    let d = PathBuf::from(\"src/m2/d.rs\");\n\n    let ia = make_fn(\u0026a, \"fa\");\n    let ib = make_fn(\u0026b, \"fb\");\n    let ic = make_fn(\u0026c, \"fc\");\n    let id = make_fn(\u0026d, \"fd\");\n\n    g.files.insert(a.clone(), FileNode { path: a.clone(), items: vec![ia.clone()], imports: vec![], metrics: Default::default() });\n    g.files.insert(b.clone(), FileNode { path: b.clone(), items: vec![ib.clone()], imports: vec![], metrics: Default::default() });\n    g.files.insert(c.clone(), FileNode { path: c.clone(), items: vec![ic.clone()], imports: vec![], metrics: Default::default() });\n    g.files.insert(d.clone(), FileNode { path: d.clone(), items: vec![id.clone()], imports: vec![], metrics: Default::default() });\n\n    g.relationships.push(Relationship { from_item: ia.id.clone(), to_item: ib.id.clone(), relationship_type: RelationshipType::Calls { call_type: \"test\".into() }, strength: 1.0, context: String::new() });\n    g.relationships.push(Relationship { from_item: ib.id.clone(), to_item: ic.id.clone(), relationship_type: RelationshipType::Calls { call_type: \"test\".into() }, strength: 1.0, context: String::new() });\n    // d has no edges, different module directory\n\n    g\n}\n\n#[test]\nfn shortest_path_found_and_absent() {\n    let g = graph_chain();\n    // Path a -\u003e b -\u003e c exists\n    let p = ShortestPathQuery::new(\"src/a.rs\", \"src/m1/c.rs\").run(\u0026g);\n    assert_eq!(p.first().unwrap().display().to_string(), \"src/a.rs\");\n    assert_eq!(p.last().unwrap().display().to_string(), \"src/m1/c.rs\");\n\n    // No path from c to a\n    let none = ShortestPathQuery::new(\"src/m1/c.rs\", \"src/a.rs\").run(\u0026g);\n    assert!(none.is_empty());\n}\n\n#[test]\nfn hubs_query_metrics_and_sorting() {\n    let g = graph_chain();\n    // Total metric: b should have total 2 (1 in, 1 out) and be near top\n    let total = HubsQuery::new(CentralityMetric::Total, 10).run(\u0026g);\n    assert!(total.iter().any(|(p,i,o)| p.ends_with(\"src/b.rs\") \u0026\u0026 *i == 1 \u0026\u0026 *o == 1));\n\n    // In metric: c has indegree 1, d has 0\n    let ins = HubsQuery::new(CentralityMetric::In, 10).run(\u0026g);\n    assert!(ins.iter().any(|(p,i,_)| p.ends_with(\"src/m1/c.rs\") \u0026\u0026 *i == 1));\n\n    // Out metric: a has outdegree 1\n    let outs = HubsQuery::new(CentralityMetric::Out, 10).run(\u0026g);\n    assert!(outs.iter().any(|(p,_,o)| p.ends_with(\"src/a.rs\") \u0026\u0026 *o == 1));\n}\n\n#[test]\nfn module_centrality_inter_module_edges() {\n    let g = graph_chain();\n    // Expect edges counted between parent directories of files\n    let rows = ModuleCentralityQuery::new(CentralityMetric::Total, 10).run(\u0026g);\n    // At least two modules should appear\n    assert!(rows.len() \u003e= 2);\n    // Ensure modules include src and src/m1, src/m2\n    let mods: Vec\u003cString\u003e = rows.iter().map(|(p,_,_)| p.display().to_string()).collect();\n    assert!(mods.iter().any(|m| m == \"src\" || m.ends_with(\"/src\")));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","utils_tests.rs"],"content":"use knowledge_rs::utils::{file_walker, table};\nuse std::fs;\nuse std::io::Write;\nuse tempfile::tempdir;\n\n#[test]\nfn table_renderer_produces_expected_grid() {\n    let headers = [\"A\", \"B\"];\n    let rows = vec![vec![\"x\".into(), \"y\".into()], vec![\"long\".into(), \"z\".into()]];\n    let out = table::render(\u0026headers, \u0026rows);\n    assert!(out.starts_with(\"+\"));\n    assert!(out.contains(\"| A\"));\n    assert!(out.contains(\"long\"));\n}\n\n#[test]\nfn file_walker_respects_ignore_and_no_ignore() {\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    // Create files\n    write(\u0026src.join(\"lib.rs\"), \"pub mod hidden;\\n\");\n    write(\u0026src.join(\"hidden.rs\"), \"pub fn f() {}\\n\");\n\n    // Add .gitignore to hide hidden.rs\n    write(\u0026root.join(\".gitignore\"), \"src/hidden.rs\\n\");\n\n    // Default: should not see hidden.rs\n    let files = file_walker::rust_files(root.to_str().unwrap());\n    let listed: Vec\u003c_\u003e = files.iter().map(|s| s.ends_with(\"lib.rs\") || s.ends_with(\"hidden.rs\")).collect();\n    assert!(listed.iter().any(|\u0026b| b));\n    assert!(!files.iter().any(|s| s.ends_with(\"hidden.rs\")));\n\n    // no_ignore=true: should include hidden.rs\n    let files_all = file_walker::rust_files_with_options(root.to_str().unwrap(), true);\n    assert!(files_all.iter().any(|s| s.ends_with(\"hidden.rs\")));\n}\n\nfn write(path: \u0026std::path::Path, s: \u0026str) {\n    let mut f = fs::File::create(path).unwrap();\n    f.write_all(s.as_bytes()).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","visualization_dot.rs"],"content":"use assert_cmd::prelude::*;\nuse std::fs;\nuse std::io::Write;\nuse std::process::Command;\nuse tempfile::tempdir;\n\n#[test]\nfn dot_generator_clusters_and_flat_themes() {\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    // Minimal multi-file crate to trigger clusters/children\n    write_file(\u0026src.join(\"lib.rs\"), r#\"\n        mod m;\n        pub struct S; pub enum E { A }\n        pub trait T { fn f(\u0026self); }\n    \"#);\n    write_file(\u0026src.join(\"m.rs\"), r#\"\n        pub fn foo() {}\n    \"#);\n\n    // Build a graph JSON then load it via CLI to ensure consistency\n    let graph_json = root.join(\"graph.json\");\n    let mut build = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    build.arg(\"build\").arg(\"--path\").arg(\u0026root).arg(\"--json\").arg(\u0026graph_json);\n    build.assert().success();\n\n    // Use the CLI to emit DOT with clusters + legend + dark theme\n    let dot_dark = root.join(\"dark.dot\");\n    let mut build_dot_dark = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    build_dot_dark\n        .arg(\"build\").arg(\"--path\").arg(\u0026root)\n        .arg(\"--dot\").arg(\u0026dot_dark)\n        .arg(\"--dot-clusters\").arg(\"on\")\n        .arg(\"--dot-legend\").arg(\"on\")\n        .arg(\"--dot-theme\").arg(\"dark\")\n        .arg(\"--dot-rankdir\").arg(\"TB\")\n        .arg(\"--dot-splines\").arg(\"polyline\")\n        .arg(\"--dot-rounded\").arg(\"off\");\n    build_dot_dark.assert().success();\n\n    let dot_dark_str = fs::read_to_string(\u0026dot_dark).unwrap();\n    assert!(dot_dark_str.contains(\"digraph KnowledgeRS\"));\n    assert!(dot_dark_str.contains(\"rankdir=TB\"));\n    assert!(dot_dark_str.contains(\"splines=polyline\"));\n    assert!(dot_dark_str.contains(\"subgraph \\\"cluster_\")); // clusters enabled\n    assert!(dot_dark_str.contains(\"label=\\\"Legend\\\"\"));  // legend enabled\n\n    // Emit DOT without clusters, light theme defaults\n    let dot_light = root.join(\"light.dot\");\n    let mut build_dot_light = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    build_dot_light\n        .arg(\"build\").arg(\"--path\").arg(\u0026root)\n        .arg(\"--dot\").arg(\u0026dot_light)\n        .arg(\"--dot-clusters\").arg(\"off\")\n        .arg(\"--dot-legend\").arg(\"off\");\n    build_dot_light.assert().success();\n\n    let dot_light_str = fs::read_to_string(\u0026dot_light).unwrap();\n    assert!(dot_light_str.contains(\"rankdir=LR\")); // default\n    assert!(!dot_light_str.contains(\"cluster_\")); // no clusters\n}\n\nfn write_file(path: \u0026std::path::Path, content: \u0026str) {\n    let mut f = fs::File::create(path).unwrap();\n    f.write_all(content.as_bytes()).unwrap();\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","dio","knowledge-rs","benches","build_graph.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};\nuse knowledge_rs::graph::KnowledgeGraph;\nuse knowledge_rs::utils::cache::CacheMode;\nuse std::path::Path;\n\nfn bench_build_graph(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"build_graph\");\n\n    // Benchmark different cache modes\n    for mode in [CacheMode::Rebuild, CacheMode::Use, CacheMode::Ignore] {\n        let label = match mode {\n            CacheMode::Rebuild =\u003e \"rebuild\",\n            CacheMode::Use =\u003e \"use_cache\",\n            CacheMode::Ignore =\u003e \"ignore_cache\",\n        };\n        group.bench_function(BenchmarkId::new(\"build_from_directory_with_cache_opts\", label), |b| {\n            b.iter(|| {\n                let root = Path::new(\".\");\n                let graph = KnowledgeGraph::build_from_directory_with_cache_opts(black_box(root), mode, false)\n                    .expect(\"build graph\");\n                // prevent optimizer from discarding\n                black_box(graph.files.len())\n            })\n        });\n    }\n\n    group.finish();\n}\n\ncriterion_group!(name = benches; config = Criterion::default(); targets = bench_build_graph);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","benches","queries.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};\nuse knowledge_rs::graph::KnowledgeGraph;\nuse knowledge_rs::query::{CentralityMetric, ConnectedFilesQuery, HubsQuery, Query, ShortestPathQuery};\nuse knowledge_rs::utils::cache::CacheMode;\nuse std::path::Path;\n\nfn build_graph_once() -\u003e KnowledgeGraph {\n    let root = Path::new(\".\");\n    KnowledgeGraph::build_from_directory_with_cache_opts(root, CacheMode::Use, false)\n        .expect(\"build graph\")\n}\n\nfn bench_queries(c: \u0026mut Criterion) {\n    // Setup outside of iter\n    let graph = build_graph_once();\n\n    let mut group = c.benchmark_group(\"queries\");\n\n    // Heuristic pick: pick two files from the repo for path \u0026 connected benchmarks\n    let mut files: Vec\u003c_\u003e = graph.files.keys().cloned().collect();\n    files.sort();\n    let from = files.get(0).cloned();\n    let to = files.get(1).cloned();\n\n    // Connected files\n    if let Some(sample) = from.clone() {\n        group.bench_function(BenchmarkId::new(\"connected_files\", sample.file_name().and_then(|s| s.to_str()).unwrap_or(\"sample\")), |b| {\n            b.iter(|| {\n                let q = ConnectedFilesQuery { file: sample.clone() };\n                let res = q.run(black_box(\u0026graph));\n                black_box(res.len())\n            })\n        });\n    }\n\n    // Hubs (top 10 by total degree)\n    group.bench_function(BenchmarkId::new(\"hubs\", \"top10_total\"), |b| {\n        b.iter(|| {\n            let q = HubsQuery { metric: CentralityMetric::Total, top: 10 };\n            let res = q.run(black_box(\u0026graph));\n            black_box(res.len())\n        })\n    });\n\n    // Shortest path between two files (if at least two files)\n    if let (Some(a), Some(b)) = (from, to) {\n        group.bench_function(BenchmarkId::new(\"shortest_path\", \"a_to_b\"), |bch| {\n            bch.iter(|| {\n                let q = ShortestPathQuery { from: a.clone(), to: b.clone() };\n                let res = q.run(black_box(\u0026graph));\n                black_box(res.len())\n            })\n        });\n    }\n\n    group.finish();\n}\n\ncriterion_group!(name = benches; config = Criterion::default(); targets = bench_queries);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","examples","basic_build.rs"],"content":"use knowledge_rs::graph::KnowledgeGraph;\nuse knowledge_rs::utils::cache::CacheMode;\n\nfn main() {\n    let root = std::path::Path::new(\".\");\n    let no_ignore = false; // set true to include ignored files\n    let graph = KnowledgeGraph::build_from_directory_with_cache_opts(root, CacheMode::Use, no_ignore)\n        .expect(\"build graph\");\n    println!(\n        \"Built graph: files={}, relationships={}\",\n        graph.files.len(),\n        graph.relationships.len()\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","examples","generate_svg.rs"],"content":"use knowledge_rs::graph::KnowledgeGraph;\nuse knowledge_rs::utils::cache::CacheMode;\nuse knowledge_rs::visualization::{DotGenerator, DotOptions, EdgeStyle, RankDir, SvgGenerator, SvgOptions, DotTheme};\n\nfn main() {\n    let root = std::path::Path::new(\".\");\n    let graph = KnowledgeGraph::build_from_directory_with_cache_opts(root, CacheMode::Use, false)\n        .expect(\"build graph\");\n\n    // Generate DOT with options\n    let dot_opts = DotOptions { clusters: true, legend: true, theme: DotTheme::Light, rankdir: RankDir::LR, splines: EdgeStyle::Curved, rounded: true };\n    let dot = DotGenerator::new().generate_dot_with_options(\u0026graph, dot_opts).expect(\"dot\");\n    std::fs::write(\"graph.dot\", dot).expect(\"write dot\");\n\n    // Generate SVG (requires `dot` from Graphviz on PATH)\n    let svg_opts = SvgOptions { dot: dot_opts, interactive: true };\n    match SvgGenerator::new().generate_svg_with_options(\u0026graph, svg_opts) {\n        Ok(svg) =\u003e {\n            std::fs::write(\"graph.svg\", svg).expect(\"write svg\");\n            println!(\"Wrote graph.svg\");\n        }\n        Err(e) =\u003e {\n            eprintln!(\"SVG generation failed: {}\\nHint: ensure Graphviz 'dot' is installed and on PATH.\", e);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","examples","generate_synthetic.rs"],"content":"use std::env;\nuse std::fs;\nuse std::io::Write;\nuse std::path::PathBuf;\n\n// Generate a synthetic Rust project with many small files to benchmark build speed.\n// Usage:\n//   cargo run --example generate_synthetic -- \u003croot\u003e \u003cfiles\u003e\n// Example:\n//   cargo run --example generate_synthetic -- /tmp/kr_synth 10000\nfn main() {\n    let args: Vec\u003cString\u003e = env::args().collect();\n    if args.len() != 3 {\n        eprintln!(\"Usage: {} \u003croot\u003e \u003cfiles\u003e\", args.get(0).map(String::as_str).unwrap_or(\"generate_synthetic\"));\n        std::process::exit(2);\n    }\n    let root = PathBuf::from(\u0026args[1]);\n    let n: usize = args[2].parse().expect(\"files must be a number\");\n\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).expect(\"create src\");\n\n    // Write lib.rs that mods chunks to keep module tree shallow-ish\n    let mut lib = String::new();\n    lib.push_str(\"// synthetic project generated for benchmarking\\n\");\n    lib.push_str(\"pub fn root() {}\\n\");\n\n    for i in 0..n {\n        lib.push_str(\u0026format!(\"pub mod f{};\\n\", i));\n    }\n    fs::write(src.join(\"lib.rs\"), lib).expect(\"write lib.rs\");\n\n    // Each file defines one function and calls previous one to create a chain of calls\n    for i in 0..n {\n        let path = src.join(format!(\"f{}.rs\", i));\n        let mut file = fs::File::create(\u0026path).expect(\"create file\");\n        if i == 0 {\n            writeln!(file, \"pub fn f0() {{}} \").unwrap();\n        } else {\n            writeln!(file, \"use crate::f{}::f{};\", i - 1, i - 1).unwrap();\n            writeln!(file, \"pub fn f{}() {{ f{}(); }}\", i, i - 1).unwrap();\n        }\n    }\n\n    println!(\"Generated synthetic project at {} with {} files\", root.display(), n);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","examples","query_connected.rs"],"content":"use knowledge_rs::graph::{ItemId, KnowledgeGraph};\nuse knowledge_rs::utils::cache::CacheMode;\n\nfn main() {\n    let root = std::path::Path::new(\".\");\n    let graph = KnowledgeGraph::build_from_directory_with_cache_opts(root, CacheMode::Use, false)\n        .expect(\"build graph\");\n\n    // Pick a file like src/lib.rs if it exists; otherwise, print the first file.\n    let target = std::path::Path::new(\"src/lib.rs\");\n    let file = if graph.files.contains_key(target) {\n        target\n    } else if let Some(first) = graph.files.keys().next() {\n        first.as_path()\n    } else {\n        eprintln!(\"No files in graph\");\n        return;\n    };\n\n    // Build an index from ItemId -\u003e owning file\n    let mut owner: std::collections::HashMap\u003cItemId, std::path::PathBuf\u003e = std::collections::HashMap::new();\n    for (path, node) in \u0026graph.files {\n        for it in \u0026node.items {\n            owner.insert(it.id.clone(), path.clone());\n        }\n    }\n\n    // List files that have direct relationships with any item in the target file\n    let mut related = std::collections::BTreeSet::new();\n    for rel in \u0026graph.relationships {\n        let from_file = owner.get(\u0026rel.from_item);\n        let to_file = owner.get(\u0026rel.to_item);\n        match (from_file, to_file) {\n            (Some(f), Some(t)) =\u003e {\n                if f == file \u0026\u0026 t != file {\n                    related.insert(t.clone());\n                } else if t == file \u0026\u0026 f != file {\n                    related.insert(f.clone());\n                }\n            }\n            _ =\u003e {}\n        }\n    }\n\n    println!(\"Connected files to {}:\", file.display());\n    for f in related {\n        println!(\"- {}\", f.display());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","src","cli","mod.rs"],"content":"use clap::{Parser, Subcommand};\n\n#[derive(Debug, Parser)]\n#[command(\n    name = \"knowledge-rs\",\n    version,\n    about = \"Rust Knowledge Graph System\",\n    long_about = \"Parse Rust projects into a knowledge graph and run queries. File discovery respects .gitignore and .ignore with parent traversal. Global git excludes are disabled for determinism. Use --no-ignore to bypass ignore rules.\"\n)] \npub struct Cli {\n    #[command(subcommand)]\n    pub command: Commands,\n}\n\n#[derive(Debug, Subcommand)]\npub enum Commands {\n    /// Build the knowledge graph from a source directory\n    Build {\n        /// Path to the Rust project root (directory containing src/)\n        #[arg(short, long, default_value = \".\")] \n        path: String,\n        /// Path to a TOML configuration file\n        #[arg(long)]\n        config: Option\u003cString\u003e,\n        /// Bypass ignore rules (.gitignore/.ignore) when discovering files\n        #[arg(long, default_value_t = false, help = \"Include files even if matched by .gitignore/.ignore. Global git excludes are always disabled for determinism.\")]\n        no_ignore: bool,\n        /// Ignore cache when building (do not reuse cached files)\n        #[arg(long, default_value_t = false)]\n        no_cache: bool,\n        /// Rebuild cache from scratch (clears previous cache)\n        #[arg(long, default_value_t = false)]\n        rebuild: bool,\n        /// Output JSON file path\n        #[arg(long)]\n        json: Option\u003cString\u003e,\n        /// Output DOT file path\n        #[arg(long)]\n        dot: Option\u003cString\u003e,\n        /// Output SVG file path\n        #[arg(long)]\n        svg: Option\u003cString\u003e,\n        /// DOT: enable/disable hierarchical clusters (default: on)\n        #[arg(long, value_parser = [\"on\", \"off\"], default_value = \"on\")]\n        dot_clusters: String,\n        /// DOT: include legend (default: on)\n        #[arg(long, value_parser = [\"on\", \"off\"], default_value = \"on\")]\n        dot_legend: String,\n        /// DOT: theme (light or dark)\n        #[arg(long, value_parser = [\"light\", \"dark\"], default_value = \"light\")]\n        dot_theme: String,\n        /// DOT: rank direction (LR or TB)\n        #[arg(long, value_parser = [\"LR\", \"TB\"], default_value = \"LR\")]\n        dot_rankdir: String,\n        /// DOT: edge splines style (curved, ortho, polyline)\n        #[arg(long, value_parser = [\"curved\", \"ortho\", \"polyline\"], default_value = \"curved\")]\n        dot_splines: String,\n        /// DOT: rounded node corners (on/off)\n        #[arg(long, value_parser = [\"on\", \"off\"], default_value = \"on\")]\n        dot_rounded: String,\n        /// SVG: add interactive enhancements (on/off)\n        #[arg(long, value_parser = [\"on\", \"off\"], default_value = \"on\")]\n        svg_interactive: String,\n        /// Save built graph to JSON file path\n        #[arg(long)]\n        save: Option\u003cString\u003e,\n    },\n    /// Run queries over the knowledge graph\n    Query {\n        #[command(subcommand)]\n        query: QueryCommands,\n    },\n    \n}\n\n#[derive(Debug, Subcommand)]\npub enum QueryCommands {\n    /// List files connected to the given file via relationships\n    ConnectedFiles {\n        /// Path to project root (directory containing src/)\n        #[arg(short, long, default_value = \".\")] \n        path: String,\n        /// Path to a TOML configuration file\n        #[arg(long)]\n        config: Option\u003cString\u003e,\n        /// Bypass ignore rules (.gitignore/.ignore) when discovering files\n        #[arg(long, default_value_t = false, help = \"Include files even if matched by .gitignore/.ignore. Global git excludes are always disabled for determinism.\")]\n        no_ignore: bool,\n        /// The file to analyze (absolute or relative)\n        #[arg(long)]\n        file: String,\n        /// Optional path to a prebuilt graph JSON (skips rebuild)\n        #[arg(long)]\n        graph: Option\u003cString\u003e,\n        /// Output format: text or json\n        #[arg(long, value_parser = [\"text\", \"json\"], default_value = \"text\")]\n        format: String,\n    },\n    /// List files that call or are called by a given function name\n    FunctionUsage {\n        /// Path to project root (directory containing src/)\n        #[arg(short, long, default_value = \".\")] \n        path: String,\n        /// Path to a TOML configuration file\n        #[arg(long)]\n        config: Option\u003cString\u003e,\n        /// Bypass ignore rules (.gitignore/.ignore) when discovering files\n        #[arg(long, default_value_t = false)]\n        no_ignore: bool,\n        /// Function name to analyze\n        #[arg(long)]\n        function: String,\n        /// Direction: callers or callees\n        #[arg(long, value_parser = [\"callers\", \"callees\"], default_value = \"callers\")]\n        direction: String,\n        /// Optional path to a prebuilt graph JSON (skips rebuild)\n        #[arg(long)]\n        graph: Option\u003cString\u003e,\n        /// Output format: text or json\n        #[arg(long, value_parser = [\"text\", \"json\"], default_value = \"text\")]\n        format: String,\n    },\n    /// Detect cycles between files\n    Cycles {\n        /// Path to project root (directory containing src/)\n        #[arg(short, long, default_value = \".\")] \n        path: String,\n        /// Path to a TOML configuration file\n        #[arg(long)]\n        config: Option\u003cString\u003e,\n        /// Bypass ignore rules (.gitignore/.ignore) when discovering files\n        #[arg(long, default_value_t = false)]\n        no_ignore: bool,\n        /// Optional path to a prebuilt graph JSON (skips rebuild)\n        #[arg(long)]\n        graph: Option\u003cString\u003e,\n        /// Output format: text or json\n        #[arg(long, value_parser = [\"text\", \"json\"], default_value = \"text\")]\n        format: String,\n    },\n    /// Compute shortest path between two files\n    Path {\n        /// Path to project root (directory containing src/)\n        #[arg(short, long, default_value = \".\")] \n        path: String,\n        /// Path to a TOML configuration file\n        #[arg(long)]\n        config: Option\u003cString\u003e,\n        /// Bypass ignore rules (.gitignore/.ignore) when discovering files\n        #[arg(long, default_value_t = false)]\n        no_ignore: bool,\n        /// Source file path\n        #[arg(long)]\n        from: String,\n        /// Destination file path\n        #[arg(long)]\n        to: String,\n        /// Optional path to a prebuilt graph JSON (skips rebuild)\n        #[arg(long)]\n        graph: Option\u003cString\u003e,\n        /// Output format: text or json\n        #[arg(long, value_parser = [\"text\", \"json\"], default_value = \"text\")]\n        format: String,\n    },\n    /// List top-N hub files by degree centrality\n    Hubs {\n        /// Path to project root (directory containing src/)\n        #[arg(short, long, default_value = \".\")] \n        path: String,\n        /// Path to a TOML configuration file\n        #[arg(long)]\n        config: Option\u003cString\u003e,\n        /// Bypass ignore rules (.gitignore/.ignore) when discovering files\n        #[arg(long, default_value_t = false)]\n        no_ignore: bool,\n        /// Optional path to a prebuilt graph JSON (skips rebuild)\n        #[arg(long)]\n        graph: Option\u003cString\u003e,\n        /// Metric: in, out, total\n        #[arg(long, value_parser = [\"in\", \"out\", \"total\"], default_value = \"total\")]\n        metric: String,\n        /// Top N results\n        #[arg(long, default_value_t = 10)]\n        top: usize,\n        /// Output format: text or json\n        #[arg(long, value_parser = [\"text\", \"json\"], default_value = \"text\")]\n        format: String,\n    },\n    /// List top-N modules (directories) by degree centrality\n    ModuleCentrality {\n        /// Path to project root (directory containing src/)\n        #[arg(short, long, default_value = \".\")] \n        path: String,\n        /// Path to a TOML configuration file\n        #[arg(long)]\n        config: Option\u003cString\u003e,\n        /// Bypass ignore rules (.gitignore/.ignore) when discovering files\n        #[arg(long, default_value_t = false)]\n        no_ignore: bool,\n        /// Optional path to a prebuilt graph JSON (skips rebuild)\n        #[arg(long)]\n        graph: Option\u003cString\u003e,\n        /// Metric: in, out, total\n        #[arg(long, value_parser = [\"in\", \"out\", \"total\"], default_value = \"total\")]\n        metric: String,\n        /// Top N results\n        #[arg(long, default_value_t = 10)]\n        top: usize,\n        /// Output format: text or json\n        #[arg(long, value_parser = [\"text\", \"json\"], default_value = \"text\")]\n        format: String,\n    },\n    /// List types implementing a trait\n    TraitImpls {\n        /// Path to project root (directory containing src/)\n        #[arg(short, long, default_value = \".\")] \n        path: String,\n        /// Path to a TOML configuration file\n        #[arg(long)]\n        config: Option\u003cString\u003e,\n        /// Bypass ignore rules (.gitignore/.ignore) when discovering files\n        #[arg(long, default_value_t = false)]\n        no_ignore: bool,\n        /// Trait name (e.g., Display)\n        #[arg(long, value_name = \"NAME\")]\n        r#trait: String,\n        /// Optional path to a prebuilt graph JSON (skips rebuild)\n        #[arg(long)]\n        graph: Option\u003cString\u003e,\n        /// Output format: text or json\n        #[arg(long, value_parser = [\"text\", \"json\"], default_value = \"text\")]\n        format: String,\n    },\n}\n\npub fn parse() -\u003e Cli {\n    Cli::parse()\n}\n","traces":[{"line":236,"address":[8085968],"length":1,"stats":{"Line":0}},{"line":237,"address":[8085976],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","dio","knowledge-rs","src","errors.rs"],"content":"use std::path::PathBuf;\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum ParseError {\n    #[error(\"Regex match failed: {0}\")]\n    Regex(String),\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n    #[error(\"Invalid UTF-8 in file {file}\")]\n    InvalidUtf8 { file: PathBuf },\n}\n\n#[derive(Debug, Error)]\npub enum KnowledgeGraphError {\n    #[error(\"Parse error in file {file}: {source}\")]\n    ParseError { file: PathBuf, source: ParseError },\n\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"Invalid query: {0}\")]\n    Query(String),\n\n    #[error(\"Visualization error: {0}\")]\n    Visualization(String),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","src","graph","mod.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::PathBuf;\nuse regex::Regex;\nuse rayon::prelude::*;\nuse crate::utils::cache;\n\npub mod resolver;\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq, Hash)]\npub struct ItemId(pub String);\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Location {\n    pub file: PathBuf,\n    pub line_start: usize,\n    pub line_end: usize,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ItemType {\n    Module { is_inline: bool },\n    Function { is_async: bool, is_const: bool },\n    Struct { is_tuple: bool },\n    Enum { variant_count: usize },\n    Trait { is_object_safe: bool },\n    Impl { trait_name: Option\u003cString\u003e, type_name: String },\n    Const,\n    Static { is_mut: bool },\n    Type,\n    Macro,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum Visibility {\n    Public,\n    Private,\n    PubCrate,\n    PubSuper,\n    PubIn(String),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Item {\n    pub id: ItemId,\n    pub item_type: ItemType,\n    pub name: String,\n    pub visibility: Visibility,\n    pub location: Location,\n    pub attributes: Vec\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Import {\n    pub path: String,\n    pub alias: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum RelationshipType {\n    Uses { import_type: String },\n    Implements { trait_name: String },\n    Contains { containment_type: String },\n    Extends { extension_type: String },\n    Calls { call_type: String },\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Relationship {\n    pub from_item: ItemId,\n    pub to_item: ItemId,\n    pub relationship_type: RelationshipType,\n    pub strength: f64,\n    pub context: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct FileMetrics {\n    pub item_count: usize,\n    pub import_count: usize,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct FileNode {\n    pub path: PathBuf,\n    pub items: Vec\u003cItem\u003e,\n    pub imports: Vec\u003cImport\u003e,\n    pub metrics: FileMetrics,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct GraphMetadata {\n    pub generated_at: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct KnowledgeGraph {\n    pub files: HashMap\u003cPathBuf, FileNode\u003e,\n    pub relationships: Vec\u003cRelationship\u003e,\n    pub metadata: GraphMetadata,\n    // Module hierarchy tracking: parent and children maps keyed by file paths\n    pub module_parent: HashMap\u003cPathBuf, PathBuf\u003e,\n    pub module_children: HashMap\u003cPathBuf, Vec\u003cPathBuf\u003e\u003e,\n}\n\nimpl KnowledgeGraph {\n    /// Build a knowledge graph from a directory with explicit cache mode and ignore behavior.\n    ///\n    /// Arguments:\n    /// - `path`: Root directory to scan for Rust source files.\n    /// - `mode`: Cache usage policy (see `utils::cache::CacheMode`).\n    /// - `no_ignore`: When true, bypasses `.gitignore`/`.ignore` rules in file discovery.\n    ///\n    /// Returns a fully built `KnowledgeGraph`, loading from and/or updating the on-disk cache\n    /// according to `mode`. File discovery is performed via `utils::file_walker::rust_files_with_options`.\n    pub fn build_from_directory_with_cache_opts(\n        path: \u0026std::path::Path,\n        mode: cache::CacheMode,\n        no_ignore: bool,\n    ) -\u003e Result\u003cSelf, crate::errors::KnowledgeGraphError\u003e {\n        use crate::parser::RustParser;\n        use crate::utils::file_walker;\n        use std::fs;\n        use crate::errors::KnowledgeGraphError;\n\n        let files = file_walker::rust_files_with_options(path.to_string_lossy().as_ref(), no_ignore);\n\n        // Load or ignore cache based on mode\n        let root_dir = path.to_path_buf();\n        let mut cache_state = match mode {\n            cache::CacheMode::Use =\u003e cache::load_cache(\u0026root_dir).unwrap_or_default(),\n            cache::CacheMode::Ignore | cache::CacheMode::Rebuild =\u003e Default::default(),\n        };\n\n        // Collect file metadata for change detection\n        let infos: Vec\u003c(String, cache::CacheEntryMeta)\u003e = files\n            .iter()\n            .map(|f| {\n                let p = std::path::Path::new(f);\n                let meta = fs::metadata(p).ok();\n                let len = meta.as_ref().and_then(|m| m.len().try_into().ok()).unwrap_or(0u64);\n                let mtime = meta\n                    .and_then(|m| m.modified().ok())\n                    .and_then(|t| t.duration_since(std::time::UNIX_EPOCH).ok())\n                    .map(|d| d.as_secs())\n                    .unwrap_or(0u64);\n                (f.clone(), cache::CacheEntryMeta { mtime, len })\n            })\n            .collect();\n\n        // Prune cache entries for files that no longer exist in the walk\n        if matches!(mode, cache::CacheMode::Use) {\n            use std::collections::HashSet;\n            let present: HashSet\u003cPathBuf\u003e = files.iter().map(|f| std::path::Path::new(f).to_path_buf()).collect();\n            cache_state.entries.retain(|k, _| present.contains(k));\n        }\n\n    \n\n    \n\n        // Reuse from cache when metadata matches (only in Use mode)\n        let mut reused: Vec\u003c(PathBuf, FileNode, Vec\u003cRelationship\u003e)\u003e = Vec::new();\n        let mut to_parse: Vec\u003c(String, cache::CacheEntryMeta)\u003e = Vec::new();\n        for (file, meta) in \u0026infos {\n            let key = std::path::Path::new(file).to_path_buf();\n            if matches!(mode, cache::CacheMode::Use) {\n                if let Some(entry) = cache_state.entries.get(\u0026key) {\n                    if entry.meta == *meta {\n                        let node = entry.node.clone();\n                        // Rebuild contains edges for cached node\n                        let file_id = ItemId(format!(\"file:{}\", node.path.display()));\n                        let mut edges = Vec::new();\n                        for it in node.items.iter().skip(1) {\n                            edges.push(Relationship {\n                                from_item: file_id.clone(),\n                                to_item: it.id.clone(),\n                                relationship_type: RelationshipType::Contains { containment_type: \"file_contains\".to_string() },\n                                strength: 1.0,\n                                context: \"auto\".to_string(),\n                            });\n                        }\n                        reused.push((node.path.clone(), node, edges));\n                        continue;\n                    }\n                }\n            }\n            to_parse.push((file.clone(), meta.clone()));\n        }\n\n        // Parse files in parallel. Each task returns (path, node, contains_edges)\n        let parsed: Result\u003cVec\u003c(PathBuf, FileNode, Vec\u003cRelationship\u003e, cache::CacheEntry)\u003e, KnowledgeGraphError\u003e = to_parse\n            .into_par_iter()\n            .map(|file| {\n                let (file, meta) = file;\n                let content = fs::read_to_string(\u0026file).map_err(KnowledgeGraphError::Io)?;\n                let p = std::path::Path::new(\u0026file).to_path_buf();\n                let mut node = RustParser::new()\n                    .parse_file(\u0026content, \u0026p)\n                    .map_err(|source| KnowledgeGraphError::ParseError { file: p.clone(), source })?;\n\n                // Create a synthetic file-level module item\n                let file_id = ItemId(format!(\"file:{}\", node.path.display()));\n                let file_item = Item {\n                    id: file_id.clone(),\n                    item_type: ItemType::Module { is_inline: false },\n                    name: node\n                        .path\n                        .file_stem()\n                        .and_then(|s| s.to_str())\n                        .unwrap_or(\"(file)\")\n                        .to_string(),\n                    visibility: Visibility::PubCrate,\n                    location: Location { file: node.path.clone(), line_start: 1, line_end: 1 },\n                    attributes: vec![],\n                };\n\n                // Prepend the file item\n                let mut items_with_file = Vec::with_capacity(node.items.len() + 1);\n                items_with_file.push(file_item);\n                items_with_file.extend(node.items.into_iter());\n                node.metrics.item_count = items_with_file.len();\n                node.items = items_with_file;\n\n                // Build Contains relationships from file item to each other item\n                let mut contains_edges: Vec\u003cRelationship\u003e = Vec::new();\n                for it in node.items.iter().skip(1) {\n                    contains_edges.push(Relationship {\n                        from_item: file_id.clone(),\n                        to_item: it.id.clone(),\n                        relationship_type: RelationshipType::Contains { containment_type: \"file_contains\".to_string() },\n                        strength: 1.0,\n                        context: \"auto\".to_string(),\n                    });\n                }\n\n                let cache_entry = cache::CacheEntry { meta, node: node.clone() };\n                Ok::\u003c_, KnowledgeGraphError\u003e((node.path.clone(), node, contains_edges, cache_entry))\n            })\n            .collect();\n\n        let mut graph = KnowledgeGraph::default();\n        // Insert reused nodes\n        for (path, node, edges) in reused {\n            graph.files.insert(path, node);\n            graph.relationships.extend(edges);\n        }\n        // Insert newly parsed nodes and update cache\n        for (path, node, edges, cache_entry) in parsed? {\n            graph.files.insert(path, node);\n            graph.relationships.extend(edges);\n            cache_state.entries.insert(cache_entry.node.path.clone(), cache_entry);\n        }\n\n        // Set generation timestamp (seconds since epoch) without extra deps\n        graph.metadata.generated_at = match std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n        {\n            Ok(d) =\u003e format!(\"{}\", d.as_secs()),\n            Err(_) =\u003e \"0\".to_string(),\n        };\n        // Analyze relationships beyond file containment\n        graph.analyze_relationships();\n\n        // Save cache (best-effort). Even in Ignore/Rebuild, we save freshly parsed state.\n        cache::save_cache(\u0026root_dir, \u0026cache_state);\n        Ok(graph)\n    }\n\n    // Module hierarchy helpers\n    pub fn get_module_parent(\u0026self, file: \u0026PathBuf) -\u003e Option\u003c\u0026PathBuf\u003e {\n        self.module_parent.get(file)\n    }\n\n    pub fn get_module_children(\u0026self, file: \u0026PathBuf) -\u003e \u0026[PathBuf] {\n        match self.module_children.get(file) {\n            Some(v) =\u003e v.as_slice(),\n            None =\u003e \u0026[],\n        }\n    }\n    /// Backward-compatible builder: reads env var `KNOWLEDGE_RS_NO_IGNORE` for ignore bypass.\n    pub fn build_from_directory_with_cache(path: \u0026std::path::Path, mode: cache::CacheMode) -\u003e Result\u003cSelf, crate::errors::KnowledgeGraphError\u003e {\n        let no_ignore = std::env::var(\"KNOWLEDGE_RS_NO_IGNORE\")\n            .map(|v| v == \"1\" || v.eq_ignore_ascii_case(\"true\"))\n            .unwrap_or(false);\n        Self::build_from_directory_with_cache_opts(path, mode, no_ignore)\n    }\n\n    /// Backward-compatible builder: `CacheMode::Use` and env-derived ignore bypass.\n    pub fn build_from_directory(path: \u0026std::path::Path) -\u003e Result\u003cSelf, crate::errors::KnowledgeGraphError\u003e {\n        let no_ignore = std::env::var(\"KNOWLEDGE_RS_NO_IGNORE\")\n            .map(|v| v == \"1\" || v.eq_ignore_ascii_case(\"true\"))\n            .unwrap_or(false);\n        Self::build_from_directory_with_cache_opts(path, cache::CacheMode::Use, no_ignore)\n    }\n\n    /// Convenience builder: explicit ignore bypass with default `CacheMode::Use`.\n    pub fn build_from_directory_opts(path: \u0026std::path::Path, no_ignore: bool) -\u003e Result\u003cSelf, crate::errors::KnowledgeGraphError\u003e {\n        Self::build_from_directory_with_cache_opts(path, cache::CacheMode::Use, no_ignore)\n    }\n\n    pub fn save_json(\u0026self, path: \u0026std::path::Path) -\u003e Result\u003c(), crate::errors::KnowledgeGraphError\u003e {\n        let data = serde_json::to_string_pretty(self).map_err(|e| {\n            crate::errors::KnowledgeGraphError::Io(std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))\n        })?;\n        std::fs::write(path, data)?;\n        Ok(())\n    }\n\n    pub fn load_json(path: \u0026std::path::Path) -\u003e Result\u003cSelf, crate::errors::KnowledgeGraphError\u003e {\n        let data = std::fs::read_to_string(path)?;\n        let graph: KnowledgeGraph = serde_json::from_str(\u0026data).map_err(|e| {\n            crate::errors::KnowledgeGraphError::Io(std::io::Error::new(std::io::ErrorKind::Other, e.to_string()))\n        })?;\n        Ok(graph)\n    }\n\n    \n}\n\nimpl KnowledgeGraph {\n    fn analyze_relationships(\u0026mut self) {\n        self.analyze_module_hierarchy();\n        self.analyze_import_uses();\n        self.analyze_calls_heuristic();\n    }\n\n    // Establish module hierarchy using filesystem layout.\n    // For every file-level synthetic module item, link its parent module (if present) with a Contains edge.\n    fn analyze_module_hierarchy(\u0026mut self) {\n        // Reset hierarchy maps to avoid stale entries on re-analysis\n        self.module_parent.clear();\n        self.module_children.clear();\n        // Helper to get file-level item id (first item) for a given path\n        let mut file_level_id: HashMap\u003cPathBuf, ItemId\u003e = HashMap::new();\n        for (p, f) in \u0026self.files {\n            if let Some(it) = f.items.first() {\n                file_level_id.insert(p.clone(), it.id.clone());\n            }\n        }\n\n        // For each file, determine its parent module file and add Contains edge\n        for (path, _file) in self.files.clone().into_iter() {\n            // Skip if we can't find this file's synthetic id\n            let Some(child_id) = file_level_id.get(\u0026path) else { continue; };\n\n            // Determine parent file candidate based on path structure\n            let parent_dir = match path.parent() { Some(d) =\u003e d.to_path_buf(), None =\u003e continue };\n            let file_name = path.file_name().and_then(|s| s.to_str()).unwrap_or(\"\");\n\n            // If current file is mod.rs or lib.rs, parent is parent's parent dir's mod.rs or lib.rs\n            let parent_candidates: Vec\u003cPathBuf\u003e = if file_name == \"mod.rs\" || file_name == \"lib.rs\" {\n                let grand = parent_dir.parent().map(|p| p.to_path_buf());\n                match grand {\n                    Some(g) =\u003e vec![g.join(\"mod.rs\"), g.join(\"lib.rs\")],\n                    None =\u003e Vec::new(),\n                }\n            } else {\n                // foo.rs -\u003e parent is current dir's mod.rs or lib.rs\n                vec![parent_dir.join(\"mod.rs\"), parent_dir.join(\"lib.rs\")]\n            };\n\n            // Find first existing parent in graph\n            let mut parent_id_opt: Option\u003cItemId\u003e = None;\n            for cand in parent_candidates {\n                if let Some(pid) = file_level_id.get(\u0026cand) {\n                    parent_id_opt = Some(pid.clone());\n                    break;\n                }\n            }\n\n            if let Some(parent_id) = parent_id_opt {\n                if parent_id != *child_id {\n                    // Relationship edge\n                    self.relationships.push(Relationship {\n                        from_item: parent_id.clone(),\n                        to_item: child_id.clone(),\n                        relationship_type: RelationshipType::Contains { containment_type: \"module_contains\".to_string() },\n                        strength: 1.0,\n                        context: \"fs\".to_string(),\n                    });\n                    // Hierarchy maps\n                    // Resolve actual parent path from id -\u003e file map\n                    let parent_path = self\n                        .files\n                        .keys()\n                        .find(|p| if let Some(fid) = file_level_id.get(*p) { fid == \u0026parent_id } else { false })\n                        .cloned();\n                    if let Some(pp) = parent_path {\n                        self.module_parent.insert(path.clone(), pp.clone());\n                        self.module_children.entry(pp).or_default().push(path.clone());\n                    }\n                }\n            }\n        }\n    }\n\n    fn analyze_import_uses(\u0026mut self) {\n        // Build edges using a Resolver in a separate scope to avoid \u0026mut self conflicts\n        let mut new_edges: Vec\u003cRelationship\u003e = Vec::new();\n        {\n            let res = resolver::Resolver::new(\u0026self);\n            for (path, file) in \u0026self.files {\n                if file.items.is_empty() { continue; }\n                let file_id = file.items[0].id.clone();\n                for imp in \u0026file.imports {\n                    let targets = res.resolve_import(path, \u0026imp.path);\n                    if targets.is_empty() { continue; }\n                    for to in targets {\n                        if to == file_id { continue; }\n                        // Prefer module when the resolved target is the synthetic file-level module; else item\n                        let import_type = if res.is_file_level_module(\u0026to) { \"import-module\" } else { \"import-item\" };\n                        new_edges.push(Relationship {\n                            from_item: file_id.clone(),\n                            to_item: to,\n                            relationship_type: RelationshipType::Uses { import_type: import_type.to_string() },\n                            strength: if import_type == \"import-item\" { 1.0 } else { 0.8 },\n                            context: imp.path.clone(),\n                        });\n                    }\n                }\n            }\n        }\n        self.relationships.extend(new_edges);\n    }\n\n    fn analyze_calls_heuristic(\u0026mut self) {\n        // Regex for fully qualified paths like a::b::foo(...)\n        let path_call_re = Regex::new(r\"\\b([A-Za-z_][A-Za-z0-9_]*(?:::[A-Za-z_][A-Za-z0-9_]*)+)\\s*\\(\").unwrap();\n        // Regex for simple names: foo(...)\n        let simple_call_re = Regex::new(r\"\\b([A-Za-z_][A-Za-z0-9_]*)\\s*\\(\").unwrap();\n\n        // Build index of function name -\u003e list of ItemIds that are functions\n        let mut func_index: HashMap\u003cString, Vec\u003cItemId\u003e\u003e = HashMap::new();\n        for file in self.files.values() {\n            for item in \u0026file.items {\n                if let ItemType::Function { .. } = item.item_type {\n                    func_index.entry(item.name.clone()).or_default().push(item.id.clone());\n                }\n            }\n        }\n\n        // Dedup set of created edges (from,to)\n        let mut seen: std::collections::HashSet\u003c(String, String)\u003e = std::collections::HashSet::new();\n        let mut new_edges: Vec\u003cRelationship\u003e = Vec::new();\n\n        for (path, file) in \u0026self.files {\n            if file.items.is_empty() { continue; }\n            let file_id = file.items[0].id.clone();\n            if let Ok(content) = std::fs::read_to_string(path) {\n                // 1) Resolve fully qualified calls via Resolver (more precise)\n                let res = resolver::Resolver::new(\u0026self);\n                for cap in path_call_re.captures_iter(\u0026content) {\n                    let full = cap.get(1).map(|m| m.as_str()).unwrap_or(\"\");\n                    let mut targets = res.resolve_import(path, full);\n                    // Fallback: if resolution fails, try last segment as function name\n                    if targets.is_empty() {\n                        if let Some(last) = full.rsplit(\"::\").next() {\n                            if let Some(funcs) = func_index.get(last) {\n                                targets = funcs.clone();\n                            }\n                        }\n                    }\n                    for to in targets {\n                        let key = (file_id.0.clone(), to.0.clone());\n                        if seen.insert(key) {\n                            new_edges.push(Relationship {\n                                from_item: file_id.clone(),\n                                to_item: to.clone(),\n                                relationship_type: RelationshipType::Calls { call_type: \"path\".to_string() },\n                                strength: 0.7,\n                                context: full.to_string(),\n                            });\n                        }\n                    }\n                }\n\n                // 2) Fallback simple name calls, filtering out definitions/macros and keywords\n                for cap in simple_call_re.captures_iter(\u0026content) {\n                    let m = match cap.get(0) { Some(m) =\u003e m, None =\u003e continue };\n                    let name = cap.get(1).map(|m| m.as_str()).unwrap_or(\"\");\n                    // Skip if preceding few chars suggest a definition like `fn name(` or macro `name!(`\n                    let start = m.start();\n                    let prefix = \u0026content[start.saturating_sub(8)..start];\n                    if prefix.contains(\"fn \") || prefix.contains(\"struct \") || prefix.contains(\"enum \") || prefix.contains(\"trait \") {\n                        continue;\n                    }\n                    // Skip macro invocations `name!(` by checking previous non-space char\n                    if start \u003e 0 {\n                        let prev = content[..start].chars().rev().find(|c| !c.is_whitespace());\n                        if let Some('!') = prev { continue; }\n                    }\n                    if let Some(targets) = func_index.get(name) {\n                        for to in targets {\n                            let key = (file_id.0.clone(), to.0.clone());\n                            if seen.insert(key) {\n                                new_edges.push(Relationship {\n                                    from_item: file_id.clone(),\n                                    to_item: to.clone(),\n                                    relationship_type: RelationshipType::Calls { call_type: \"heuristic\".to_string() },\n                                    strength: 0.5,\n                                    context: name.to_string(),\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        self.relationships.extend(new_edges);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::tempdir;\n\n    #[test]\n    fn module_hierarchy_basic() {\n        // Files: src/lib.rs (parent of src/a/mod.rs); src/a/mod.rs (parent of src/a/foo.rs)\n        let mut g = KnowledgeGraph::default();\n        let lib = PathBuf::from(\"src/lib.rs\");\n        let a_mod = PathBuf::from(\"src/a/mod.rs\");\n        let a_foo = PathBuf::from(\"src/a/foo.rs\");\n\n        let make_file_item = |p: \u0026PathBuf| Item {\n            id: ItemId(format!(\"file:{}\", p.display())),\n            item_type: ItemType::Module { is_inline: false },\n            name: p.file_stem().and_then(|s| s.to_str()).unwrap_or(\"(file)\").to_string(),\n            visibility: Visibility::PubCrate,\n            location: Location { file: p.clone(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        };\n\n        g.files.insert(lib.clone(), FileNode { path: lib.clone(), items: vec![make_file_item(\u0026lib)], imports: vec![], metrics: Default::default() });\n        g.files.insert(a_mod.clone(), FileNode { path: a_mod.clone(), items: vec![make_file_item(\u0026a_mod)], imports: vec![], metrics: Default::default() });\n        g.files.insert(a_foo.clone(), FileNode { path: a_foo.clone(), items: vec![make_file_item(\u0026a_foo)], imports: vec![], metrics: Default::default() });\n\n        // Build hierarchy\n        g.analyze_module_hierarchy();\n\n        // Parent checks\n        assert_eq!(g.get_module_parent(\u0026a_mod), Some(\u0026lib));\n        assert_eq!(g.get_module_parent(\u0026a_foo), Some(\u0026a_mod));\n        assert!(g.get_module_parent(\u0026lib).is_none());\n\n        // Children checks\n        let lib_children = g.get_module_children(\u0026lib);\n        assert!(lib_children.contains(\u0026a_mod));\n        let a_mod_children = g.get_module_children(\u0026a_mod);\n        assert!(a_mod_children.contains(\u0026a_foo));\n    }\n\n    #[test]\n    fn import_uses_edges_item_vs_module() {\n        // Build a small graph with two files in a temp dir\n        let td = tempdir().unwrap();\n        let f1 = td.path().join(\"a.rs\");\n        let f2 = td.path().join(\"modx.rs\");\n        let f3 = td.path().join(\"b.rs\");\n        // Write contents (not strictly needed for imports)\n        fs::write(\u0026f1, \"// a.rs\\n\").unwrap();\n        fs::write(\u0026f2, \"// modx.rs\\n\").unwrap();\n        fs::write(\u0026f3, \"// b.rs\\n\").unwrap();\n\n        // File nodes\n        let mk_file_item = |p: \u0026PathBuf| Item {\n            id: ItemId(format!(\"file:{}\", p.display())),\n            item_type: ItemType::Module { is_inline: false },\n            name: p.file_stem().and_then(|s| s.to_str()).unwrap_or(\"(file)\").to_string(),\n            visibility: Visibility::PubCrate,\n            location: Location { file: p.clone(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        };\n        let mk_fn_item = |p: \u0026PathBuf, name: \u0026str| Item {\n            id: ItemId(format!(\"fn:{}:1\", name)),\n            item_type: ItemType::Function { is_async: false, is_const: false },\n            name: name.to_string(),\n            visibility: Visibility::Public,\n            location: Location { file: p.clone(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        };\n\n        let mut g = KnowledgeGraph::default();\n\n        // a.rs imports: item \"foo\" and module \"modx\"\n        let mut a_node = FileNode::default();\n        a_node.path = f1.clone();\n        a_node.items = vec![mk_file_item(\u0026f1)];\n        a_node.imports = vec![\n            Import { path: \"foo\".into(), alias: None },\n            Import { path: \"modx\".into(), alias: None },\n        ];\n\n        // modx.rs is a module (no inner items needed)\n        let mut modx_node = FileNode::default();\n        modx_node.path = f2.clone();\n        modx_node.items = vec![mk_file_item(\u0026f2)];\n\n        // b.rs defines function foo\n        let mut b_node = FileNode::default();\n        b_node.path = f3.clone();\n        b_node.items = vec![mk_file_item(\u0026f3), mk_fn_item(\u0026f3, \"foo\")];\n\n        g.files.insert(f1.clone(), a_node);\n        g.files.insert(f2.clone(), modx_node);\n        g.files.insert(f3.clone(), b_node);\n\n        // Run import uses analysis\n        g.analyze_import_uses();\n\n        // Check relationships: from a.rs file-level id\n        let a_file_id = ItemId(format!(\"file:{}\", f1.display()));\n        // Expect one import-item edge to function foo and one import-module edge to modx\n        let mut saw_item = false;\n        let mut saw_module = false;\n        for r in \u0026g.relationships {\n            if r.from_item == a_file_id {\n                if let RelationshipType::Uses { import_type } = \u0026r.relationship_type {\n                    if import_type == \"import-item\" { saw_item = true; }\n                    if import_type == \"import-module\" { saw_module = true; }\n                }\n            }\n        }\n        assert!(saw_item, \"expected import-item edge\");\n        assert!(saw_module, \"expected import-module edge\");\n    }\n\n    #[test]\n    fn calls_heuristic_and_path_and_macro_exclusion() {\n        // temp dir structure with caller and callees; write contents so heuristic reads\n        let td = tempdir().unwrap();\n        let caller = td.path().join(\"caller.rs\");\n        let callee_foo = td.path().join(\"callee.rs\");\n        let dir_a = td.path().join(\"a\");\n        let dir_b = dir_a.join(\"b\");\n        fs::create_dir_all(\u0026dir_b).unwrap();\n        let baz = dir_b.join(\"baz.rs\");\n\n        // Contents: caller calls foo(), a::b::baz(), and macro!() which should be ignored\n        fs::write(\u0026caller, \"fn main(){ foo(); a::b::baz(); my_macro!(x); }\\n\").unwrap();\n        fs::write(\u0026callee_foo, \"pub fn foo(){}\\n\").unwrap();\n        fs::write(\u0026baz, \"pub fn baz(){}\\n\").unwrap();\n\n        // Helpers to build graph items\n        let mk_file_item = |p: \u0026PathBuf| Item {\n            id: ItemId(format!(\"file:{}\", p.display())),\n            item_type: ItemType::Module { is_inline: false },\n            name: p.file_stem().and_then(|s| s.to_str()).unwrap_or(\"(file)\").to_string(),\n            visibility: Visibility::PubCrate,\n            location: Location { file: p.clone(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        };\n        let mk_fn_item = |p: \u0026PathBuf, name: \u0026str| Item {\n            id: ItemId(format!(\"fn:{}:X\", name)),\n            item_type: ItemType::Function { is_async: false, is_const: false },\n            name: name.to_string(),\n            visibility: Visibility::Public,\n            location: Location { file: p.clone(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        };\n\n        let mut g = KnowledgeGraph::default();\n        // caller file\n        let mut caller_node = FileNode::default();\n        caller_node.path = caller.clone();\n        caller_node.items = vec![mk_file_item(\u0026caller)];\n        // callee foo\n        let mut callee_node = FileNode::default();\n        callee_node.path = callee_foo.clone();\n        callee_node.items = vec![mk_file_item(\u0026callee_foo), mk_fn_item(\u0026callee_foo, \"foo\")];\n        // baz\n        let mut baz_node = FileNode::default();\n        baz_node.path = baz.clone();\n        baz_node.items = vec![mk_file_item(\u0026baz), mk_fn_item(\u0026baz, \"baz\")];\n\n        g.files.insert(caller.clone(), caller_node);\n        g.files.insert(callee_foo.clone(), callee_node);\n        g.files.insert(baz.clone(), baz_node);\n\n        // Run call analysis\n        g.analyze_calls_heuristic();\n\n        let caller_file_id = ItemId(format!(\"file:{}\", caller.display()));\n        let mut saw_foo = false;\n        let mut saw_baz = false;\n        let mut saw_macro = false;\n        for r in \u0026g.relationships {\n            if r.from_item != caller_file_id { continue; }\n            if let RelationshipType::Calls { call_type } = \u0026r.relationship_type {\n                // Identify target by id suffix\n                if r.to_item.0.starts_with(\"fn:foo:\") {\n                    saw_foo = true;\n                    assert_eq!(call_type, \"heuristic\");\n                }\n                if r.to_item.0.starts_with(\"fn:baz:\") {\n                    saw_baz = true;\n                    // path or heuristic is acceptable; path is preferred route\n                }\n            }\n            if let RelationshipType::Uses { .. } = r.relationship_type { /* ignore */ }\n        }\n        assert!(saw_foo, \"expected call edge to foo()\");\n        assert!(saw_baz, \"expected call edge to a::b::baz()\");\n        assert!(!saw_macro, \"macro invocations must not create call edges\");\n    }\n}\n","traces":[{"line":115,"address":[5987568,5986448,5992981],"length":1,"stats":{"Line":6}},{"line":125,"address":[7046596],"length":1,"stats":{"Line":5}},{"line":128,"address":[6124615],"length":1,"stats":{"Line":5}},{"line":129,"address":[7046913],"length":1,"stats":{"Line":5}},{"line":130,"address":[6124763,6124662],"length":1,"stats":{"Line":11}},{"line":131,"address":[6124693,6124846],"length":1,"stats":{"Line":2}},{"line":135,"address":[7082475],"length":1,"stats":{"Line":5}},{"line":137,"address":[7047223],"length":1,"stats":{"Line":11}},{"line":138,"address":[7086206],"length":1,"stats":{"Line":5}},{"line":139,"address":[6024102],"length":1,"stats":{"Line":5}},{"line":140,"address":[7164160,7164169,7086264],"length":1,"stats":{"Line":16}},{"line":142,"address":[6026857,6058695,6058688],"length":1,"stats":{"Line":16}},{"line":143,"address":[6026873,6053776,6053789],"length":1,"stats":{"Line":16}},{"line":144,"address":[6026292,6057500,6057488],"length":1,"stats":{"Line":16}},{"line":145,"address":[7345872],"length":1,"stats":{"Line":6}},{"line":146,"address":[6026332],"length":1,"stats":{"Line":5}},{"line":151,"address":[7082684],"length":1,"stats":{"Line":5}},{"line":153,"address":[6064512,6064547],"length":1,"stats":{"Line":22}},{"line":154,"address":[6125251],"length":1,"stats":{"Line":7}},{"line":162,"address":[6125064],"length":1,"stats":{"Line":5}},{"line":163,"address":[5987574],"length":1,"stats":{"Line":6}},{"line":164,"address":[5988331,5988234],"length":1,"stats":{"Line":10}},{"line":165,"address":[7162194,7159305],"length":1,"stats":{"Line":11}},{"line":166,"address":[7086372],"length":1,"stats":{"Line":5}},{"line":167,"address":[7162343,7162245],"length":1,"stats":{"Line":11}},{"line":168,"address":[5991127],"length":1,"stats":{"Line":1}},{"line":169,"address":[7086608],"length":1,"stats":{"Line":1}},{"line":171,"address":[8940315,8940247],"length":1,"stats":{"Line":2}},{"line":172,"address":[7086901],"length":1,"stats":{"Line":1}},{"line":173,"address":[7162800,7162881],"length":1,"stats":{"Line":2}},{"line":174,"address":[7093391],"length":1,"stats":{"Line":1}},{"line":175,"address":[6129620],"length":1,"stats":{"Line":1}},{"line":176,"address":[5992877],"length":1,"stats":{"Line":1}},{"line":177,"address":[6130112,6130184],"length":1,"stats":{"Line":2}},{"line":179,"address":[6130228],"length":1,"stats":{"Line":1}},{"line":182,"address":[6129646],"length":1,"stats":{"Line":1}},{"line":187,"address":[7093628,7091845],"length":1,"stats":{"Line":11}},{"line":191,"address":[7088775],"length":1,"stats":{"Line":5}},{"line":193,"address":[7415189,7411184,7415903],"length":1,"stats":{"Line":8}},{"line":194,"address":[7403295],"length":1,"stats":{"Line":3}},{"line":195,"address":[8578653,8574062,8574133],"length":1,"stats":{"Line":6}},{"line":196,"address":[7144188,7144283],"length":1,"stats":{"Line":6}},{"line":197,"address":[7404247,7403822,7404111],"length":1,"stats":{"Line":6}},{"line":198,"address":[6085018,6084914],"length":1,"stats":{"Line":7}},{"line":199,"address":[7404484,7390364,7404183,7404076,7407889,7403913,7390336],"length":1,"stats":{"Line":6}},{"line":202,"address":[5992664],"length":1,"stats":{"Line":3}},{"line":203,"address":[5993409],"length":1,"stats":{"Line":4}},{"line":204,"address":[6085253],"length":1,"stats":{"Line":3}},{"line":205,"address":[7404872],"length":1,"stats":{"Line":3}},{"line":206,"address":[5993014],"length":1,"stats":{"Line":3}},{"line":208,"address":[7145469],"length":1,"stats":{"Line":4}},{"line":209,"address":[6116560,6086044,6116574],"length":1,"stats":{"Line":9}},{"line":210,"address":[7412971],"length":1,"stats":{"Line":4}},{"line":211,"address":[5993194],"length":1,"stats":{"Line":4}},{"line":212,"address":[5993223],"length":1,"stats":{"Line":4}},{"line":213,"address":[7145627,7145678],"length":1,"stats":{"Line":8}},{"line":214,"address":[6218246],"length":1,"stats":{"Line":4}},{"line":218,"address":[7405549,7405619],"length":1,"stats":{"Line":8}},{"line":219,"address":[6086719],"length":1,"stats":{"Line":4}},{"line":220,"address":[7146290],"length":1,"stats":{"Line":4}},{"line":221,"address":[8576583],"length":1,"stats":{"Line":4}},{"line":222,"address":[6086380],"length":1,"stats":{"Line":4}},{"line":225,"address":[6087052],"length":1,"stats":{"Line":4}},{"line":226,"address":[7406047,7406130],"length":1,"stats":{"Line":8}},{"line":227,"address":[7407529],"length":1,"stats":{"Line":4}},{"line":228,"address":[6219356],"length":1,"stats":{"Line":4}},{"line":229,"address":[6087719],"length":1,"stats":{"Line":4}},{"line":230,"address":[7415258,7415330],"length":1,"stats":{"Line":8}},{"line":232,"address":[5995478],"length":1,"stats":{"Line":4}},{"line":236,"address":[6086822],"length":1,"stats":{"Line":4}},{"line":237,"address":[7414461,7414520],"length":1,"stats":{"Line":8}},{"line":241,"address":[6125824],"length":1,"stats":{"Line":3}},{"line":243,"address":[5988096,5990841,5988204,5988339],"length":1,"stats":{"Line":10}},{"line":244,"address":[7083988,7086180],"length":1,"stats":{"Line":2}},{"line":245,"address":[7050807],"length":1,"stats":{"Line":1}},{"line":248,"address":[7089477,7091383,7089899],"length":1,"stats":{"Line":9}},{"line":249,"address":[6127981,6127140],"length":1,"stats":{"Line":6}},{"line":250,"address":[7091088],"length":1,"stats":{"Line":3}},{"line":251,"address":[6128090],"length":1,"stats":{"Line":3}},{"line":255,"address":[5989762,5989783,5989858,5989429,5989516],"length":1,"stats":{"Line":12}},{"line":256,"address":[7084925],"length":1,"stats":{"Line":3}},{"line":258,"address":[7160920],"length":1,"stats":{"Line":3}},{"line":259,"address":[7085221,7084970],"length":1,"stats":{"Line":0}},{"line":262,"address":[5990490],"length":1,"stats":{"Line":3}},{"line":265,"address":[7090777],"length":1,"stats":{"Line":3}},{"line":266,"address":[7085460],"length":1,"stats":{"Line":3}},{"line":270,"address":[7084224],"length":1,"stats":{"Line":1}},{"line":271,"address":[6121150],"length":1,"stats":{"Line":1}},{"line":274,"address":[5975856],"length":1,"stats":{"Line":1}},{"line":275,"address":[7142494,7142586],"length":1,"stats":{"Line":2}},{"line":276,"address":[5975916],"length":1,"stats":{"Line":1}},{"line":277,"address":[5976536],"length":1,"stats":{"Line":0}},{"line":281,"address":[7138784],"length":1,"stats":{"Line":3}},{"line":282,"address":[7100588],"length":1,"stats":{"Line":3}},{"line":283,"address":[7165040,7165049],"length":1,"stats":{"Line":3}},{"line":285,"address":[7100671],"length":1,"stats":{"Line":3}},{"line":289,"address":[8942784],"length":1,"stats":{"Line":2}},{"line":290,"address":[6131538],"length":1,"stats":{"Line":3}},{"line":291,"address":[7089225],"length":1,"stats":{"Line":2}},{"line":293,"address":[8942894],"length":1,"stats":{"Line":2}},{"line":297,"address":[7168608],"length":1,"stats":{"Line":0}},{"line":298,"address":[7040641],"length":1,"stats":{"Line":0}},{"line":301,"address":[5980554,5980016,5980525],"length":1,"stats":{"Line":0}},{"line":302,"address":[8625058,8625052,8624912],"length":1,"stats":{"Line":0}},{"line":303,"address":[7194792,7194739],"length":1,"stats":{"Line":0}},{"line":305,"address":[5981105,5980871,5980975],"length":1,"stats":{"Line":0}},{"line":306,"address":[7075925],"length":1,"stats":{"Line":0}},{"line":309,"address":[7077296,7077834,7077840],"length":1,"stats":{"Line":0}},{"line":310,"address":[5982481],"length":1,"stats":{"Line":0}},{"line":311,"address":[5982695,5982629,5982874],"length":1,"stats":{"Line":0}},{"line":312,"address":[6164984,6164931],"length":1,"stats":{"Line":0}},{"line":314,"address":[8931395],"length":1,"stats":{"Line":0}},{"line":321,"address":[8942128],"length":1,"stats":{"Line":3}},{"line":322,"address":[5993086],"length":1,"stats":{"Line":3}},{"line":323,"address":[6130872],"length":1,"stats":{"Line":3}},{"line":324,"address":[5993698],"length":1,"stats":{"Line":3}},{"line":329,"address":[7144576,7147518,7142608],"length":1,"stats":{"Line":4}},{"line":331,"address":[7142631],"length":1,"stats":{"Line":4}},{"line":332,"address":[8943564],"length":1,"stats":{"Line":4}},{"line":334,"address":[7095388],"length":1,"stats":{"Line":4}},{"line":335,"address":[7054664,7054597],"length":1,"stats":{"Line":8}},{"line":336,"address":[6132556,6137026],"length":1,"stats":{"Line":8}},{"line":337,"address":[7100248,7100214],"length":1,"stats":{"Line":4}},{"line":342,"address":[7095686,7095860],"length":1,"stats":{"Line":8}},{"line":344,"address":[7090605,7090733],"length":1,"stats":{"Line":8}},{"line":347,"address":[7143479,7143536],"length":1,"stats":{"Line":8}},{"line":348,"address":[6018672,6018686],"length":1,"stats":{"Line":16}},{"line":351,"address":[5995929,5995809],"length":1,"stats":{"Line":8}},{"line":352,"address":[7055944,7056552],"length":1,"stats":{"Line":16}},{"line":353,"address":[5997146],"length":1,"stats":{"Line":4}},{"line":354,"address":[6134445,6134367,6136983],"length":1,"stats":{"Line":4}},{"line":355,"address":[7144740],"length":1,"stats":{"Line":0}},{"line":359,"address":[6134259,6133721],"length":1,"stats":{"Line":4}},{"line":363,"address":[8945445],"length":1,"stats":{"Line":4}},{"line":364,"address":[7145285,7144514,7145420],"length":1,"stats":{"Line":12}},{"line":365,"address":[7057453,7057556],"length":1,"stats":{"Line":8}},{"line":366,"address":[7098435,7098515,7098464],"length":1,"stats":{"Line":8}},{"line":371,"address":[5997796],"length":1,"stats":{"Line":4}},{"line":372,"address":[5997982,5997881],"length":1,"stats":{"Line":8}},{"line":374,"address":[7093736],"length":1,"stats":{"Line":4}},{"line":375,"address":[7093463],"length":1,"stats":{"Line":4}},{"line":376,"address":[7098910],"length":1,"stats":{"Line":4}},{"line":377,"address":[7146154,7146222],"length":1,"stats":{"Line":8}},{"line":379,"address":[7146266],"length":1,"stats":{"Line":4}},{"line":383,"address":[7099340],"length":1,"stats":{"Line":4}},{"line":386,"address":[7383314,7383296],"length":1,"stats":{"Line":12}},{"line":388,"address":[7099427,7099901],"length":1,"stats":{"Line":8}},{"line":389,"address":[7146786,7146755,7146682,7147056],"length":1,"stats":{"Line":8}},{"line":390,"address":[6136653],"length":1,"stats":{"Line":4}},{"line":397,"address":[8927938,8925808,8927840],"length":1,"stats":{"Line":4}},{"line":399,"address":[5977359],"length":1,"stats":{"Line":4}},{"line":401,"address":[5977408],"length":1,"stats":{"Line":4}},{"line":402,"address":[5977548,5977476],"length":1,"stats":{"Line":8}},{"line":403,"address":[5977714,5977846],"length":1,"stats":{"Line":8}},{"line":404,"address":[7078133],"length":1,"stats":{"Line":4}},{"line":405,"address":[8926381,8927135,8926460],"length":1,"stats":{"Line":10}},{"line":406,"address":[7140410,7140470],"length":1,"stats":{"Line":4}},{"line":407,"address":[7078514,7078582],"length":1,"stats":{"Line":4}},{"line":408,"address":[5979371,5978540,5978405,5978316],"length":1,"stats":{"Line":8}},{"line":409,"address":[7038177,7038089],"length":1,"stats":{"Line":4}},{"line":411,"address":[7079056,7078999],"length":1,"stats":{"Line":4}},{"line":412,"address":[7141439],"length":1,"stats":{"Line":2}},{"line":413,"address":[6116046],"length":1,"stats":{"Line":2}},{"line":414,"address":[7079141],"length":1,"stats":{"Line":2}},{"line":415,"address":[8927373,8927452],"length":1,"stats":{"Line":4}},{"line":416,"address":[8927574,8927496],"length":1,"stats":{"Line":4}},{"line":417,"address":[7074005],"length":1,"stats":{"Line":2}},{"line":423,"address":[8926216],"length":1,"stats":{"Line":4}},{"line":426,"address":[7147952,7154204,7151966],"length":1,"stats":{"Line":4}},{"line":428,"address":[5969151],"length":1,"stats":{"Line":4}},{"line":430,"address":[7064100,7064168],"length":1,"stats":{"Line":8}},{"line":433,"address":[7148170],"length":1,"stats":{"Line":4}},{"line":434,"address":[5968894,5968822],"length":1,"stats":{"Line":8}},{"line":435,"address":[5974743,5969037],"length":1,"stats":{"Line":8}},{"line":436,"address":[5974852],"length":1,"stats":{"Line":4}},{"line":437,"address":[6112688],"length":1,"stats":{"Line":4}},{"line":443,"address":[6106847],"length":1,"stats":{"Line":4}},{"line":444,"address":[6106866],"length":1,"stats":{"Line":4}},{"line":446,"address":[7070094,7070017],"length":1,"stats":{"Line":8}},{"line":447,"address":[5969402,5969595],"length":1,"stats":{"Line":8}},{"line":448,"address":[7148953],"length":1,"stats":{"Line":4}},{"line":449,"address":[7149022,7149069,7149124],"length":1,"stats":{"Line":12}},{"line":451,"address":[7029880],"length":1,"stats":{"Line":4}},{"line":452,"address":[8919063,8918967,8919190],"length":1,"stats":{"Line":12}},{"line":453,"address":[7073628,7071127],"length":1,"stats":{"Line":12}},{"line":454,"address":[5973473],"length":1,"stats":{"Line":3}},{"line":456,"address":[7068461,7068393],"length":1,"stats":{"Line":6}},{"line":457,"address":[5973699],"length":1,"stats":{"Line":0}},{"line":458,"address":[8922589,8922317],"length":1,"stats":{"Line":0}},{"line":459,"address":[7033442,7033397],"length":1,"stats":{"Line":0}},{"line":463,"address":[8922729,8922083,8922594],"length":1,"stats":{"Line":9}},{"line":464,"address":[7152950,7153069],"length":1,"stats":{"Line":6}},{"line":465,"address":[5974600],"length":1,"stats":{"Line":3}},{"line":466,"address":[7153527],"length":1,"stats":{"Line":3}},{"line":467,"address":[7034135],"length":1,"stats":{"Line":3}},{"line":468,"address":[6111886],"length":1,"stats":{"Line":3}},{"line":469,"address":[7034291,7034209],"length":1,"stats":{"Line":6}},{"line":471,"address":[7153471],"length":1,"stats":{"Line":3}},{"line":478,"address":[5970892,5971074],"length":1,"stats":{"Line":8}},{"line":479,"address":[7030816,7030658],"length":1,"stats":{"Line":8}},{"line":480,"address":[7359712,7359713],"length":1,"stats":{"Line":16}},{"line":482,"address":[6108836],"length":1,"stats":{"Line":4}},{"line":483,"address":[5971688],"length":1,"stats":{"Line":4}},{"line":484,"address":[5971223],"length":1,"stats":{"Line":4}},{"line":488,"address":[5972059],"length":1,"stats":{"Line":3}},{"line":489,"address":[8920583],"length":1,"stats":{"Line":9}},{"line":490,"address":[7031771],"length":1,"stats":{"Line":3}},{"line":492,"address":[7151064,7150793],"length":1,"stats":{"Line":6}},{"line":493,"address":[5971904,5971839],"length":1,"stats":{"Line":6}},{"line":494,"address":[5972610],"length":1,"stats":{"Line":3}},{"line":495,"address":[7067634],"length":1,"stats":{"Line":3}},{"line":496,"address":[5972529],"length":1,"stats":{"Line":2}},{"line":497,"address":[7151528],"length":1,"stats":{"Line":2}},{"line":498,"address":[6110059],"length":1,"stats":{"Line":2}},{"line":499,"address":[7032382,7032470],"length":1,"stats":{"Line":4}},{"line":501,"address":[7032514],"length":1,"stats":{"Line":2}},{"line":509,"address":[7064867],"length":1,"stats":{"Line":4}}],"covered":199,"coverable":217},{"path":["/","home","dio","knowledge-rs","src","graph","resolver.rs"],"content":"use std::collections::HashMap;\nuse std::path::{Path, PathBuf};\n\nuse crate::graph::{Item, ItemId, ItemType, KnowledgeGraph};\n\npub struct Resolver\u003c'a\u003e {\n    graph: \u0026'a KnowledgeGraph,\n    // name -\u003e items (functions, types, etc.)\n    name_index: HashMap\u003cString, Vec\u003cItemId\u003e\u003e, \n    // module (file stem) -\u003e file-level module item id\n    module_index: HashMap\u003cString, ItemId\u003e,\n    // item -\u003e file mapping\n    item_to_file: HashMap\u003cItemId, PathBuf\u003e,\n    // alias (from pub use ... as Alias) -\u003e fully-qualified target segments\n    alias_map: HashMap\u003cString, Vec\u003cString\u003e\u003e,\n    // per-file exposure of names via non-aliased re-exports: exposed name -\u003e fully-qualified target segments\n    exposure_map: HashMap\u003cPathBuf, HashMap\u003cString, Vec\u003cString\u003e\u003e\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::graph::*;\n    use std::path::PathBuf;\n\n    fn mk_fn(id: \u0026str, name: \u0026str, file: \u0026Path) -\u003e Item {\n        Item {\n            id: ItemId(id.to_string()),\n            item_type: ItemType::Function { is_async: false, is_const: false },\n            name: name.to_string(),\n            visibility: Visibility::Public,\n            location: Location { file: file.to_path_buf(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        }\n    }\n\n    fn mk_file_item(path: \u0026Path) -\u003e Item {\n        Item {\n            id: ItemId(format!(\"file:{}\", path.display())),\n            item_type: ItemType::Module { is_inline: false },\n            name: path.file_stem().and_then(|s| s.to_str()).unwrap_or(\"(file)\").to_string(),\n            visibility: Visibility::PubCrate,\n            location: Location { file: path.to_path_buf(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        }\n    }\n\n    fn graph_fixture() -\u003e KnowledgeGraph {\n        // src/lib.rs\n        let lib = PathBuf::from(\"src/lib.rs\");\n        let mut lib_node = FileNode::default();\n        lib_node.path = lib.clone();\n        lib_node.items = vec![mk_file_item(\u0026lib)];\n        lib_node.imports = vec![Import { path: \"crate::a::foo\".to_string(), alias: None }];\n\n        // src/a/mod.rs\n        let a_mod = PathBuf::from(\"src/a/mod.rs\");\n        let mut a_node = FileNode::default();\n        a_node.path = a_mod.clone();\n        a_node.items = vec![mk_file_item(\u0026a_mod)];\n\n        // src/a/foo.rs\n        let a_foo = PathBuf::from(\"src/a/foo.rs\");\n        let mut afoo_node = FileNode::default();\n        afoo_node.path = a_foo.clone();\n        afoo_node.items = vec![mk_file_item(\u0026a_foo), mk_fn(\"fn:foo:1\", \"foo\", \u0026a_foo)];\n\n        // src/b/bar.rs\n        let b_bar = PathBuf::from(\"src/b/bar.rs\");\n        let mut bbar_node = FileNode::default();\n        bbar_node.path = b_bar.clone();\n        bbar_node.items = vec![mk_file_item(\u0026b_bar), mk_fn(\"fn:bar:1\", \"bar\", \u0026b_bar)];\n\n        let mut g = KnowledgeGraph::default();\n        g.files.insert(lib.clone(), lib_node);\n        g.files.insert(a_mod.clone(), a_node);\n        g.files.insert(a_foo.clone(), afoo_node);\n        g.files.insert(b_bar.clone(), bbar_node);\n        g\n    }\n\n    #[test]\n    fn resolve_crate_path() {\n        let g = graph_fixture();\n        let res = Resolver::new(\u0026g);\n        let from = Path::new(\"src/lib.rs\");\n        let ids = res.resolve_import(from, \"crate::a::foo\");\n        // Should resolve to function named foo\n        assert!(ids.iter().any(|id| id.0.starts_with(\"fn:foo:\")));\n    }\n\n    #[test]\n    fn alias_underscore_is_ignored() {\n        // Graph with a module m1 and a function inside; alias as '_' should not bind a usable name\n        let lib = PathBuf::from(\"src/lib.rs\");\n        let mut lib_node = FileNode::default();\n        lib_node.path = lib.clone();\n        lib_node.items = vec![mk_file_item(\u0026lib)];\n        lib_node.imports = vec![Import { path: \"crate::m1\".to_string(), alias: Some(\"_\".to_string()) }];\n\n        let m1_mod = PathBuf::from(\"src/m1/mod.rs\");\n        let mut m1_node = FileNode::default();\n        m1_node.path = m1_mod.clone();\n        m1_node.items = vec![mk_file_item(\u0026m1_mod)];\n\n        let mut g = KnowledgeGraph::default();\n        g.files.insert(lib.clone(), lib_node);\n        g.files.insert(m1_mod.clone(), m1_node);\n\n        let res = Resolver::new(\u0026g);\n        let from = std::path::Path::new(\"src/lib.rs\");\n        // Resolving '_' should produce nothing since '_' alias is ignored\n        let ids = res.resolve_import(from, \"_\");\n        assert!(ids.is_empty());\n    }\n\n    #[test]\n    fn exposure_reexport_maps_last_segment() {\n        // Non-aliased re-export in lib exposes last segment locally\n        let lib = PathBuf::from(\"src/lib.rs\");\n        let mut lib_node = FileNode::default();\n        lib_node.path = lib.clone();\n        lib_node.items = vec![mk_file_item(\u0026lib)];\n        // Expose baz\n        lib_node.imports = vec![Import { path: \"crate::m1::m2::baz\".to_string(), alias: None }];\n\n        let m1_mod = PathBuf::from(\"src/m1/mod.rs\");\n        let mut m1_node = FileNode::default();\n        m1_node.path = m1_mod.clone();\n        m1_node.items = vec![mk_file_item(\u0026m1_mod)];\n\n        let m2_mod = PathBuf::from(\"src/m1/m2/mod.rs\");\n        let mut m2_node = FileNode::default();\n        m2_node.path = m2_mod.clone();\n        m2_node.items = vec![mk_file_item(\u0026m2_mod)];\n\n        let baz_rs = PathBuf::from(\"src/m1/m2/baz.rs\");\n        let mut baz_node = FileNode::default();\n        baz_node.path = baz_rs.clone();\n        baz_node.items = vec![mk_file_item(\u0026baz_rs), mk_fn(\"fn:baz:2\", \"baz\", \u0026baz_rs)];\n\n        let mut g = KnowledgeGraph::default();\n        g.files.insert(lib.clone(), lib_node);\n        g.files.insert(m1_mod.clone(), m1_node);\n        g.files.insert(m2_mod.clone(), m2_node);\n        g.files.insert(baz_rs.clone(), baz_node);\n\n        let res = Resolver::new(\u0026g);\n        let from = std::path::Path::new(\"src/lib.rs\");\n        let ids = res.resolve_import(from, \"baz\");\n        assert!(ids.iter().any(|id| id.0.starts_with(\"fn:baz:\")));\n    }\n\n    #[test]\n    fn deep_super_navigation_and_helpers() {\n        // Build: src/m1/m2/baz.rs with function baz, and src/m3/qux.rs with function qux\n        // From src/m1/m2/baz.rs, resolve crate::m3::qux and super::super::m3::qux\n        let lib = PathBuf::from(\"src/lib.rs\");\n        let mut lib_node = FileNode::default();\n        lib_node.path = lib.clone();\n        lib_node.items = vec![mk_file_item(\u0026lib)];\n\n        let m1_mod = PathBuf::from(\"src/m1/mod.rs\");\n        let mut m1_node = FileNode::default();\n        m1_node.path = m1_mod.clone();\n        m1_node.items = vec![mk_file_item(\u0026m1_mod)];\n\n        let m2_mod = PathBuf::from(\"src/m1/m2/mod.rs\");\n        let mut m2_node = FileNode::default();\n        m2_node.path = m2_mod.clone();\n        m2_node.items = vec![mk_file_item(\u0026m2_mod)];\n\n        let baz_rs = PathBuf::from(\"src/m1/m2/baz.rs\");\n        let mut baz_node = FileNode::default();\n        baz_node.path = baz_rs.clone();\n        baz_node.items = vec![mk_file_item(\u0026baz_rs), mk_fn(\"fn:baz:3\", \"baz\", \u0026baz_rs)];\n\n        let m3_mod = PathBuf::from(\"src/m3/mod.rs\");\n        let mut m3_node = FileNode::default();\n        m3_node.path = m3_mod.clone();\n        m3_node.items = vec![mk_file_item(\u0026m3_mod)];\n\n        let qux_rs = PathBuf::from(\"src/m3/qux.rs\");\n        let mut qux_node = FileNode::default();\n        qux_node.path = qux_rs.clone();\n        qux_node.items = vec![mk_file_item(\u0026qux_rs), mk_fn(\"fn:qux:1\", \"qux\", \u0026qux_rs)];\n\n        let mut g = KnowledgeGraph::default();\n        g.files.insert(lib.clone(), lib_node);\n        g.files.insert(m1_mod.clone(), m1_node);\n        g.files.insert(m2_mod.clone(), m2_node);\n        g.files.insert(baz_rs.clone(), baz_node);\n        g.files.insert(m3_mod.clone(), m3_node);\n        g.files.insert(qux_rs.clone(), qux_node);\n\n        let res = Resolver::new(\u0026g);\n        let from = std::path::Path::new(\"src/m1/m2/baz.rs\");\n        let ids1 = res.resolve_import(from, \"crate::m3::qux\");\n        assert!(ids1.iter().any(|id| id.0.starts_with(\"fn:qux:\")));\n        let ids2 = res.resolve_import(from, \"super::super::m3::qux\");\n        assert!(ids2.iter().any(|id| id.0.starts_with(\"fn:qux:\")));\n\n        // Helper checks: pick an actual function id among results\n        let func_id = ids1\n            .iter()\n            .find(|id| res.is_item_function(id))\n            .cloned()\n            .expect(\"expected a function id among resolved targets\");\n        assert!(res.is_item_function(\u0026func_id));\n        // file-level module id\n        let file_level_id = ItemId(format!(\"file:{}\", baz_rs.display()));\n        assert!(res.is_file_level_module(\u0026file_level_id));\n    }\n\n    #[test]\n    fn resolve_multi_segment_chain() {\n        // Build a nested module structure: src/m1/mod.rs, src/m1/m2/mod.rs, src/m1/m2/baz.rs\n        let lib = PathBuf::from(\"src/lib.rs\");\n        let mut lib_node = FileNode::default();\n        lib_node.path = lib.clone();\n        lib_node.items = vec![mk_file_item(\u0026lib)];\n\n        let m1_mod = PathBuf::from(\"src/m1/mod.rs\");\n        let mut m1_node = FileNode::default();\n        m1_node.path = m1_mod.clone();\n        m1_node.items = vec![mk_file_item(\u0026m1_mod)];\n\n        let m2_mod = PathBuf::from(\"src/m1/m2/mod.rs\");\n        let mut m2_node = FileNode::default();\n        m2_node.path = m2_mod.clone();\n        m2_node.items = vec![mk_file_item(\u0026m2_mod)];\n\n        let baz_rs = PathBuf::from(\"src/m1/m2/baz.rs\");\n        let mut baz_node = FileNode::default();\n        baz_node.path = baz_rs.clone();\n        baz_node.items = vec![mk_file_item(\u0026baz_rs), mk_fn(\"fn:baz:1\", \"baz\", \u0026baz_rs)];\n\n        let mut g = KnowledgeGraph::default();\n        g.files.insert(lib.clone(), lib_node);\n        g.files.insert(m1_mod.clone(), m1_node);\n        g.files.insert(m2_mod.clone(), m2_node);\n        g.files.insert(baz_rs.clone(), baz_node);\n\n        let res = Resolver::new(\u0026g);\n        let from = Path::new(\"src/lib.rs\");\n        let ids = res.resolve_import(from, \"crate::m1::m2::baz\");\n        assert!(ids.iter().any(|id| id.0.starts_with(\"fn:baz:\")));\n    }\n\n    #[test]\n    fn resolve_alias_splicing_with_suffix() {\n        // Build nested modules m1::m2::baz and alias m1 as M1 in lib\n        let lib = PathBuf::from(\"src/lib.rs\");\n        let mut lib_node = FileNode::default();\n        lib_node.path = lib.clone();\n        lib_node.items = vec![mk_file_item(\u0026lib)];\n        lib_node.imports = vec![Import { path: \"crate::m1\".to_string(), alias: Some(\"M1\".to_string()) }];\n\n        let m1_mod = PathBuf::from(\"src/m1/mod.rs\");\n        let mut m1_node = FileNode::default();\n        m1_node.path = m1_mod.clone();\n        m1_node.items = vec![mk_file_item(\u0026m1_mod)];\n\n        let m2_mod = PathBuf::from(\"src/m1/m2/mod.rs\");\n        let mut m2_node = FileNode::default();\n        m2_node.path = m2_mod.clone();\n        m2_node.items = vec![mk_file_item(\u0026m2_mod)];\n\n        let baz_rs = PathBuf::from(\"src/m1/m2/baz.rs\");\n        let mut baz_node = FileNode::default();\n        baz_node.path = baz_rs.clone();\n        baz_node.items = vec![mk_file_item(\u0026baz_rs), mk_fn(\"fn:baz:1\", \"baz\", \u0026baz_rs)];\n\n        let mut g = KnowledgeGraph::default();\n        g.files.insert(lib.clone(), lib_node);\n        g.files.insert(m1_mod.clone(), m1_node);\n        g.files.insert(m2_mod.clone(), m2_node);\n        g.files.insert(baz_rs.clone(), baz_node);\n\n        let res = Resolver::new(\u0026g);\n        let from = Path::new(\"src/lib.rs\");\n        let ids = res.resolve_import(from, \"M1::m2::baz\");\n        assert!(ids.iter().any(|id| id.0.starts_with(\"fn:baz:\")));\n    }\n\n    #[test]\n    fn resolve_super_and_self() {\n        let g = graph_fixture();\n        let res = Resolver::new(\u0026g);\n        // From src/a/foo.rs, `super` should go to src/a/mod.rs scope\n        let from = Path::new(\"src/a/foo.rs\");\n        let ids = res.resolve_import(from, \"super::foo\");\n        // name_index fallback will still find foo function\n        assert!(ids.iter().any(|id| id.0.starts_with(\"fn:foo:\")));\n\n        let ids2 = res.resolve_import(from, \"self::foo\");\n        assert!(ids2.iter().any(|id| id.0.starts_with(\"fn:foo:\")));\n    }\n\n    #[test]\n    fn resolve_alias_basic() {\n        // Extend graph with an alias in lib imports\n        let mut g = graph_fixture();\n        if let Some(lib) = g.files.get_mut(\u0026PathBuf::from(\"src/lib.rs\")) {\n            lib.imports.push(Import { path: \"crate::a::foo\".to_string(), alias: Some(\"FooAlias\".to_string()) });\n        }\n        let res = Resolver::new(\u0026g);\n        let from = Path::new(\"src/lib.rs\");\n        // If another import references the alias as first segment, resolver should remap it.\n        let ids = res.resolve_import(from, \"FooAlias\");\n        assert!(ids.iter().any(|id| id.0.starts_with(\"fn:foo:\")));\n    }\n}\nimpl\u003c'a\u003e Resolver\u003c'a\u003e {\n    // Compute module segments relative to src/ for a given file path.\n    fn module_segments_for(\u0026self, path: \u0026Path) -\u003e Vec\u003cString\u003e {\n        // Find \"src\" segment index\n        let mut src_idx: Option\u003cusize\u003e = None;\n        let comps: Vec\u003c_\u003e = path.components().collect();\n        for (i, c) in comps.iter().enumerate() {\n            if let std::path::Component::Normal(os) = c {\n                if os.to_str() == Some(\"src\") { src_idx = Some(i); break; }\n            }\n        }\n        let mut segs: Vec\u003cString\u003e = Vec::new();\n        if let Some(i) = src_idx {\n            // Collect directory names after src up to the file\n            for c in \u0026comps[i+1..comps.len().saturating_sub(1)] {\n                if let std::path::Component::Normal(os) = c {\n                    if let Some(s) = os.to_str() { segs.push(s.to_string()); }\n                }\n            }\n            // Handle file as module: if mod.rs or lib.rs =\u003e use last dir as module; else file stem\n            if let Some(file_os) = path.file_name() {\n                let file = file_os.to_string_lossy();\n                if file == \"mod.rs\" || file == \"lib.rs\" {\n                    // nothing to add; module is the parent dir already captured\n                } else if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {\n                    segs.push(stem.to_string());\n                }\n            }\n        }\n        segs\n    }\n}\n\nimpl\u003c'a\u003e Resolver\u003c'a\u003e {\n    pub fn new(graph: \u0026'a KnowledgeGraph) -\u003e Self {\n        let mut name_index: HashMap\u003cString, Vec\u003cItemId\u003e\u003e = HashMap::new();\n        let mut module_index: HashMap\u003cString, ItemId\u003e = HashMap::new();\n        let mut item_to_file: HashMap\u003cItemId, PathBuf\u003e = HashMap::new();\n        let mut alias_map: HashMap\u003cString, Vec\u003cString\u003e\u003e = HashMap::new();\n        let mut exposure_map: HashMap\u003cPathBuf, HashMap\u003cString, Vec\u003cString\u003e\u003e\u003e = HashMap::new();\n        for (path, file) in \u0026graph.files {\n            for (idx, it) in file.items.iter().enumerate() {\n                item_to_file.insert(it.id.clone(), path.clone());\n                name_index.entry(it.name.clone()).or_default().push(it.id.clone());\n                if idx == 0 {\n                    if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {\n                        module_index.insert(stem.to_string(), it.id.clone());\n                    }\n                }\n            }\n            for imp in \u0026file.imports {\n                let segments: Vec\u003cString\u003e = imp\n                    .path\n                    .split(\"::\")\n                    .filter(|s| !s.is_empty())\n                    .map(|s| s.to_string())\n                    .collect();\n                if let Some(alias) = \u0026imp.alias {\n                    // Ignore underscore imports: `use path as _;` doesn't bind a name\n                    if alias == \"_\" { continue; }\n                    if !alias.is_empty() \u0026\u0026 !segments.is_empty() {\n                        alias_map.insert(alias.clone(), segments.clone());\n                    }\n                } else {\n                    // Non-aliased re-export exposes the last segment under the same name within this file/module\n                    if let Some(last) = segments.last() {\n                        exposure_map\n                            .entry(path.clone())\n                            .or_default()\n                            .insert(last.clone(), segments.clone());\n                    }\n                }\n            }\n        }\n        Self { graph, name_index, module_index, item_to_file, alias_map, exposure_map }\n    }\n\n    // Resolve an import path relative to a given file.\n    // Returns a list because globs or ambiguous names can map to multiple targets.\n    pub fn resolve_import(\u0026self, from_file: \u0026Path, raw_path: \u0026str) -\u003e Vec\u003cItemId\u003e {\n        // Strip aliasing `as X`\n        let path = raw_path.split(\" as \").next().unwrap_or(raw_path).trim();\n        let mut parts: Vec\u003cString\u003e = path\n            .split(\"::\")\n            .filter(|s| !s.is_empty())\n            .map(|s| s.to_string())\n            .collect();\n        if parts.is_empty() { return Vec::new(); }\n\n        // Best-effort normalization of crate/self/super using filesystem layout under src/\n        let mut scope: Vec\u003cString\u003e = self.module_segments_for(from_file);\n        loop {\n            match parts.first().map(|s| s.as_str()) {\n                Some(\"crate\") =\u003e { parts.remove(0); scope.clear(); }\n                Some(\"self\") =\u003e { parts.remove(0); /* stay in same scope */ }\n                Some(\"super\") =\u003e { parts.remove(0); if !scope.is_empty() { scope.pop(); } }\n                _ =\u003e break,\n            }\n        }\n        if parts.is_empty() { return Vec::new(); }\n\n        // Apply alias mapping on the first segment, if any\n        if let Some(first) = parts.first().cloned() {\n            if let Some(mapped) = self.alias_map.get(\u0026first) {\n                parts.remove(0);\n                let mut new_parts = mapped.clone();\n                new_parts.extend(parts.into_iter());\n                parts = new_parts;\n            }\n        }\n\n        // Apply per-file exposure mapping (re-exports without alias)\n        if let Some(first) = parts.first().cloned() {\n            if let Some(map) = self.exposure_map.get(from_file) {\n                if let Some(mapped) = map.get(\u0026first) {\n                    parts.remove(0);\n                    let mut new_parts = mapped.clone();\n                    new_parts.extend(parts.into_iter());\n                    parts = new_parts;\n                }\n            }\n        }\n\n        // Try to resolve using scoped module chain based on filesystem under src/\n        // Prepare a borrowable slice of \u0026str for scoped chain\n        let parts_str: Vec\u003c\u0026str\u003e = parts.iter().map(|s| s.as_str()).collect();\n        if let Some(ids) = self.resolve_scoped_chain(from_file, \u0026scope, \u0026parts_str) {\n            return ids;\n        }\n\n        // Fallback: Try exact item name match on the last segment\n        let last = parts.last().unwrap().as_str();\n        if let Some(ids) = self.name_index.get(last) {\n            return ids.clone();\n        }\n\n        // Fallback: map segment to a module (file-level) item\n        if let Some(mid) = self.module_index.get(last) {\n            return vec![mid.clone()];\n        }\n\n        // If there are multiple segments, try mapping first to a module and last to a symbol\n        if parts.len() \u003e= 2 {\n            let first = parts[0].as_str();\n            if let Some(_m0) = self.module_index.get(first) {\n                if let Some(ids) = self.name_index.get(last) {\n                    return ids.clone();\n                }\n            }\n            // Try combining scope head with parts\n            if let Some(scope_head) = scope.first() {\n                if let Some(_m) = self.module_index.get(scope_head) {\n                    if let Some(ids) = self.name_index.get(last) {\n                        return ids.clone();\n                    }\n                }\n            }\n        }\n\n        Vec::new()\n    }\n\n    pub fn is_item_function(\u0026self, id: \u0026ItemId) -\u003e bool {\n        if let Some(file) = self.item_to_file.get(id).and_then(|p| self.graph.files.get(p)) {\n            if let Some(Item { item_type, .. }) = file.items.iter().find(|it| \u0026it.id == id) {\n                return matches!(item_type, ItemType::Function { .. });\n            }\n        }\n        false\n    }\n\n    pub fn is_file_level_module(\u0026self, id: \u0026ItemId) -\u003e bool {\n        if let Some(file_path) = self.item_to_file.get(id) {\n            if let Some(file) = self.graph.files.get(file_path) {\n                if let Some(first) = file.items.first() { return \u0026first.id == id; }\n            }\n        }\n        false\n    }\n\n    // Attempt to walk modules using the scope and parts to find the target file/module and then resolve the final item.\n    // Returns Some(vec) on success; None if chain cannot be mapped.\n    fn resolve_scoped_chain(\u0026self, from_file: \u0026Path, scope: \u0026Vec\u003cString\u003e, parts: \u0026Vec\u003c\u0026str\u003e) -\u003e Option\u003cVec\u003cItemId\u003e\u003e {\n        if parts.is_empty() { return None; }\n        let (base_src, _src_idx) = self.base_src_dir(from_file)?;\n        // Build starting module path from scope\n        let mut dir = base_src.clone();\n        let mut scope_dirs: Vec\u003c\u0026str\u003e = scope.iter().map(|s| s.as_str()).collect();\n        // If from_file is a leaf file (not mod.rs/lib.rs), drop last scope segment (file stem)\n        let is_leaf = from_file.file_name()\n            .and_then(|s| s.to_str())\n            .map(|f| f != \"mod.rs\" \u0026\u0026 f != \"lib.rs\")\n            .unwrap_or(false);\n        if is_leaf \u0026\u0026 !scope_dirs.is_empty() { scope_dirs.pop(); }\n        for seg in scope_dirs { dir.push(seg); }\n        // Walk all segments except the last as module directories/files\n        for seg in \u0026parts[..parts.len().saturating_sub(1)] {\n            // Try directory seg\n            dir.push(seg);\n            // Accept if there is either dir/mod.rs or dir/lib.rs in graph\n            let candidates = vec![dir.join(\"mod.rs\"), dir.join(\"lib.rs\")];\n            let mut found_dir = false;\n            for cand in candidates {\n                if self.graph.files.contains_key(\u0026cand) {\n                    found_dir = true;\n                    break;\n                }\n            }\n            if !found_dir {\n                // Try sibling file: parent/\u003cseg\u003e.rs\n                dir.pop();\n                let file_rs = dir.join(format!(\"{}.rs\", seg));\n                if self.graph.files.contains_key(\u0026file_rs) {\n                    // Now move into that file's dir scope for next segments\n                    dir.push(seg);\n                } else {\n                    return None;\n                }\n            }\n        }\n        // Now resolve the last segment inside current dir/module\n        let last = parts[parts.len()-1];\n        // First, try a file in this dir named last.rs\n        let file_rs = dir.join(format!(\"{}.rs\", last));\n        if let Some(fnode) = self.graph.files.get(\u0026file_rs) {\n            // Prefer concrete items named `last` inside that file\n            let ids: Vec\u003cItemId\u003e = fnode.items.iter()\n                .filter(|it| it.name == last)\n                .map(|it| it.id.clone())\n                .collect();\n            if !ids.is_empty() { return Some(ids); }\n            // Else return the file-level module id if known\n            if let Some(mid) = self.module_index.get(last) { return Some(vec![mid.clone()]); }\n        }\n        // Next, try dir/mod.rs or dir/lib.rs containing an item named `last`\n        let container_candidates = vec![dir.join(\"mod.rs\"), dir.join(\"lib.rs\")];\n        for cand in container_candidates {\n            if let Some(fnode) = self.graph.files.get(\u0026cand) {\n                let mut ids: Vec\u003cItemId\u003e = Vec::new();\n                for it in \u0026fnode.items {\n                    if it.name == last { ids.push(it.id.clone()); }\n                }\n                if !ids.is_empty() { return Some(ids); }\n            }\n        }\n        None\n    }\n\n    // Returns (base_src_dir, index_of_src_component) if src is found in the path\n    fn base_src_dir(\u0026self, path: \u0026Path) -\u003e Option\u003c(PathBuf, usize)\u003e {\n        let comps: Vec\u003c_\u003e = path.components().collect();\n        let mut src_idx: Option\u003cusize\u003e = None;\n        for (i, c) in comps.iter().enumerate() {\n            if let std::path::Component::Normal(os) = c { if os.to_str() == Some(\"src\") { src_idx = Some(i); break; } }\n        }\n        let i = src_idx?;\n        let mut base = PathBuf::new();\n        for c in \u0026comps[..=i] {\n            base.push(c.as_os_str());\n        }\n        Some((base, i))\n    }\n}\n","traces":[{"line":316,"address":[7612756,7612956,7611024],"length":1,"stats":{"Line":7}},{"line":318,"address":[7603189],"length":1,"stats":{"Line":5}},{"line":319,"address":[6153505],"length":1,"stats":{"Line":7}},{"line":320,"address":[6015882,6015795],"length":1,"stats":{"Line":11}},{"line":321,"address":[6016230,6016165],"length":1,"stats":{"Line":12}},{"line":322,"address":[6016837],"length":1,"stats":{"Line":4}},{"line":325,"address":[8965256],"length":1,"stats":{"Line":8}},{"line":326,"address":[6016390],"length":1,"stats":{"Line":4}},{"line":328,"address":[6016420,6016619,6016515],"length":1,"stats":{"Line":20}},{"line":329,"address":[6017375,6016826],"length":1,"stats":{"Line":4}},{"line":330,"address":[7604862],"length":1,"stats":{"Line":2}},{"line":334,"address":[6017470],"length":1,"stats":{"Line":4}},{"line":335,"address":[6017000],"length":1,"stats":{"Line":6}},{"line":336,"address":[7077055,7077129,7077187],"length":1,"stats":{"Line":14}},{"line":338,"address":[6017753],"length":1,"stats":{"Line":9}},{"line":339,"address":[8966362],"length":1,"stats":{"Line":3}},{"line":343,"address":[7076498],"length":1,"stats":{"Line":3}},{"line":348,"address":[],"length":0,"stats":{"Line":6}},{"line":349,"address":[6143591],"length":1,"stats":{"Line":7}},{"line":350,"address":[7593336],"length":1,"stats":{"Line":6}},{"line":351,"address":[6143703],"length":1,"stats":{"Line":7}},{"line":352,"address":[7593459],"length":1,"stats":{"Line":6}},{"line":353,"address":[8955103],"length":1,"stats":{"Line":8}},{"line":354,"address":[7593651,7593587],"length":1,"stats":{"Line":14}},{"line":355,"address":[6006351,6006714],"length":1,"stats":{"Line":13}},{"line":356,"address":[7603660,7604318,7603637,7602397],"length":1,"stats":{"Line":14}},{"line":357,"address":[7603787],"length":1,"stats":{"Line":8}},{"line":358,"address":[6146322],"length":1,"stats":{"Line":5}},{"line":359,"address":[6146340],"length":1,"stats":{"Line":22}},{"line":360,"address":[6009378,6009328],"length":1,"stats":{"Line":6}},{"line":364,"address":[7602415],"length":1,"stats":{"Line":8}},{"line":365,"address":[6007188],"length":1,"stats":{"Line":3}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[6145035],"length":1,"stats":{"Line":13}},{"line":369,"address":[6007286],"length":1,"stats":{"Line":13}},{"line":371,"address":[7049336],"length":1,"stats":{"Line":5}},{"line":373,"address":[6145182,6145292],"length":1,"stats":{"Line":2}},{"line":374,"address":[7602959,7602914,7603014],"length":1,"stats":{"Line":3}},{"line":375,"address":[7067676,7067752],"length":1,"stats":{"Line":1}},{"line":379,"address":[6008028,6008452],"length":1,"stats":{"Line":7}},{"line":380,"address":[7603534],"length":1,"stats":{"Line":3}},{"line":381,"address":[8957017],"length":1,"stats":{"Line":3}},{"line":383,"address":[],"length":0,"stats":{"Line":8}},{"line":393,"address":[6149297,6151962,6147280],"length":1,"stats":{"Line":3}},{"line":395,"address":[6009640],"length":1,"stats":{"Line":3}},{"line":396,"address":[6009885],"length":1,"stats":{"Line":3}},{"line":398,"address":[7061726,7061712],"length":1,"stats":{"Line":11}},{"line":399,"address":[7042259],"length":1,"stats":{"Line":11}},{"line":401,"address":[],"length":0,"stats":{"Line":10}},{"line":404,"address":[6010651,6010622],"length":1,"stats":{"Line":11}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[6340585,6340576],"length":1,"stats":{"Line":23}},{"line":407,"address":[7597871,7598189,7597823,7597745],"length":1,"stats":{"Line":19}},{"line":408,"address":[7605749,7605885,7606087,7605837],"length":1,"stats":{"Line":12}},{"line":409,"address":[7605843,7605931],"length":1,"stats":{"Line":11}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[7043128,7043177,7046421,7042686],"length":1,"stats":{"Line":14}},{"line":416,"address":[7606165,7606238],"length":1,"stats":{"Line":14}},{"line":417,"address":[7071017,7071141,7071564],"length":1,"stats":{"Line":15}},{"line":418,"address":[7043501,7043557],"length":1,"stats":{"Line":2}},{"line":419,"address":[],"length":0,"stats":{"Line":1}},{"line":420,"address":[7043721,7043610],"length":1,"stats":{"Line":2}},{"line":421,"address":[6012004],"length":1,"stats":{"Line":1}},{"line":426,"address":[7071591,7071051],"length":1,"stats":{"Line":12}},{"line":427,"address":[7044125,7044013],"length":1,"stats":{"Line":12}},{"line":428,"address":[7599325,7599382,7599783],"length":1,"stats":{"Line":6}},{"line":429,"address":[8961029],"length":1,"stats":{"Line":1}},{"line":430,"address":[],"length":0,"stats":{"Line":1}},{"line":431,"address":[6149838,6149949],"length":1,"stats":{"Line":2}},{"line":432,"address":[7607599],"length":1,"stats":{"Line":1}},{"line":439,"address":[7067337,7067312],"length":1,"stats":{"Line":28}},{"line":440,"address":[7044794,7044845],"length":1,"stats":{"Line":7}},{"line":441,"address":[7600101],"length":1,"stats":{"Line":3}},{"line":445,"address":[7044975,7045048],"length":1,"stats":{"Line":8}},{"line":446,"address":[8961938],"length":1,"stats":{"Line":4}},{"line":447,"address":[6012976,6013035],"length":1,"stats":{"Line":8}},{"line":451,"address":[6150791,6150821],"length":1,"stats":{"Line":2}},{"line":452,"address":[7045459,7045410],"length":1,"stats":{"Line":0}},{"line":456,"address":[6150903,6151163],"length":1,"stats":{"Line":2}},{"line":457,"address":[6151191],"length":1,"stats":{"Line":0}},{"line":458,"address":[6014098],"length":1,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[7609116],"length":1,"stats":{"Line":0}},{"line":464,"address":[7046031,7045905],"length":1,"stats":{"Line":0}},{"line":465,"address":[7073893],"length":1,"stats":{"Line":0}},{"line":466,"address":[7609342],"length":1,"stats":{"Line":0}},{"line":467,"address":[8963096],"length":1,"stats":{"Line":0}},{"line":473,"address":[6013993],"length":1,"stats":{"Line":1}},{"line":476,"address":[7069280],"length":1,"stats":{"Line":1}},{"line":477,"address":[8915200,8915214],"length":1,"stats":{"Line":3}},{"line":478,"address":[6470672,6470686],"length":1,"stats":{"Line":4}},{"line":479,"address":[7052997],"length":1,"stats":{"Line":1}},{"line":482,"address":[7052970],"length":1,"stats":{"Line":0}},{"line":485,"address":[7596448],"length":1,"stats":{"Line":2}},{"line":486,"address":[7604386],"length":1,"stats":{"Line":2}},{"line":487,"address":[7596528,7596581],"length":1,"stats":{"Line":4}},{"line":488,"address":[7604511],"length":1,"stats":{"Line":2}},{"line":491,"address":[6009102],"length":1,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":9}},{"line":497,"address":[7060318,7060194],"length":1,"stats":{"Line":4}},{"line":498,"address":[8949352,8949244],"length":1,"stats":{"Line":12}},{"line":500,"address":[8949459],"length":1,"stats":{"Line":8}},{"line":501,"address":[7061689,7061664],"length":1,"stats":{"Line":14}},{"line":503,"address":[7596067,7596249],"length":1,"stats":{"Line":12}},{"line":504,"address":[7596151],"length":1,"stats":{"Line":18}},{"line":505,"address":[6000802],"length":1,"stats":{"Line":16}},{"line":507,"address":[6001532,6001461],"length":1,"stats":{"Line":7}},{"line":508,"address":[],"length":0,"stats":{"Line":11}},{"line":510,"address":[],"length":0,"stats":{"Line":8}},{"line":512,"address":[6002141],"length":1,"stats":{"Line":4}},{"line":514,"address":[],"length":0,"stats":{"Line":6}},{"line":515,"address":[6142653],"length":1,"stats":{"Line":4}},{"line":516,"address":[7041198,7041036],"length":1,"stats":{"Line":10}},{"line":517,"address":[],"length":0,"stats":{"Line":10}},{"line":518,"address":[7041396],"length":1,"stats":{"Line":3}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[7592748],"length":1,"stats":{"Line":3}},{"line":524,"address":[6005290],"length":1,"stats":{"Line":4}},{"line":525,"address":[7592789],"length":1,"stats":{"Line":3}},{"line":526,"address":[7065574,7065652],"length":1,"stats":{"Line":7}},{"line":528,"address":[7593125],"length":1,"stats":{"Line":2}},{"line":530,"address":[7041771],"length":1,"stats":{"Line":2}},{"line":535,"address":[7061635],"length":1,"stats":{"Line":4}},{"line":537,"address":[6001736],"length":1,"stats":{"Line":4}},{"line":538,"address":[6002561,6002647],"length":1,"stats":{"Line":8}},{"line":540,"address":[6002185,6002110],"length":1,"stats":{"Line":6}},{"line":541,"address":[8951284],"length":1,"stats":{"Line":7}},{"line":542,"address":[6140031],"length":1,"stats":{"Line":8}},{"line":544,"address":[7589781,7589858],"length":1,"stats":{"Line":6}},{"line":546,"address":[6003154,6003280,6003085,6003559],"length":1,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":8}},{"line":550,"address":[7039605,7039767],"length":1,"stats":{"Line":7}},{"line":551,"address":[7591327,7591122],"length":1,"stats":{"Line":6}},{"line":552,"address":[],"length":0,"stats":{"Line":2}},{"line":553,"address":[6004058,6003967],"length":1,"stats":{"Line":4}},{"line":554,"address":[6004974,6004755],"length":1,"stats":{"Line":4}},{"line":556,"address":[7040371],"length":1,"stats":{"Line":2}},{"line":559,"address":[6003724],"length":1,"stats":{"Line":3}},{"line":563,"address":[7603069,7601696,7603091],"length":1,"stats":{"Line":4}},{"line":564,"address":[7046581],"length":1,"stats":{"Line":10}},{"line":565,"address":[7046643],"length":1,"stats":{"Line":4}},{"line":566,"address":[6014387,6014474],"length":1,"stats":{"Line":14}},{"line":567,"address":[6152527,6152607],"length":1,"stats":{"Line":14}},{"line":569,"address":[7610178,7610372],"length":1,"stats":{"Line":14}},{"line":570,"address":[7602533],"length":1,"stats":{"Line":8}},{"line":571,"address":[8964219,8964129],"length":1,"stats":{"Line":12}},{"line":572,"address":[6016165,6015886],"length":1,"stats":{"Line":12}},{"line":574,"address":[],"length":0,"stats":{"Line":4}}],"covered":132,"coverable":148},{"path":["/","home","dio","knowledge-rs","src","lib.rs"],"content":"//! knowledge-rs  Rust Knowledge Graph System\n//!\n//! Build a knowledge graph from a Rust codebase and query relationships.\n//!\n//! # Features\n//! - File discovery with `.gitignore`/`.ignore` support (deterministic; global excludes off)\n//! - Incremental builds with on-disk cache\n//! - Queries: connected files, function usage, cycles, path, hubs, module centrality, trait impls\n//! - DOT and SVG visualization\n//!\n//! # Quickstart (Library)\n//! ```no_run\n//! use knowledge_rs::graph::KnowledgeGraph;\n//! use knowledge_rs::utils::cache::CacheMode;\n//!\n//! let root = std::path::Path::new(\".\");\n//! // Build with cache and respect ignore rules\n//! let graph = KnowledgeGraph::build_from_directory_with_cache_opts(root, CacheMode::Use, /* no_ignore = */ false)\n//!     .expect(\"build graph\");\n//! println!(\"files: {} relationships: {}\", graph.files.len(), graph.relationships.len());\n//! ```\n//!\n//! # Quickstart (CLI)\n//! ```text\n//! knowledge-rs build --path . --json graph.json\n//! knowledge-rs query connected-files --path . --file src/lib.rs --format text\n//! ```\n//!\n//! # Ignore Behavior\n//! Pass `--no-ignore` in CLI to include ignored files. Env `KNOWLEDGE_RS_NO_IGNORE` remains supported for compatibility.\npub mod graph;\npub mod parser;\npub mod visualization;\npub mod cli;\npub mod utils;\npub mod errors;\npub mod query;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","src","main.rs"],"content":"fn main() {\n    use knowledge_rs::cli::{parse, Commands, QueryCommands};\n    use knowledge_rs::visualization::{DotGenerator, DotOptions, DotTheme, RankDir, EdgeStyle, SvgGenerator, SvgOptions};\n    use knowledge_rs::graph::KnowledgeGraph;\n    use knowledge_rs::query::Query;\n    use std::fs;\n\n    let cli = parse();\n\n    match cli.command {\n        Commands::Build { path, config, no_ignore, no_cache, rebuild, json, dot, svg, dot_clusters, dot_legend, dot_theme, dot_rankdir, dot_splines, dot_rounded, svg_interactive, save } =\u003e {\n            // Determine cache mode\n            let mode = if rebuild {\n                knowledge_rs::utils::cache::CacheMode::Rebuild\n            } else if no_cache {\n                knowledge_rs::utils::cache::CacheMode::Ignore\n            } else {\n                knowledge_rs::utils::cache::CacheMode::Use\n            };\n\n            let build_path = std::path::Path::new(\u0026path);\n            // Clear cache file if rebuild was requested\n            if matches!(mode, knowledge_rs::utils::cache::CacheMode::Rebuild) {\n                knowledge_rs::utils::cache::clear_cache(build_path);\n            }\n\n            // Build with explicit ignore option\n            let graph = match KnowledgeGraph::build_from_directory_with_cache_opts(build_path, mode, no_ignore) {\n                Ok(g) =\u003e g,\n                Err(e) =\u003e {\n                    eprintln!(\"Build failed: {}\", e);\n                    std::process::exit(1);\n                }\n            };\n\n            // Optionally write JSON output\n            if let Some(json_path) = json {\n                let serialized = serde_json::to_string_pretty(\u0026graph)\n                    .expect(\"serialize graph to JSON\");\n                if let Err(e) = fs::write(\u0026json_path, serialized) {\n                    eprintln!(\"Failed to write JSON output {}: {}\", json_path, e);\n                }\n            }\n\n            // Common DOT options from flags\n            let mut clusters = matches!(dot_clusters.as_str(), \"on\");\n            let mut legend = matches!(dot_legend.as_str(), \"on\");\n            let mut theme = match dot_theme.as_str() { \"dark\" =\u003e DotTheme::Dark, _ =\u003e DotTheme::Light };\n            let mut rankdir = match dot_rankdir.as_str() { \"TB\" =\u003e RankDir::TB, _ =\u003e RankDir::LR };\n            let mut splines = match dot_splines.as_str() { \"ortho\" =\u003e EdgeStyle::Ortho, \"polyline\" =\u003e EdgeStyle::Polyline, _ =\u003e EdgeStyle::Curved };\n            let mut rounded = matches!(dot_rounded.as_str(), \"on\");\n            // Apply config overrides if provided\n            if let Some(cfg_path) = config.as_ref() {\n                if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                    if let Some(dot) = cfg.dot {\n                        if let Some(v) = dot.clusters { clusters = v; }\n                        if let Some(v) = dot.legend { legend = v; }\n                        if let Some(v) = dot.theme { theme = if v == \"dark\" { DotTheme::Dark } else { DotTheme::Light }; }\n                        if let Some(v) = dot.rankdir { rankdir = if v == \"TB\" { RankDir::TB } else { RankDir::LR }; }\n                        if let Some(v) = dot.splines { splines = match v.as_str() { \"ortho\" =\u003e EdgeStyle::Ortho, \"polyline\" =\u003e EdgeStyle::Polyline, _ =\u003e EdgeStyle::Curved }; }\n                        if let Some(v) = dot.rounded { rounded = v; }\n                    }\n                }\n            }\n            let dot_opts = DotOptions { clusters, legend, theme, rankdir, splines, rounded };\n\n            // Optionally write DOT output\n            if let Some(dot_path) = dot {\n                match DotGenerator::new().generate_dot_with_options(\u0026graph, dot_opts) {\n                    Ok(content) =\u003e {\n                        if let Err(e) = fs::write(\u0026dot_path, content) {\n                            eprintln!(\"Failed to write DOT output {}: {}\", dot_path, e);\n                        }\n                    }\n                    Err(e) =\u003e eprintln!(\"Visualization error: {}\", e),\n                }\n            }\n\n            // Optionally write SVG output\n            if let Some(svg_path) = svg {\n                let mut interactive = matches!(svg_interactive.as_str(), \"on\");\n                if let Some(cfg_path) = config.as_ref() {\n                    if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                        if let Some(svg) = cfg.svg {\n                            if let Some(v) = svg.interactive { interactive = v; }\n                        }\n                    }\n                }\n                let svg_opts = SvgOptions { dot: dot_opts, interactive };\n                match SvgGenerator::new().generate_svg_with_options(\u0026graph, svg_opts) {\n                    Ok(content) =\u003e {\n                        if let Err(e) = fs::write(\u0026svg_path, content) {\n                            eprintln!(\"Failed to write SVG output {}: {}\", svg_path, e);\n                        }\n                    }\n                    Err(e) =\u003e eprintln!(\"Visualization error: {}\", e),\n                }\n            }\n\n            if let Some(save_path) = save {\n                if let Err(e) = KnowledgeGraph::save_json(\u0026graph, std::path::Path::new(\u0026save_path)) {\n                    eprintln!(\"Failed to save graph JSON {}: {}\", save_path, e);\n                }\n            }\n\n            println!(\"Build completed for path: {}\", path);\n        }\n        Commands::Query { query } =\u003e match query {\n            QueryCommands::ConnectedFiles { path, config, no_ignore, file, graph: graph_path, format } =\u003e {\n                let graph = match graph_path {\n                    Some(p) =\u003e match KnowledgeGraph::load_json(std::path::Path::new(\u0026p)) {\n                        Ok(g) =\u003e g,\n                        Err(e) =\u003e { eprintln!(\"Load graph failed: {}\", e); std::process::exit(1); }\n                    },\n                    None =\u003e {\n                        let res = match KnowledgeGraph::build_from_directory_opts(std::path::Path::new(\u0026path), no_ignore) {\n                            Ok(g) =\u003e g,\n                            Err(e) =\u003e { eprintln!(\"Build failed: {}\", e); std::process::exit(1); }\n                        };\n                        res\n                    }\n                };\n                let q = knowledge_rs::query::ConnectedFilesQuery::new(\u0026file);\n                let results = q.run(\u0026graph);\n                let fmt = if let Some(cfg_path) = config.as_ref() {\n                    if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                        cfg.query.and_then(|q| q.default_format).unwrap_or(format.clone())\n                    } else { format.clone() }\n                } else { format.clone() };\n                if fmt == \"json\" {\n                    let out: Vec\u003cString\u003e = results.into_iter().map(|p| p.display().to_string()).collect();\n                    match serde_json::to_string_pretty(\u0026out) {\n                        Ok(s) =\u003e println!(\"{}\", s),\n                        Err(e) =\u003e { eprintln!(\"JSON encode error: {}\", e); std::process::exit(1); }\n                    }\n                } else {\n                    let rows: Vec\u003cVec\u003cString\u003e\u003e = results\n                        .into_iter()\n                        .enumerate()\n                        .map(|(i,p)| vec![format!(\"{}\", i+1), p.display().to_string()])\n                        .collect();\n                    let table = knowledge_rs::utils::table::render(\u0026[\"#\", \"Path\"], \u0026rows);\n                    println!(\"{}\", table);\n                }\n            }\n            QueryCommands::FunctionUsage { path, config, no_ignore, function, direction, graph: graph_path, format } =\u003e {\n                let graph = match graph_path {\n                    Some(p) =\u003e match KnowledgeGraph::load_json(std::path::Path::new(\u0026p)) {\n                        Ok(g) =\u003e g,\n                        Err(e) =\u003e { eprintln!(\"Load graph failed: {}\", e); std::process::exit(1); }\n                    },\n                    None =\u003e {\n                        if no_ignore { std::env::set_var(\"KNOWLEDGE_RS_NO_IGNORE\", \"1\"); }\n                        let res = match KnowledgeGraph::build_from_directory(std::path::Path::new(\u0026path)) {\n                            Ok(g) =\u003e g,\n                            Err(e) =\u003e { eprintln!(\"Build failed: {}\", e); std::process::exit(1); }\n                        };\n                        if no_ignore { std::env::remove_var(\"KNOWLEDGE_RS_NO_IGNORE\"); }\n                        res\n                    }\n                };\n                let dir = match direction.as_str() {\n                    \"callees\" =\u003e knowledge_rs::query::UsageDirection::Callees,\n                    _ =\u003e knowledge_rs::query::UsageDirection::Callers,\n                };\n                let q = knowledge_rs::query::FunctionUsageQuery { function, direction: dir };\n                let results = q.run(\u0026graph);\n                let fmt = if let Some(cfg_path) = config.as_ref() {\n                    if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                        cfg.query.and_then(|q| q.default_format).unwrap_or(format.clone())\n                    } else { format.clone() }\n                } else { format.clone() };\n                if fmt == \"json\" {\n                    let out: Vec\u003cString\u003e = results.into_iter().map(|p| p.display().to_string()).collect();\n                    match serde_json::to_string_pretty(\u0026out) {\n                        Ok(s) =\u003e println!(\"{}\", s),\n                        Err(e) =\u003e { eprintln!(\"JSON encode error: {}\", e); std::process::exit(1); }\n                    }\n                } else {\n                    for p in results { println!(\"{}\", p.display()); }\n                }\n            }\n            QueryCommands::Cycles { path, config, no_ignore, graph: graph_path, format } =\u003e {\n                let graph = match graph_path {\n                    Some(p) =\u003e match KnowledgeGraph::load_json(std::path::Path::new(\u0026p)) {\n                        Ok(g) =\u003e g,\n                        Err(e) =\u003e { eprintln!(\"Load graph failed: {}\", e); std::process::exit(1); }\n                    },\n                    None =\u003e {\n                        if no_ignore { std::env::set_var(\"KNOWLEDGE_RS_NO_IGNORE\", \"1\"); }\n                        let res = match KnowledgeGraph::build_from_directory(std::path::Path::new(\u0026path)) {\n                            Ok(g) =\u003e g,\n                            Err(e) =\u003e { eprintln!(\"Build failed: {}\", e); std::process::exit(1); }\n                        };\n                        if no_ignore { std::env::remove_var(\"KNOWLEDGE_RS_NO_IGNORE\"); }\n                        res\n                    }\n                };\n                let q = knowledge_rs::query::CycleDetectionQuery::new();\n                let cycles = q.run(\u0026graph);\n                let fmt = if let Some(cfg_path) = config.as_ref() {\n                    if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                        cfg.query.and_then(|q| q.default_format).unwrap_or(format.clone())\n                    } else { format.clone() }\n                } else { format.clone() };\n                if fmt == \"json\" {\n                    let out: Vec\u003cVec\u003cString\u003e\u003e = cycles\n                        .into_iter()\n                        .map(|cyc| cyc.into_iter().map(|p| p.display().to_string()).collect())\n                        .collect();\n                    match serde_json::to_string_pretty(\u0026out) {\n                        Ok(s) =\u003e println!(\"{}\", s),\n                        Err(e) =\u003e { eprintln!(\"JSON encode error: {}\", e); std::process::exit(1); }\n                    }\n                } else {\n                    for cyc in cycles {\n                        let parts: Vec\u003cString\u003e = cyc.iter().map(|p| p.display().to_string()).collect();\n                        println!(\"{}\", parts.join(\" -\u003e \"));\n                    }\n                }\n            }\n            QueryCommands::Path { path, config, no_ignore, from, to, graph: graph_path, format } =\u003e {\n                let graph = match graph_path {\n                    Some(p) =\u003e match KnowledgeGraph::load_json(std::path::Path::new(\u0026p)) {\n                        Ok(g) =\u003e g,\n                        Err(e) =\u003e { eprintln!(\"Load graph failed: {}\", e); std::process::exit(1); }\n                    },\n                    None =\u003e {\n                        if no_ignore { std::env::set_var(\"KNOWLEDGE_RS_NO_IGNORE\", \"1\"); }\n                        let res = match KnowledgeGraph::build_from_directory(std::path::Path::new(\u0026path)) {\n                            Ok(g) =\u003e g,\n                            Err(e) =\u003e { eprintln!(\"Build failed: {}\", e); std::process::exit(1); }\n                        };\n                        if no_ignore { std::env::remove_var(\"KNOWLEDGE_RS_NO_IGNORE\"); }\n                        res\n                    }\n                };\n                let q = knowledge_rs::query::ShortestPathQuery::new(\u0026from, \u0026to);\n                let results = q.run(\u0026graph);\n                let fmt = if let Some(cfg_path) = config.as_ref() {\n                    if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                        cfg.query.and_then(|q| q.default_format).unwrap_or(format.clone())\n                    } else { format.clone() }\n                } else { format.clone() };\n                if fmt == \"json\" {\n                    let out: Vec\u003cString\u003e = results.into_iter().map(|p| p.display().to_string()).collect();\n                    match serde_json::to_string_pretty(\u0026out) {\n                        Ok(s) =\u003e println!(\"{}\", s),\n                        Err(e) =\u003e { eprintln!(\"JSON encode error: {}\", e); std::process::exit(1); }\n                    }\n                } else {\n                    if results.is_empty() {\n                        println!(\"\u003cno path\u003e\");\n                    } else {\n                        let rows: Vec\u003cVec\u003cString\u003e\u003e = results\n                            .into_iter()\n                            .enumerate()\n                            .map(|(i,p)| vec![format!(\"{}\", i+1), p.display().to_string()])\n                            .collect();\n                        let table = knowledge_rs::utils::table::render(\u0026[\"Step\", \"Path\"], \u0026rows);\n                        println!(\"{}\", table);\n                    }\n                }\n            }\n            QueryCommands::Hubs { path, config, no_ignore, graph: graph_path, metric, top, format } =\u003e {\n                use knowledge_rs::query::{HubsQuery, CentralityMetric};\n                let graph = match graph_path {\n                    Some(p) =\u003e match KnowledgeGraph::load_json(std::path::Path::new(\u0026p)) {\n                        Ok(g) =\u003e g,\n                        Err(e) =\u003e { eprintln!(\"Load graph failed: {}\", e); std::process::exit(1); }\n                    },\n                    None =\u003e {\n                        if no_ignore { std::env::set_var(\"KNOWLEDGE_RS_NO_IGNORE\", \"1\"); }\n                        let res = match KnowledgeGraph::build_from_directory(std::path::Path::new(\u0026path)) {\n                            Ok(g) =\u003e g,\n                            Err(e) =\u003e { eprintln!(\"Build failed: {}\", e); std::process::exit(1); }\n                        };\n                        if no_ignore { std::env::remove_var(\"KNOWLEDGE_RS_NO_IGNORE\"); }\n                        res\n                    }\n                };\n                let m = match metric.as_str() {\n                    \"in\" =\u003e CentralityMetric::In,\n                    \"out\" =\u003e CentralityMetric::Out,\n                    _ =\u003e CentralityMetric::Total,\n                };\n                let q = HubsQuery::new(m, top);\n                let rows = q.run(\u0026graph);\n                let fmt = if let Some(cfg_path) = config.as_ref() {\n                    if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                        cfg.query.and_then(|q| q.default_format).unwrap_or(format.clone())\n                    } else { format.clone() }\n                } else { format.clone() };\n                if fmt == \"json\" {\n                    #[derive(serde::Serialize)]\n                    struct HubRow { path: String, indegree: usize, outdegree: usize }\n                    let out: Vec\u003cHubRow\u003e = rows.into_iter().map(|(p,i,o)| HubRow { path: p.display().to_string(), indegree: i, outdegree: o }).collect();\n                    match serde_json::to_string_pretty(\u0026out) {\n                        Ok(s) =\u003e println!(\"{}\", s),\n                        Err(e) =\u003e { eprintln!(\"JSON encode error: {}\", e); std::process::exit(1); }\n                    }\n                } else {\n                    let body: Vec\u003cVec\u003cString\u003e\u003e = rows\n                        .into_iter()\n                        .map(|(p,i,o)| vec![p.display().to_string(), i.to_string(), o.to_string(), (i+o).to_string()])\n                        .collect();\n                    let table = knowledge_rs::utils::table::render(\u0026[\"Path\", \"In\", \"Out\", \"Total\"], \u0026body);\n                    println!(\"{}\", table);\n                }\n            }\n            QueryCommands::ModuleCentrality { path, config, no_ignore, graph: graph_path, metric, top, format } =\u003e {\n                use knowledge_rs::query::{ModuleCentralityQuery, CentralityMetric, Query};\n                let graph = match graph_path {\n                    Some(p) =\u003e match KnowledgeGraph::load_json(std::path::Path::new(\u0026p)) {\n                        Ok(g) =\u003e g,\n                        Err(e) =\u003e { eprintln!(\"Load graph failed: {}\", e); std::process::exit(1); }\n                    },\n                    None =\u003e {\n                        if no_ignore { std::env::set_var(\"KNOWLEDGE_RS_NO_IGNORE\", \"1\"); }\n                        let res = match KnowledgeGraph::build_from_directory(std::path::Path::new(\u0026path)) {\n                            Ok(g) =\u003e g,\n                            Err(e) =\u003e { eprintln!(\"Build failed: {}\", e); std::process::exit(1); }\n                        };\n                        if no_ignore { std::env::remove_var(\"KNOWLEDGE_RS_NO_IGNORE\"); }\n                        res\n                    }\n                };\n                let m = match metric.as_str() {\n                    \"in\" =\u003e CentralityMetric::In,\n                    \"out\" =\u003e CentralityMetric::Out,\n                    _ =\u003e CentralityMetric::Total,\n                };\n                let q = ModuleCentralityQuery::new(m, top);\n                let rows = q.run(\u0026graph);\n                let fmt = if let Some(cfg_path) = config.as_ref() {\n                    if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                        cfg.query.and_then(|q| q.default_format).unwrap_or(format.clone())\n                    } else { format.clone() }\n                } else { format.clone() };\n                if fmt == \"json\" {\n                    #[derive(serde::Serialize)]\n                    struct Row { module: String, indegree: usize, outdegree: usize }\n                    let out: Vec\u003cRow\u003e = rows.into_iter().map(|(p,i,o)| Row { module: p.display().to_string(), indegree: i, outdegree: o }).collect();\n                    match serde_json::to_string_pretty(\u0026out) {\n                        Ok(s) =\u003e println!(\"{}\", s),\n                        Err(e) =\u003e { eprintln!(\"JSON encode error: {}\", e); std::process::exit(1); }\n                    }\n                } else {\n                    let body: Vec\u003cVec\u003cString\u003e\u003e = rows\n                        .into_iter()\n                        .map(|(p,i,o)| vec![p.display().to_string(), i.to_string(), o.to_string(), (i+o).to_string()])\n                        .collect();\n                    let table = knowledge_rs::utils::table::render(\u0026[\"Module\", \"In\", \"Out\", \"Total\"], \u0026body);\n                    println!(\"{}\", table);\n                }\n            }\n            QueryCommands::TraitImpls { path, config, no_ignore, r#trait, graph: graph_path, format } =\u003e {\n                use knowledge_rs::query::{TraitImplsQuery, Query};\n                let graph = match graph_path {\n                    Some(p) =\u003e match KnowledgeGraph::load_json(std::path::Path::new(\u0026p)) {\n                        Ok(g) =\u003e g,\n                        Err(e) =\u003e { eprintln!(\"Load graph failed: {}\", e); std::process::exit(1); }\n                    },\n                    None =\u003e {\n                        if no_ignore { std::env::set_var(\"KNOWLEDGE_RS_NO_IGNORE\", \"1\"); }\n                        let res = match KnowledgeGraph::build_from_directory(std::path::Path::new(\u0026path)) {\n                            Ok(g) =\u003e g,\n                            Err(e) =\u003e { eprintln!(\"Build failed: {}\", e); std::process::exit(1); }\n                        };\n                        if no_ignore { std::env::remove_var(\"KNOWLEDGE_RS_NO_IGNORE\"); }\n                        res\n                    }\n                };\n                let q = TraitImplsQuery::new(\u0026r#trait);\n                let rows = q.run(\u0026graph);\n                let fmt = if let Some(cfg_path) = config.as_ref() {\n                    if let Some(cfg) = knowledge_rs::utils::config::load_config_at(std::path::Path::new(cfg_path)) {\n                        cfg.query.and_then(|q| q.default_format).unwrap_or(format.clone())\n                    } else { format.clone() }\n                } else { format.clone() };\n                if fmt == \"json\" {\n                    #[derive(serde::Serialize)]\n                    struct Row { path: String, r#type: String }\n                    let out: Vec\u003cRow\u003e = rows.into_iter().map(|(p,t)| Row { path: p.display().to_string(), r#type: t }).collect();\n                    match serde_json::to_string_pretty(\u0026out) {\n                        Ok(s) =\u003e println!(\"{}\", s),\n                        Err(e) =\u003e { eprintln!(\"JSON encode error: {}\", e); std::process::exit(1); }\n                    }\n                } else {\n                    if rows.is_empty() {\n                        println!(\"\u003cno implementations found\u003e\");\n                    } else {\n                        let body: Vec\u003cVec\u003cString\u003e\u003e = rows\n                            .into_iter()\n                            .map(|(p,t)| vec![p.display().to_string(), t])\n                            .collect();\n                        let table = knowledge_rs::utils::table::render(\u0026[\"Path\", \"Type\"], \u0026body);\n                        println!(\"{}\", table);\n                    }\n                }\n            }\n        },\n    }\n}\n","traces":[{"line":1,"address":[5737808,5737840,5739959,5746181],"length":1,"stats":{"Line":1}},{"line":8,"address":[5737922],"length":1,"stats":{"Line":0}},{"line":10,"address":[5738104],"length":1,"stats":{"Line":0}},{"line":11,"address":[5738211],"length":1,"stats":{"Line":0}},{"line":13,"address":[5738957,5738932],"length":1,"stats":{"Line":0}},{"line":14,"address":[5738949],"length":1,"stats":{"Line":0}},{"line":15,"address":[5738943,5738967],"length":1,"stats":{"Line":0}},{"line":16,"address":[5738969],"length":1,"stats":{"Line":0}},{"line":18,"address":[5738959],"length":1,"stats":{"Line":0}},{"line":21,"address":[5738977,5739094],"length":1,"stats":{"Line":0}},{"line":23,"address":[5739110],"length":1,"stats":{"Line":0}},{"line":24,"address":[5739140,5739209],"length":1,"stats":{"Line":0}},{"line":28,"address":[5739174,5739211],"length":1,"stats":{"Line":0}},{"line":29,"address":[5739338],"length":1,"stats":{"Line":0}},{"line":30,"address":[5739248],"length":1,"stats":{"Line":0}},{"line":31,"address":[5745860,5739328],"length":1,"stats":{"Line":0}},{"line":32,"address":[5745929],"length":1,"stats":{"Line":0}},{"line":37,"address":[5739390],"length":1,"stats":{"Line":0}},{"line":38,"address":[5739467],"length":1,"stats":{"Line":0}},{"line":40,"address":[5739630],"length":1,"stats":{"Line":0}},{"line":41,"address":[5739825,5739716],"length":1,"stats":{"Line":0}},{"line":46,"address":[5740025,5739502],"length":1,"stats":{"Line":0}},{"line":47,"address":[5740075],"length":1,"stats":{"Line":0}},{"line":48,"address":[5740164],"length":1,"stats":{"Line":0}},{"line":49,"address":[5740268],"length":1,"stats":{"Line":0}},{"line":50,"address":[5740372],"length":1,"stats":{"Line":0}},{"line":51,"address":[5740563],"length":1,"stats":{"Line":0}},{"line":53,"address":[5740644],"length":1,"stats":{"Line":0}},{"line":54,"address":[5740734,5740933],"length":1,"stats":{"Line":0}},{"line":55,"address":[5742303,5741019],"length":1,"stats":{"Line":0}},{"line":56,"address":[5741153,5741102],"length":1,"stats":{"Line":0}},{"line":57,"address":[5741181],"length":1,"stats":{"Line":0}},{"line":58,"address":[5741236,5741380],"length":1,"stats":{"Line":0}},{"line":59,"address":[5741554,5741334,5741665],"length":1,"stats":{"Line":0}},{"line":60,"address":[5741883,5741623,5741776],"length":1,"stats":{"Line":0}},{"line":61,"address":[5742259,5741847],"length":1,"stats":{"Line":0}},{"line":65,"address":[5740764],"length":1,"stats":{"Line":0}},{"line":68,"address":[5740871,5742374],"length":1,"stats":{"Line":0}},{"line":69,"address":[5742414,5742515],"length":1,"stats":{"Line":0}},{"line":70,"address":[5742749],"length":1,"stats":{"Line":0}},{"line":71,"address":[5742797],"length":1,"stats":{"Line":0}},{"line":72,"address":[5742992,5742883],"length":1,"stats":{"Line":0}},{"line":75,"address":[5743126,5742659],"length":1,"stats":{"Line":0}},{"line":80,"address":[5743261,5742425],"length":1,"stats":{"Line":0}},{"line":81,"address":[5743309,5743438],"length":1,"stats":{"Line":0}},{"line":82,"address":[5743480],"length":1,"stats":{"Line":0}},{"line":83,"address":[5743570,5743671],"length":1,"stats":{"Line":0}},{"line":84,"address":[5743757],"length":1,"stats":{"Line":0}},{"line":85,"address":[5743847,5743798],"length":1,"stats":{"Line":0}},{"line":89,"address":[5743597],"length":1,"stats":{"Line":0}},{"line":90,"address":[5743877,5743641],"length":1,"stats":{"Line":0}},{"line":91,"address":[5744123],"length":1,"stats":{"Line":0}},{"line":92,"address":[5744171],"length":1,"stats":{"Line":0}},{"line":93,"address":[5744257,5744366],"length":1,"stats":{"Line":0}},{"line":96,"address":[5744033,5744500],"length":1,"stats":{"Line":0}},{"line":100,"address":[5744635,5743332],"length":1,"stats":{"Line":0}},{"line":101,"address":[5744800,5744675],"length":1,"stats":{"Line":0}},{"line":102,"address":[5744927,5745052],"length":1,"stats":{"Line":0}},{"line":106,"address":[5744710,5745166],"length":1,"stats":{"Line":0}},{"line":108,"address":[5738141],"length":1,"stats":{"Line":0}},{"line":109,"address":[5746196],"length":1,"stats":{"Line":0}},{"line":110,"address":[5746459],"length":1,"stats":{"Line":0}},{"line":111,"address":[5748463,5749054],"length":1,"stats":{"Line":0}},{"line":112,"address":[5749252],"length":1,"stats":{"Line":0}},{"line":113,"address":[5749110,5751583],"length":1,"stats":{"Line":0}},{"line":116,"address":[5748533,5748635],"length":1,"stats":{"Line":0}},{"line":117,"address":[5748784],"length":1,"stats":{"Line":0}},{"line":118,"address":[5748862,5748697],"length":1,"stats":{"Line":0}},{"line":120,"address":[5748810],"length":1,"stats":{"Line":0}},{"line":123,"address":[5748852],"length":1,"stats":{"Line":0}},{"line":124,"address":[5749430,5749354],"length":1,"stats":{"Line":0}},{"line":125,"address":[5749438,5749511],"length":1,"stats":{"Line":0}},{"line":126,"address":[5749646,5749566],"length":1,"stats":{"Line":0}},{"line":127,"address":[5750110,5749910,5749732,5749868],"length":1,"stats":{"Line":0}},{"line":128,"address":[5750018,5749787,5749999,5750132],"length":1,"stats":{"Line":0}},{"line":129,"address":[5749593,5750156],"length":1,"stats":{"Line":0}},{"line":130,"address":[5750081,5750209],"length":1,"stats":{"Line":0}},{"line":131,"address":[5750282,5750751],"length":1,"stats":{"Line":0}},{"line":132,"address":[5750797,5750848],"length":1,"stats":{"Line":0}},{"line":133,"address":[5750927],"length":1,"stats":{"Line":0}},{"line":134,"address":[5751429,5750885],"length":1,"stats":{"Line":0}},{"line":137,"address":[5750215],"length":1,"stats":{"Line":0}},{"line":140,"address":[5687257,5687232],"length":1,"stats":{"Line":0}},{"line":142,"address":[5750508,5750429],"length":1,"stats":{"Line":0}},{"line":143,"address":[5750539,5750610],"length":1,"stats":{"Line":0}},{"line":146,"address":[5746505],"length":1,"stats":{"Line":0}},{"line":147,"address":[5746824],"length":1,"stats":{"Line":0}},{"line":148,"address":[5752454,5751715],"length":1,"stats":{"Line":0}},{"line":149,"address":[5752652],"length":1,"stats":{"Line":0}},{"line":150,"address":[5752510,5755279],"length":1,"stats":{"Line":0}},{"line":153,"address":[5751792,5751833,5751908],"length":1,"stats":{"Line":0}},{"line":154,"address":[5751926,5751798],"length":1,"stats":{"Line":0}},{"line":155,"address":[5752072],"length":1,"stats":{"Line":0}},{"line":156,"address":[5751982,5752262],"length":1,"stats":{"Line":0}},{"line":158,"address":[5752131,5752226,5752163],"length":1,"stats":{"Line":0}},{"line":159,"address":[5752135],"length":1,"stats":{"Line":0}},{"line":162,"address":[5752236],"length":1,"stats":{"Line":0}},{"line":163,"address":[5752819,5752770],"length":1,"stats":{"Line":0}},{"line":164,"address":[5752809],"length":1,"stats":{"Line":0}},{"line":166,"address":[5752827],"length":1,"stats":{"Line":0}},{"line":167,"address":[5752992,5752913],"length":1,"stats":{"Line":0}},{"line":168,"address":[5753000,5753073],"length":1,"stats":{"Line":0}},{"line":169,"address":[5753208,5753128],"length":1,"stats":{"Line":0}},{"line":170,"address":[5691011,5691008],"length":1,"stats":{"Line":0}},{"line":171,"address":[5753694,5753561,5753580,5753349],"length":1,"stats":{"Line":0}},{"line":172,"address":[5753155,5753718],"length":1,"stats":{"Line":0}},{"line":173,"address":[5753643,5753771],"length":1,"stats":{"Line":0}},{"line":174,"address":[5753844,5754439],"length":1,"stats":{"Line":0}},{"line":175,"address":[5754536,5754485],"length":1,"stats":{"Line":0}},{"line":176,"address":[5754615],"length":1,"stats":{"Line":0}},{"line":177,"address":[5754573,5755125],"length":1,"stats":{"Line":0}},{"line":180,"address":[5753914,5753777,5754190],"length":1,"stats":{"Line":0}},{"line":183,"address":[5746870],"length":1,"stats":{"Line":0}},{"line":184,"address":[5747085],"length":1,"stats":{"Line":0}},{"line":185,"address":[5756171,5755452],"length":1,"stats":{"Line":0}},{"line":186,"address":[5756369],"length":1,"stats":{"Line":0}},{"line":187,"address":[5758932,5756227],"length":1,"stats":{"Line":0}},{"line":190,"address":[5755529,5755645,5755570],"length":1,"stats":{"Line":0}},{"line":191,"address":[5755663,5755535],"length":1,"stats":{"Line":0}},{"line":192,"address":[5755809],"length":1,"stats":{"Line":0}},{"line":193,"address":[5755979,5755719],"length":1,"stats":{"Line":0}},{"line":195,"address":[5755868,5755963,5755900],"length":1,"stats":{"Line":0}},{"line":196,"address":[5755872],"length":1,"stats":{"Line":0}},{"line":199,"address":[5755965],"length":1,"stats":{"Line":0}},{"line":200,"address":[5756471],"length":1,"stats":{"Line":0}},{"line":201,"address":[5756514,5756590],"length":1,"stats":{"Line":0}},{"line":202,"address":[5756645,5756725],"length":1,"stats":{"Line":0}},{"line":203,"address":[5689136,5689139],"length":1,"stats":{"Line":0}},{"line":204,"address":[5757078,5756866,5757211,5757097],"length":1,"stats":{"Line":0}},{"line":205,"address":[5756672,5757235],"length":1,"stats":{"Line":0}},{"line":206,"address":[5757288,5757160],"length":1,"stats":{"Line":0}},{"line":207,"address":[5757357],"length":1,"stats":{"Line":0}},{"line":209,"address":[5684416,5689536,5689568,5684448],"length":1,"stats":{"Line":0}},{"line":211,"address":[5758284,5758237],"length":1,"stats":{"Line":0}},{"line":212,"address":[5758363],"length":1,"stats":{"Line":0}},{"line":213,"address":[5758778,5758321],"length":1,"stats":{"Line":0}},{"line":216,"address":[5757423,5757550,5757294],"length":1,"stats":{"Line":0}},{"line":217,"address":[5757619,5757751],"length":1,"stats":{"Line":0}},{"line":218,"address":[5757943,5757848],"length":1,"stats":{"Line":0}},{"line":222,"address":[5747131],"length":1,"stats":{"Line":0}},{"line":223,"address":[5747442],"length":1,"stats":{"Line":0}},{"line":224,"address":[5759803,5759064],"length":1,"stats":{"Line":0}},{"line":225,"address":[5760001],"length":1,"stats":{"Line":0}},{"line":226,"address":[5762506,5759859],"length":1,"stats":{"Line":0}},{"line":229,"address":[5759182,5759257,5759141],"length":1,"stats":{"Line":0}},{"line":230,"address":[5759275,5759147],"length":1,"stats":{"Line":0}},{"line":231,"address":[5759421],"length":1,"stats":{"Line":0}},{"line":232,"address":[5759331,5759611],"length":1,"stats":{"Line":0}},{"line":234,"address":[5759575,5759480,5759512],"length":1,"stats":{"Line":0}},{"line":235,"address":[5759484],"length":1,"stats":{"Line":0}},{"line":238,"address":[5759601],"length":1,"stats":{"Line":0}},{"line":239,"address":[5760179,5760103],"length":1,"stats":{"Line":0}},{"line":240,"address":[5760187,5760260],"length":1,"stats":{"Line":0}},{"line":241,"address":[5760315,5760395],"length":1,"stats":{"Line":0}},{"line":242,"address":[5760617,5760659,5760859,5760481],"length":1,"stats":{"Line":0}},{"line":243,"address":[5760536,5760748,5760767,5760881],"length":1,"stats":{"Line":0}},{"line":244,"address":[5760905,5760342],"length":1,"stats":{"Line":0}},{"line":245,"address":[5760958,5760830],"length":1,"stats":{"Line":0}},{"line":246,"address":[5691072,5691040],"length":1,"stats":{"Line":0}},{"line":247,"address":[5761682,5761631],"length":1,"stats":{"Line":0}},{"line":248,"address":[5761761],"length":1,"stats":{"Line":0}},{"line":249,"address":[5761719,5762352],"length":1,"stats":{"Line":0}},{"line":252,"address":[5761063,5760972],"length":1,"stats":{"Line":0}},{"line":253,"address":[5761136,5761548],"length":1,"stats":{"Line":0}},{"line":255,"address":[5761069],"length":1,"stats":{"Line":0}},{"line":258,"address":[5761204],"length":1,"stats":{"Line":0}},{"line":260,"address":[5761321,5761242],"length":1,"stats":{"Line":0}},{"line":261,"address":[5761423,5761352],"length":1,"stats":{"Line":0}},{"line":265,"address":[5747488],"length":1,"stats":{"Line":0}},{"line":267,"address":[5747775],"length":1,"stats":{"Line":0}},{"line":268,"address":[5763377,5762638],"length":1,"stats":{"Line":0}},{"line":269,"address":[5763575],"length":1,"stats":{"Line":0}},{"line":270,"address":[5763433,5766038],"length":1,"stats":{"Line":0}},{"line":273,"address":[5762756,5762831,5762715],"length":1,"stats":{"Line":0}},{"line":274,"address":[5762849,5762721],"length":1,"stats":{"Line":0}},{"line":275,"address":[5762995],"length":1,"stats":{"Line":0}},{"line":276,"address":[5763185,5762905],"length":1,"stats":{"Line":0}},{"line":278,"address":[5763054,5763149,5763086],"length":1,"stats":{"Line":0}},{"line":279,"address":[5763058],"length":1,"stats":{"Line":0}},{"line":282,"address":[5763159,5763693],"length":1,"stats":{"Line":0}},{"line":283,"address":[5763796,5763715],"length":1,"stats":{"Line":0}},{"line":284,"address":[5763813,5763770,5763829],"length":1,"stats":{"Line":0}},{"line":285,"address":[5763819],"length":1,"stats":{"Line":0}},{"line":287,"address":[5763845],"length":1,"stats":{"Line":0}},{"line":288,"address":[5763909],"length":1,"stats":{"Line":0}},{"line":289,"address":[5763952,5764028],"length":1,"stats":{"Line":0}},{"line":290,"address":[5764083,5764163],"length":1,"stats":{"Line":0}},{"line":291,"address":[5764627,5764249,5764385,5764427],"length":1,"stats":{"Line":0}},{"line":292,"address":[5764535,5764516,5764304,5764649],"length":1,"stats":{"Line":0}},{"line":293,"address":[5764673,5764110],"length":1,"stats":{"Line":0}},{"line":294,"address":[5764726,5764598],"length":1,"stats":{"Line":0}},{"line":297,"address":[5764795,5765237],"length":1,"stats":{"Line":0}},{"line":298,"address":[5765330,5765283],"length":1,"stats":{"Line":0}},{"line":299,"address":[5765409],"length":1,"stats":{"Line":0}},{"line":300,"address":[5765367,5765884],"length":1,"stats":{"Line":0}},{"line":303,"address":[5764732],"length":1,"stats":{"Line":0}},{"line":305,"address":[5683024,5683049],"length":1,"stats":{"Line":0}},{"line":307,"address":[5764915,5764994],"length":1,"stats":{"Line":0}},{"line":308,"address":[5765096,5765025],"length":1,"stats":{"Line":0}},{"line":311,"address":[5747821],"length":1,"stats":{"Line":0}},{"line":313,"address":[5748108],"length":1,"stats":{"Line":0}},{"line":314,"address":[5766909,5766170],"length":1,"stats":{"Line":0}},{"line":315,"address":[5767107],"length":1,"stats":{"Line":0}},{"line":316,"address":[5766965,5769570],"length":1,"stats":{"Line":0}},{"line":319,"address":[5766247,5766288,5766363],"length":1,"stats":{"Line":0}},{"line":320,"address":[5766381,5766253],"length":1,"stats":{"Line":0}},{"line":321,"address":[5766527],"length":1,"stats":{"Line":0}},{"line":322,"address":[5766717,5766437],"length":1,"stats":{"Line":0}},{"line":324,"address":[5766681,5766586,5766618],"length":1,"stats":{"Line":0}},{"line":325,"address":[5766590],"length":1,"stats":{"Line":0}},{"line":328,"address":[5767225,5766691],"length":1,"stats":{"Line":0}},{"line":329,"address":[5767328,5767247],"length":1,"stats":{"Line":0}},{"line":330,"address":[5767361,5767302,5767345],"length":1,"stats":{"Line":0}},{"line":331,"address":[5767351],"length":1,"stats":{"Line":0}},{"line":333,"address":[5767377],"length":1,"stats":{"Line":0}},{"line":334,"address":[5767441],"length":1,"stats":{"Line":0}},{"line":335,"address":[5767560,5767484],"length":1,"stats":{"Line":0}},{"line":336,"address":[5767615,5767695],"length":1,"stats":{"Line":0}},{"line":337,"address":[5682896,5682899],"length":1,"stats":{"Line":0}},{"line":338,"address":[5768067,5767836,5768048,5768181],"length":1,"stats":{"Line":0}},{"line":339,"address":[5768205,5767642],"length":1,"stats":{"Line":0}},{"line":340,"address":[5768258,5768130],"length":1,"stats":{"Line":0}},{"line":343,"address":[5689728,5689753],"length":1,"stats":{"Line":0}},{"line":344,"address":[5768862,5768815],"length":1,"stats":{"Line":0}},{"line":345,"address":[5768941],"length":1,"stats":{"Line":0}},{"line":346,"address":[5769416,5768899],"length":1,"stats":{"Line":0}},{"line":349,"address":[5768264],"length":1,"stats":{"Line":0}},{"line":351,"address":[5768409],"length":1,"stats":{"Line":0}},{"line":353,"address":[5768447,5768526],"length":1,"stats":{"Line":0}},{"line":354,"address":[5768557,5768628],"length":1,"stats":{"Line":0}},{"line":357,"address":[5748154],"length":1,"stats":{"Line":0}},{"line":359,"address":[5748417],"length":1,"stats":{"Line":0}},{"line":360,"address":[5770411,5769702],"length":1,"stats":{"Line":0}},{"line":361,"address":[5770600],"length":1,"stats":{"Line":0}},{"line":362,"address":[5772977,5770467],"length":1,"stats":{"Line":0}},{"line":365,"address":[5769883,5769808,5769773],"length":1,"stats":{"Line":0}},{"line":366,"address":[5769895,5769779],"length":1,"stats":{"Line":0}},{"line":367,"address":[5770041],"length":1,"stats":{"Line":0}},{"line":368,"address":[5769951,5770225],"length":1,"stats":{"Line":0}},{"line":370,"address":[5770132,5770100,5770195],"length":1,"stats":{"Line":0}},{"line":371,"address":[5770104],"length":1,"stats":{"Line":0}},{"line":374,"address":[5770205,5770703],"length":1,"stats":{"Line":0}},{"line":375,"address":[5770722,5770798],"length":1,"stats":{"Line":0}},{"line":376,"address":[5770806,5770873],"length":1,"stats":{"Line":0}},{"line":377,"address":[5770928,5770996],"length":1,"stats":{"Line":0}},{"line":378,"address":[5690979,5690976],"length":1,"stats":{"Line":0}},{"line":379,"address":[5771368,5771479,5771137,5771349],"length":1,"stats":{"Line":0}},{"line":380,"address":[5770949,5771503],"length":1,"stats":{"Line":0}},{"line":381,"address":[5771431,5771553],"length":1,"stats":{"Line":0}},{"line":384,"address":[5689193,5689168],"length":1,"stats":{"Line":0}},{"line":385,"address":[5772221,5772174],"length":1,"stats":{"Line":0}},{"line":386,"address":[5772300],"length":1,"stats":{"Line":0}},{"line":387,"address":[5772258,5772823],"length":1,"stats":{"Line":0}},{"line":390,"address":[5771567,5771648],"length":1,"stats":{"Line":0}},{"line":391,"address":[5771717,5772091],"length":1,"stats":{"Line":0}},{"line":393,"address":[5771654],"length":1,"stats":{"Line":0}},{"line":395,"address":[5683849,5683824],"length":1,"stats":{"Line":0}},{"line":397,"address":[5771800,5771867],"length":1,"stats":{"Line":0}},{"line":398,"address":[5771898,5771966],"length":1,"stats":{"Line":0}}],"covered":1,"coverable":259},{"path":["/","home","dio","knowledge-rs","src","parser","mod.rs"],"content":"use crate::errors::ParseError;\nuse crate::graph::{FileMetrics, FileNode, Import, Item, ItemId, ItemType, Location, Visibility};\nuse regex::Regex;\nuse std::path::Path;\n\n#[derive(Debug, Default)]\npub struct RustParser {\n    patterns: RegexPatterns,\n}\n\n#[derive(Debug)]\npub struct RegexPatterns {\n    pub fn_sig: Regex,\n    pub struct_def: Regex,\n    pub enum_def: Regex,\n    pub vis_pub_in: Regex,\n    pub import_stmt: Regex,\n}\n\nimpl RegexPatterns {\n    pub fn compile() -\u003e Self {\n        // Simple, conservative regexes to avoid catastrophic backtracking\n        let fn_sig = Regex::new(r\"(?m)^\\s*(?P\u003cvis\u003epub(?:\\([^)]*\\))?\\s+)?(?:async\\s+)?(?:const\\s+)?fn\\s+(?P\u003cname\u003e[a-zA-Z_][a-zA-Z0-9_]*)\\s*\\(\").unwrap();\n        let struct_def = Regex::new(r\"(?m)^\\s*(?P\u003cvis\u003epub(?:\\([^)]*\\))?\\s+)?struct\\s+(?P\u003cname\u003e[A-Za-z_][A-Za-z0-9_]*)\").unwrap();\n        let enum_def = Regex::new(r\"(?m)^\\s*(?P\u003cvis\u003epub(?:\\([^)]*\\))?\\s+)?enum\\s+(?P\u003cname\u003e[A-Za-z_][A-Za-z0-9_]*)\").unwrap();\n        let vis_pub_in = Regex::new(r\"^pub\\((?P\u003csc\u003e[^)]+)\\)$\").unwrap();\n        let import_stmt = Regex::new(r\"(?m)^\\s*(?:pub\\s+)?use\\s+([^;{]+?)(?:\\s+as\\s+([A-Za-z_][A-Za-z0-9_]*))?\\s*;\\s*$\").unwrap();\n        Self { fn_sig, struct_def, enum_def, vis_pub_in, import_stmt }\n    }\n}\n\nimpl Default for RegexPatterns {\n    fn default() -\u003e Self { Self::compile() }\n}\n\nimpl RustParser {\n    pub fn new() -\u003e Self {\n        Self { patterns: RegexPatterns::compile() }\n    }\n\n    pub fn parse_file(\u0026self, content: \u0026str, path: \u0026Path) -\u003e Result\u003cFileNode, ParseError\u003e {\n        let items = self.extract_items(content, path);\n        let imports = self.extract_imports(content);\n        let metrics = FileMetrics { item_count: items.len(), import_count: imports.len() };\n        Ok(FileNode { path: path.to_path_buf(), items, imports, metrics })\n    }\n\n    fn extract_items(\u0026self, content: \u0026str, path: \u0026Path) -\u003e Vec\u003cItem\u003e {\n        let mut out = Vec::new();\n\n        for cap in self.patterns.fn_sig.captures_iter(content) {\n            let name = cap.name(\"name\").map(|m| m.as_str()).unwrap_or(\"\").to_string();\n            let vis = cap.name(\"vis\").map(|m| m.as_str().trim()).unwrap_or(\"\");\n            let visibility = parse_visibility(\u0026self.patterns.vis_pub_in, vis);\n            let line = line_number_for(content, cap.get(0).map(|m| m.start()).unwrap_or(0));\n            out.push(Item {\n                id: ItemId(format!(\"fn:{}:{}\", name, line)),\n                item_type: ItemType::Function { is_async: content[..cap.get(0).unwrap().end()].contains(\"async \"), is_const: content[..cap.get(0).unwrap().end()].contains(\"const \") },\n                name,\n                visibility,\n                location: Location { file: path.to_path_buf(), line_start: line, line_end: line },\n                attributes: vec![],\n            });\n        }\n\n        for cap in self.patterns.struct_def.captures_iter(content) {\n            let name = cap.name(\"name\").map(|m| m.as_str()).unwrap_or(\"\").to_string();\n            let vis = cap.name(\"vis\").map(|m| m.as_str().trim()).unwrap_or(\"\");\n            let visibility = parse_visibility(\u0026self.patterns.vis_pub_in, vis);\n            let line = line_number_for(content, cap.get(0).map(|m| m.start()).unwrap_or(0));\n            out.push(Item {\n                id: ItemId(format!(\"struct:{}:{}\", name, line)),\n                item_type: ItemType::Struct { is_tuple: false },\n                name,\n                visibility,\n                location: Location { file: path.to_path_buf(), line_start: line, line_end: line },\n                attributes: vec![],\n            });\n        }\n\n        for cap in self.patterns.enum_def.captures_iter(content) {\n            let name = cap.name(\"name\").map(|m| m.as_str()).unwrap_or(\"\").to_string();\n            let vis = cap.name(\"vis\").map(|m| m.as_str().trim()).unwrap_or(\"\");\n            let visibility = parse_visibility(\u0026self.patterns.vis_pub_in, vis);\n            let line = line_number_for(content, cap.get(0).map(|m| m.start()).unwrap_or(0));\n            out.push(Item {\n                id: ItemId(format!(\"enum:{}:{}\", name, line)),\n                item_type: ItemType::Enum { variant_count: 0 },\n                name,\n                visibility,\n                location: Location { file: path.to_path_buf(), line_start: line, line_end: line },\n                attributes: vec![],\n            });\n        }\n\n        out\n    }\n\n    fn extract_imports(\u0026self, content: \u0026str) -\u003e Vec\u003cImport\u003e {\n        let mut out = Vec::new();\n        for cap in self.patterns.import_stmt.captures_iter(content) {\n            let path = cap.get(1).map(|m| m.as_str().trim()).unwrap_or(\"\").to_string();\n            let alias = cap.get(2).map(|m| m.as_str().to_string());\n            out.push(Import { path, alias });\n        }\n        out\n    }\n}\n\nfn parse_visibility(vis_pub_in: \u0026Regex, vis: \u0026str) -\u003e Visibility {\n    let v = vis.trim();\n    if v.is_empty() { return Visibility::Private; }\n    if v == \"pub\" { return Visibility::Public; }\n    if v == \"pub(crate)\" { return Visibility::PubCrate; }\n    if v == \"pub(super)\" { return Visibility::PubSuper; }\n    if let Some(c) = vis_pub_in.captures(v) {\n        return Visibility::PubIn(c.name(\"sc\").map(|m| m.as_str().to_string()).unwrap_or_default());\n    }\n    Visibility::Private\n}\n\nfn line_number_for(content: \u0026str, byte_idx: usize) -\u003e usize {\n    // 1-based line number\n    content[..byte_idx].bytes().filter(|\u0026b| b == b'\\n').count() + 1\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_extract_fn_struct_enum_and_visibility() {\n        let src = r#\"\n        pub fn top() {}\n        fn hidden() {}\n        pub(crate) struct S;\n        pub(super) enum E { A, B }\n        \"#;\n        let parser = RustParser::new();\n        let file = std::path::Path::new(\"/tmp/test.rs\");\n        let node = parser.parse_file(src, file).expect(\"parse\");\n        // items: 2 fn + 1 struct + 1 enum\n        assert_eq!(node.items.len(), 4);\n        // check visibility parsing\n        let mut names: Vec\u003c(String, Visibility)\u003e = node.items.iter().map(|i| (i.name.clone(), i.visibility.clone())).collect();\n        names.sort_by(|a,b| a.0.cmp(\u0026b.0));\n        assert!(names.iter().any(|(n,v)| n == \"top\" \u0026\u0026 matches!(v, Visibility::Public)));\n        assert!(names.iter().any(|(n,v)| n == \"hidden\" \u0026\u0026 matches!(v, Visibility::Private)));\n        assert!(names.iter().any(|(n,v)| n == \"S\" \u0026\u0026 matches!(v, Visibility::PubCrate)));\n        assert!(names.iter().any(|(n,v)| n == \"E\" \u0026\u0026 matches!(v, Visibility::PubSuper)));\n    }\n\n    #[test]\n    fn test_extract_imports_with_alias() {\n        let src = r#\"\n        use std::collections::HashMap;\n        pub use crate::module::Thing as Alias;\n        \"#;\n        let parser = RustParser::new();\n        let node = parser.parse_file(src, std::path::Path::new(\"/x.rs\")).unwrap();\n        assert_eq!(node.imports.len(), 2);\n        assert!(node.imports.iter().any(|im| im.path.contains(\"std::collections::HashMap\") \u0026\u0026 im.alias.is_none()));\n        assert!(node.imports.iter().any(|im| im.path.contains(\"crate::module::Thing\") \u0026\u0026 im.alias.as_deref() == Some(\"Alias\")));\n    }\n\n    #[test]\n    fn test_async_const_functions_and_tuple_struct() {\n        let src = r#\"\n        pub async fn af() {}\n        pub const fn cf() -\u003e i32 { 0 }\n        pub struct TS(u32, u32);\n        pub(self) fn scoped() {}\n        \"#;\n        let parser = RustParser::new();\n        let node = parser.parse_file(src, std::path::Path::new(\"/y.rs\")).unwrap();\n        let names: Vec\u003c_\u003e = node.items.iter().map(|i| i.name.as_str()).collect();\n        assert!(names.contains(\u0026\"af\"));\n        assert!(names.contains(\u0026\"cf\"));\n        assert!(names.contains(\u0026\"TS\"));\n        // Ensure vis pub(in ..) patterns are accepted and mapped\n        let scoped = node.items.iter().find(|i| i.name == \"scoped\").expect(\"scoped present\");\n        match scoped.visibility {\n            Visibility::PubIn(ref s) =\u003e assert_eq!(s, \"self\"),\n            _ =\u003e panic!(\"expected Visibility::PubIn('self') for scoped\"),\n        }\n        // Sanity: counts align (2 fns + 1 tuple struct + 1 scoped fn)\n        assert_eq!(node.items.len(), 4);\n    }\n}\n","traces":[{"line":21,"address":[6652160,6653165,6653159],"length":1,"stats":{"Line":6}},{"line":23,"address":[7707905],"length":1,"stats":{"Line":6}},{"line":24,"address":[9420978],"length":1,"stats":{"Line":12}},{"line":25,"address":[6651748,6651817],"length":1,"stats":{"Line":12}},{"line":26,"address":[7711899,7711971],"length":1,"stats":{"Line":12}},{"line":27,"address":[9142029,9141957],"length":1,"stats":{"Line":12}},{"line":32,"address":[10329111],"length":1,"stats":{"Line":0}},{"line":33,"address":[10331623,10332666,10332574,10332537,10332560,10331770],"length":1,"stats":{"Line":0}},{"line":37,"address":[6782928],"length":1,"stats":{"Line":6}},{"line":38,"address":[6653201],"length":1,"stats":{"Line":6}},{"line":41,"address":[10330893],"length":1,"stats":{"Line":6}},{"line":42,"address":[10327684,10327835,10327613,10327545],"length":1,"stats":{"Line":6}},{"line":43,"address":[9132624],"length":1,"stats":{"Line":6}},{"line":44,"address":[7702720,7702779],"length":1,"stats":{"Line":12}},{"line":45,"address":[6643380],"length":1,"stats":{"Line":6}},{"line":48,"address":[9270624],"length":1,"stats":{"Line":6}},{"line":49,"address":[7701766],"length":1,"stats":{"Line":6}},{"line":51,"address":[9270657],"length":1,"stats":{"Line":18}},{"line":52,"address":[7620400,7620401],"length":1,"stats":{"Line":16}},{"line":53,"address":[6780255,6780179],"length":1,"stats":{"Line":16}},{"line":54,"address":[9270828],"length":1,"stats":{"Line":4}},{"line":55,"address":[9352540],"length":1,"stats":{"Line":16}},{"line":56,"address":[7707481],"length":1,"stats":{"Line":4}},{"line":57,"address":[6242066],"length":1,"stats":{"Line":4}},{"line":58,"address":[7710520,7710571],"length":1,"stats":{"Line":8}},{"line":59,"address":[7707211],"length":1,"stats":{"Line":4}},{"line":60,"address":[6781267],"length":1,"stats":{"Line":4}},{"line":61,"address":[7720842,7720779],"length":1,"stats":{"Line":8}},{"line":62,"address":[10330417],"length":1,"stats":{"Line":4}},{"line":66,"address":[10340387],"length":1,"stats":{"Line":12}},{"line":67,"address":[9053937,9053936],"length":1,"stats":{"Line":4}},{"line":68,"address":[6533857,6533856],"length":1,"stats":{"Line":4}},{"line":69,"address":[6649101],"length":1,"stats":{"Line":1}},{"line":70,"address":[6648556,6648604],"length":1,"stats":{"Line":4}},{"line":71,"address":[9139271],"length":1,"stats":{"Line":1}},{"line":72,"address":[6649333],"length":1,"stats":{"Line":1}},{"line":73,"address":[6779311],"length":1,"stats":{"Line":1}},{"line":74,"address":[7705321],"length":1,"stats":{"Line":1}},{"line":75,"address":[9139041],"length":1,"stats":{"Line":1}},{"line":76,"address":[6649081,6649144],"length":1,"stats":{"Line":2}},{"line":77,"address":[6649208],"length":1,"stats":{"Line":1}},{"line":81,"address":[7716178,7716039],"length":1,"stats":{"Line":12}},{"line":82,"address":[7706683,7706526],"length":1,"stats":{"Line":4}},{"line":83,"address":[10795424],"length":1,"stats":{"Line":5}},{"line":84,"address":[6238872],"length":1,"stats":{"Line":3}},{"line":85,"address":[9137059,9137011],"length":1,"stats":{"Line":5}},{"line":86,"address":[6239626],"length":1,"stats":{"Line":2}},{"line":87,"address":[6647196],"length":1,"stats":{"Line":1}},{"line":88,"address":[6648022],"length":1,"stats":{"Line":3}},{"line":89,"address":[7703780],"length":1,"stats":{"Line":1}},{"line":90,"address":[7717308],"length":1,"stats":{"Line":9}},{"line":91,"address":[9137540,9137603],"length":1,"stats":{"Line":2}},{"line":92,"address":[6648259],"length":1,"stats":{"Line":1}},{"line":96,"address":[6647140],"length":1,"stats":{"Line":6}},{"line":99,"address":[7705041,7704144,7705047],"length":1,"stats":{"Line":6}},{"line":100,"address":[9134152],"length":1,"stats":{"Line":8}},{"line":101,"address":[6644189,6644363,6644249],"length":1,"stats":{"Line":19}},{"line":102,"address":[6645198,6645084],"length":1,"stats":{"Line":10}},{"line":103,"address":[7704779,7704827],"length":1,"stats":{"Line":6}},{"line":104,"address":[6237055],"length":1,"stats":{"Line":2}},{"line":106,"address":[9888560],"length":1,"stats":{"Line":8}},{"line":110,"address":[7703168,7703782,7703776],"length":1,"stats":{"Line":4}},{"line":111,"address":[7712998],"length":1,"stats":{"Line":4}},{"line":112,"address":[10809735,10809779],"length":1,"stats":{"Line":5}},{"line":113,"address":[10796471],"length":1,"stats":{"Line":8}},{"line":114,"address":[6773683,6773607],"length":1,"stats":{"Line":2}},{"line":115,"address":[6643318,6643422],"length":1,"stats":{"Line":2}},{"line":116,"address":[7713178,7713248],"length":1,"stats":{"Line":2}},{"line":117,"address":[7713415,7713313],"length":1,"stats":{"Line":4}},{"line":119,"address":[6643545],"length":1,"stats":{"Line":0}},{"line":122,"address":[6645712],"length":1,"stats":{"Line":4}},{"line":124,"address":[7705187,7705265],"length":1,"stats":{"Line":10}}],"covered":69,"coverable":72},{"path":["/","home","dio","knowledge-rs","src","query","mod.rs"],"content":"use std::collections::{HashMap, HashSet};\nuse std::path::{Path, PathBuf};\n\nuse crate::graph::{ItemId, KnowledgeGraph};\n\n/// Query trait implemented by all query types.\n///\n/// Given an immutable reference to a `KnowledgeGraph`, returns a result of type `R`.\npub trait Query\u003cR\u003e {\n    fn run(\u0026self, graph: \u0026KnowledgeGraph) -\u003e R;\n}\n\n/// List types implementing a given trait name.\n///\n/// Returns rows as `(file_path, type_name)` sorted by file then type.\npub struct TraitImplsQuery {\n    pub trait_name: String,\n}\n\nimpl TraitImplsQuery {\n    /// Create a new query for the provided trait name (e.g., \"Display\").\n    pub fn new(trait_name: \u0026str) -\u003e Self { Self { trait_name: trait_name.to_string() } }\n}\n\n// Returns Vec of (file_path, type_name)\nimpl Query\u003cVec\u003c(PathBuf, String)\u003e\u003e for TraitImplsQuery {\n    fn run(\u0026self, graph: \u0026KnowledgeGraph) -\u003e Vec\u003c(PathBuf, String)\u003e {\n        let mut out: Vec\u003c(PathBuf, String)\u003e = Vec::new();\n        for (path, file) in \u0026graph.files {\n            for it in \u0026file.items {\n                if let crate::graph::ItemType::Impl { trait_name, type_name } = \u0026it.item_type {\n                    if let Some(tn) = trait_name {\n                        if tn == \u0026self.trait_name {\n                            out.push((path.clone(), type_name.clone()));\n                        }\n                    }\n                }\n            }\n        }\n        // Stable sort by file then type\n        out.sort_by(|a, b| a.0.cmp(\u0026b.0).then_with(|| a.1.cmp(\u0026b.1)));\n        out\n    }\n}\n\n/// Return the set of files directly connected to a target file by any relationship\n/// involving items defined in that file (edge endpoints at item-level are projected to file-level).\npub struct ConnectedFilesQuery {\n    pub file: PathBuf,\n}\n\nimpl ConnectedFilesQuery {\n    /// Construct a query targeting the specified file path.\n    pub fn new\u003cP: AsRef\u003cPath\u003e\u003e(file: P) -\u003e Self {\n        Self { file: file.as_ref().to_path_buf() }\n    }\n}\n\nimpl Query\u003cVec\u003cPathBuf\u003e\u003e for ConnectedFilesQuery {\n    fn run(\u0026self, graph: \u0026KnowledgeGraph) -\u003e Vec\u003cPathBuf\u003e {\n        // Build item -\u003e file index and file -\u003e items index\n        let mut item_to_file: HashMap\u003cItemId, PathBuf\u003e = HashMap::new();\n        let mut file_to_items: HashMap\u003cPathBuf, Vec\u003cItemId\u003e\u003e = HashMap::new();\n        for (path, file) in \u0026graph.files {\n            let ids: Vec\u003cItemId\u003e = file.items.iter().map(|i| i.id.clone()).collect();\n            for id in \u0026ids {\n                item_to_file.insert(id.clone(), path.clone());\n            }\n            file_to_items.insert(path.clone(), ids);\n        }\n\n        // Resolve the canonical path in the graph map\n        let Some((target_path, _node)) = graph.files.iter().find(|(p, _)| p == \u0026\u0026self.file) else {\n            return Vec::new();\n        };\n\n        let Some(target_items) = file_to_items.get(target_path) else { return Vec::new(); };\n        let target_set: HashSet\u003cItemId\u003e = target_items.iter().cloned().collect();\n\n        let mut out: HashSet\u003cPathBuf\u003e = HashSet::new();\n        for rel in \u0026graph.relationships {\n            // If edge touches any item in the target file, add the opposing file\n            if target_set.contains(\u0026rel.from_item) {\n                if let Some(fp) = item_to_file.get(\u0026rel.to_item) {\n                    if fp != target_path {\n                        out.insert(fp.clone());\n                    }\n                }\n            }\n            if target_set.contains(\u0026rel.to_item) {\n                if let Some(fp) = item_to_file.get(\u0026rel.from_item) {\n                    if fp != target_path {\n                        out.insert(fp.clone());\n                    }\n                }\n            }\n        }\n\n        let mut v: Vec\u003cPathBuf\u003e = out.into_iter().collect();\n        v.sort();\n        v\n    }\n}\n\n/// Direction for `FunctionUsageQuery`.\npub enum UsageDirection { Callers, Callees }\n\n/// Find callers or callees for a given function name, returning unique file paths.\npub struct FunctionUsageQuery {\n    pub function: String,\n    pub direction: UsageDirection,\n}\n\nimpl FunctionUsageQuery {\n    /// Query files containing callers of the specified function name.\n    pub fn callers(function: \u0026str) -\u003e Self { Self { function: function.to_string(), direction: UsageDirection::Callers } }\n    /// Query files containing callees called by the specified function name.\n    pub fn callees(function: \u0026str) -\u003e Self { Self { function: function.to_string(), direction: UsageDirection::Callees } }\n}\n\nimpl Query\u003cVec\u003cPathBuf\u003e\u003e for FunctionUsageQuery {\n    fn run(\u0026self, graph: \u0026KnowledgeGraph) -\u003e Vec\u003cPathBuf\u003e {\n        // Build indices\n        let mut item_to_file: HashMap\u003cItemId, PathBuf\u003e = HashMap::new();\n        let mut func_name_to_ids: HashMap\u003cString, Vec\u003cItemId\u003e\u003e = HashMap::new();\n        for (path, file) in \u0026graph.files {\n            for item in \u0026file.items {\n                item_to_file.insert(item.id.clone(), path.clone());\n                // crude: function ids contain prefix \"fn:\"; but better match by type and name\n                if let crate::graph::ItemType::Function { .. } = item.item_type {\n                    func_name_to_ids.entry(item.name.clone()).or_default().push(item.id.clone());\n                }\n            }\n        }\n\n        let Some(target_ids) = func_name_to_ids.get(\u0026self.function) else { return Vec::new(); };\n        let target_set: HashSet\u003cItemId\u003e = target_ids.iter().cloned().collect();\n\n        let mut out: HashSet\u003cPathBuf\u003e = HashSet::new();\n        for rel in \u0026graph.relationships {\n            match self.direction {\n                UsageDirection::Callers =\u003e {\n                    if target_set.contains(\u0026rel.to_item) {\n                        if let Some(fp) = item_to_file.get(\u0026rel.from_item) { out.insert(fp.clone()); }\n                    }\n                }\n                UsageDirection::Callees =\u003e {\n                    if target_set.contains(\u0026rel.from_item) {\n                        if let Some(fp) = item_to_file.get(\u0026rel.to_item) { out.insert(fp.clone()); }\n                    }\n                }\n            }\n        }\n\n        let mut v: Vec\u003cPathBuf\u003e = out.into_iter().collect();\n        v.sort();\n        v\n    }\n}\n\n/// Detect cycles over the file-level projection of the graph.\npub struct CycleDetectionQuery;\n\nimpl CycleDetectionQuery {\n    /// Construct a cycle detection query.\n    pub fn new() -\u003e Self { Self }\n}\n\nimpl Query\u003cVec\u003cVec\u003cPathBuf\u003e\u003e\u003e for CycleDetectionQuery {\n    fn run(\u0026self, graph: \u0026KnowledgeGraph) -\u003e Vec\u003cVec\u003cPathBuf\u003e\u003e {\n        // Build file-level adjacency ignoring self loops\n        let mut file_ids: Vec\u003cPathBuf\u003e = graph.files.keys().cloned().collect();\n        file_ids.sort();\n        let index: HashMap\u003cPathBuf, usize\u003e = file_ids.iter().cloned().enumerate().map(|(i, p)| (p, i)).collect();\n\n        // Map each relationship to file-\u003efile edge\n        let mut adj: Vec\u003cVec\u003cusize\u003e\u003e = vec![Vec::new(); file_ids.len()];\n        // Prepare item-\u003efile map\n        let mut item_to_file: HashMap\u003cItemId, usize\u003e = HashMap::new();\n        for (path, file) in \u0026graph.files {\n            if let Some(\u0026i) = index.get(path) {\n                for it in \u0026file.items { item_to_file.insert(it.id.clone(), i); }\n            }\n        }\n        for rel in \u0026graph.relationships {\n            if let (Some(\u0026u), Some(\u0026v)) = (item_to_file.get(\u0026rel.from_item), item_to_file.get(\u0026rel.to_item)) {\n                if u != v { adj[u].push(v); }\n            }\n        }\n\n        // DFS to find simple cycles (not necessarily unique, limited dedup)\n        let mut visited = vec![false; file_ids.len()];\n        let mut stack = vec![false; file_ids.len()];\n        let mut path: Vec\u003cusize\u003e = Vec::new();\n        let mut cycles: Vec\u003cVec\u003cPathBuf\u003e\u003e = Vec::new();\n\n        fn dfs(u: usize, adj: \u0026Vec\u003cVec\u003cusize\u003e\u003e, visited: \u0026mut [bool], stack: \u0026mut [bool], path: \u0026mut Vec\u003cusize\u003e, out: \u0026mut Vec\u003cVec\u003cPathBuf\u003e\u003e, names: \u0026Vec\u003cPathBuf\u003e) {\n            visited[u] = true;\n            stack[u] = true;\n            path.push(u);\n            for \u0026v in \u0026adj[u] {\n                if !visited[v] {\n                    dfs(v, adj, visited, stack, path, out, names);\n                } else if stack[v] {\n                    // Found a cycle; extract from v to end\n                    if let Some(pos) = path.iter().position(|\u0026x| x == v) {\n                        let cyc: Vec\u003cPathBuf\u003e = path[pos..].iter().map(|\u0026i| names[i].clone()).collect();\n                        out.push(cyc);\n                    }\n                }\n            }\n            path.pop();\n            stack[u] = false;\n        }\n\n        for u in 0..file_ids.len() {\n            if !visited[u] { dfs(u, \u0026adj, \u0026mut visited, \u0026mut stack, \u0026mut path, \u0026mut cycles, \u0026file_ids); }\n        }\n\n        cycles\n    }\n}\n\n/// Compute shortest path between two files (directed edges) on the file-level projection.\npub struct ShortestPathQuery {\n    pub from: PathBuf,\n    pub to: PathBuf,\n}\n\nimpl ShortestPathQuery {\n    /// Create a shortest path query from `from` to `to` (file paths).\n    pub fn new\u003cP: AsRef\u003cPath\u003e, Q: AsRef\u003cPath\u003e\u003e(from: P, to: Q) -\u003e Self {\n        Self { from: from.as_ref().to_path_buf(), to: to.as_ref().to_path_buf() }\n    }\n}\n\nimpl Query\u003cVec\u003cPathBuf\u003e\u003e for ShortestPathQuery {\n    fn run(\u0026self, graph: \u0026KnowledgeGraph) -\u003e Vec\u003cPathBuf\u003e {\n        // Map files to indices\n        let mut files: Vec\u003cPathBuf\u003e = graph.files.keys().cloned().collect();\n        files.sort();\n        let idx: HashMap\u003cPathBuf, usize\u003e = files.iter().cloned().enumerate().map(|(i, p)| (p, i)).collect();\n\n        let (Some(\u0026src), Some(\u0026dst)) = (idx.get(\u0026self.from), idx.get(\u0026self.to)) else { return Vec::new(); };\n\n        // Build item-\u003efile index and adjacency list\n        let mut item_to_file: HashMap\u003cItemId, usize\u003e = HashMap::new();\n        for (path, file) in \u0026graph.files {\n            if let Some(\u0026i) = idx.get(path) {\n                for it in \u0026file.items { item_to_file.insert(it.id.clone(), i); }\n            }\n        }\n        let mut adj: Vec\u003cVec\u003cusize\u003e\u003e = vec![Vec::new(); files.len()];\n        for rel in \u0026graph.relationships {\n            if let (Some(\u0026u), Some(\u0026v)) = (item_to_file.get(\u0026rel.from_item), item_to_file.get(\u0026rel.to_item)) {\n                if u != v { adj[u].push(v); }\n            }\n        }\n\n        // BFS\n        let mut prev: Vec\u003cOption\u003cusize\u003e\u003e = vec![None; files.len()];\n        let mut q: std::collections::VecDeque\u003cusize\u003e = std::collections::VecDeque::new();\n        let mut visited = vec![false; files.len()];\n        visited[src] = true;\n        q.push_back(src);\n        while let Some(u) = q.pop_front() {\n            if u == dst { break; }\n            for \u0026v in \u0026adj[u] {\n                if !visited[v] {\n                    visited[v] = true;\n                    prev[v] = Some(u);\n                    q.push_back(v);\n                }\n            }\n        }\n\n        if !visited[dst] { return Vec::new(); }\n\n        // Reconstruct path\n        let mut path_indices: Vec\u003cusize\u003e = Vec::new();\n        let mut cur = dst;\n        while let Some(p) = prev[cur] {\n            path_indices.push(cur);\n            cur = p;\n        }\n        path_indices.push(src);\n        path_indices.reverse();\n\n        path_indices.into_iter().map(|i| files[i].clone()).collect()\n    }\n}\n\n/// Metric for degree centrality used by `HubsQuery` and `ModuleCentralityQuery`.\npub enum CentralityMetric { In, Out, Total }\n\n/// Compute top-N files by degree centrality.\npub struct HubsQuery {\n    pub metric: CentralityMetric,\n    pub top: usize,\n}\n\nimpl HubsQuery {\n    /// Create a hubs query for the given metric and number of results.\n    pub fn new(metric: CentralityMetric, top: usize) -\u003e Self { Self { metric, top } }\n}\n\nimpl Query\u003cVec\u003c(PathBuf, usize, usize)\u003e\u003e for HubsQuery {\n    fn run(\u0026self, graph: \u0026KnowledgeGraph) -\u003e Vec\u003c(PathBuf, usize, usize)\u003e {\n        // Map files to indices\n        let mut files: Vec\u003cPathBuf\u003e = graph.files.keys().cloned().collect();\n        files.sort();\n        let idx: HashMap\u003cPathBuf, usize\u003e = files.iter().cloned().enumerate().map(|(i, p)| (p, i)).collect();\n\n        // Build item-\u003efile index and degree counters\n        let mut item_to_file: HashMap\u003cItemId, usize\u003e = HashMap::new();\n        for (path, file) in \u0026graph.files {\n            if let Some(\u0026i) = idx.get(path) {\n                for it in \u0026file.items { item_to_file.insert(it.id.clone(), i); }\n            }\n        }\n        let n = files.len();\n        let mut indeg = vec![0usize; n];\n        let mut outdeg = vec![0usize; n];\n\n        // Count edges at file level; ignore self-loops\n        for rel in \u0026graph.relationships {\n            if let (Some(\u0026u), Some(\u0026v)) = (item_to_file.get(\u0026rel.from_item), item_to_file.get(\u0026rel.to_item)) {\n                if u != v {\n                    outdeg[u] += 1;\n                    indeg[v] += 1;\n                }\n            }\n        }\n\n        let mut rows: Vec\u003c(PathBuf, usize, usize)\u003e = (0..n)\n            .map(|i| (files[i].clone(), indeg[i], outdeg[i]))\n            .collect();\n\n        // Sort by chosen metric desc, then by path asc for stability\n        rows.sort_by(|a, b| {\n            let (ai, ao) = (a.1, a.2);\n            let (bi, bo) = (b.1, b.2);\n            let ak = match self.metric { CentralityMetric::In =\u003e ai, CentralityMetric::Out =\u003e ao, CentralityMetric::Total =\u003e ai + ao };\n            let bk = match self.metric { CentralityMetric::In =\u003e bi, CentralityMetric::Out =\u003e bo, CentralityMetric::Total =\u003e bi + bo };\n            bk.cmp(\u0026ak).then_with(|| a.0.cmp(\u0026b.0))\n        });\n\n        rows.truncate(self.top);\n        rows\n    }\n}\n\n/// Compute top-N modules (by directory) by degree centrality.\npub struct ModuleCentralityQuery {\n    pub metric: CentralityMetric,\n    pub top: usize,\n}\n\nimpl ModuleCentralityQuery {\n    /// Create a module centrality query for the given metric and number of results.\n    pub fn new(metric: CentralityMetric, top: usize) -\u003e Self { Self { metric, top } }\n}\n\nimpl Query\u003cVec\u003c(PathBuf, usize, usize)\u003e\u003e for ModuleCentralityQuery {\n    fn run(\u0026self, graph: \u0026KnowledgeGraph) -\u003e Vec\u003c(PathBuf, usize, usize)\u003e {\n        // Build list of modules identified by parent directory of file\n        let mut modules: HashSet\u003cPathBuf\u003e = HashSet::new();\n        let mut file_to_module: HashMap\u003cPathBuf, PathBuf\u003e = HashMap::new();\n        for p in graph.files.keys() {\n            let m = p.parent().map(|x| x.to_path_buf()).unwrap_or_else(|| PathBuf::from(\".\"));\n            modules.insert(m.clone());\n            file_to_module.insert(p.clone(), m);\n        }\n\n        let mut mods: Vec\u003cPathBuf\u003e = modules.into_iter().collect();\n        mods.sort();\n        let midx: HashMap\u003cPathBuf, usize\u003e = mods.iter().cloned().enumerate().map(|(i, p)| (p, i)).collect();\n\n        // Map items to module index\n        let mut item_to_mod: HashMap\u003cItemId, usize\u003e = HashMap::new();\n        for (path, file) in \u0026graph.files {\n            let Some(module_path) = file_to_module.get(path) else { continue };\n            if let Some(\u0026mi) = midx.get(module_path) {\n                for it in \u0026file.items { item_to_mod.insert(it.id.clone(), mi); }\n            }\n        }\n\n        let n = mods.len();\n        let mut indeg = vec![0usize; n];\n        let mut outdeg = vec![0usize; n];\n\n        // Count inter-module edges\n        for rel in \u0026graph.relationships {\n            if let (Some(\u0026u), Some(\u0026v)) = (item_to_mod.get(\u0026rel.from_item), item_to_mod.get(\u0026rel.to_item)) {\n                if u != v { outdeg[u] += 1; indeg[v] += 1; }\n            }\n        }\n\n        let mut rows: Vec\u003c(PathBuf, usize, usize)\u003e = (0..n)\n            .map(|i| (mods[i].clone(), indeg[i], outdeg[i]))\n            .collect();\n\n        rows.sort_by(|a, b| {\n            let (ai, ao) = (a.1, a.2);\n            let (bi, bo) = (b.1, b.2);\n            let ak = match self.metric { CentralityMetric::In =\u003e ai, CentralityMetric::Out =\u003e ao, CentralityMetric::Total =\u003e ai + ao };\n            let bk = match self.metric { CentralityMetric::In =\u003e bi, CentralityMetric::Out =\u003e bo, CentralityMetric::Total =\u003e bi + bo };\n            bk.cmp(\u0026ak).then_with(|| a.0.cmp(\u0026b.0))\n        });\n\n        rows.truncate(self.top);\n        rows\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::graph::{FileNode, Item, ItemType, Relationship, RelationshipType};\n\n    fn make_fn(path: \u0026PathBuf, id_prefix: \u0026str, name: \u0026str) -\u003e Item {\n        Item {\n            id: ItemId(format!(\"fn:{}:{}\", name, id_prefix)),\n            item_type: ItemType::Function { is_async: false, is_const: false },\n            name: name.to_string(),\n            visibility: crate::graph::Visibility::Public,\n            location: crate::graph::Location { file: path.clone(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        }\n    }\n\n    // Build a small graph:\n    // src/a.rs (A) -\u003e calls -\u003e src/b.rs (B)\n    // src/b.rs (B) -\u003e calls -\u003e src/c.rs (C)\n    // Optional cycle: c -\u003e a\n    fn graph_fixture(with_cycle: bool) -\u003e KnowledgeGraph {\n        let mut g = KnowledgeGraph::default();\n        let a_path = PathBuf::from(\"src/a.rs\");\n        let b_path = PathBuf::from(\"src/b.rs\");\n        let c_path = PathBuf::from(\"src/c.rs\");\n\n        let a_item = make_fn(\u0026a_path, \"1\", \"fa\");\n        let b_item = make_fn(\u0026b_path, \"2\", \"fb\");\n        let c_item = make_fn(\u0026c_path, \"3\", \"fc\");\n\n        g.files.insert(\n            a_path.clone(),\n            FileNode { path: a_path.clone(), items: vec![a_item.clone()], imports: vec![], metrics: Default::default() },\n        );\n        g.files.insert(\n            b_path.clone(),\n            FileNode { path: b_path.clone(), items: vec![b_item.clone()], imports: vec![], metrics: Default::default() },\n        );\n        g.files.insert(\n            c_path.clone(),\n            FileNode { path: c_path.clone(), items: vec![c_item.clone()], imports: vec![], metrics: Default::default() },\n        );\n\n        g.relationships.push(Relationship {\n            from_item: a_item.id.clone(),\n            to_item: b_item.id.clone(),\n            relationship_type: RelationshipType::Calls { call_type: \"test\".to_string() },\n            strength: 1.0,\n            context: String::new(),\n        });\n        g.relationships.push(Relationship {\n            from_item: b_item.id.clone(),\n            to_item: c_item.id.clone(),\n            relationship_type: RelationshipType::Calls { call_type: \"test\".to_string() },\n            strength: 1.0,\n            context: String::new(),\n        });\n        if with_cycle {\n            g.relationships.push(Relationship {\n                from_item: c_item.id.clone(),\n                to_item: a_item.id.clone(),\n                relationship_type: RelationshipType::Calls { call_type: \"test\".to_string() },\n                strength: 1.0,\n                context: String::new(),\n            });\n        }\n        g\n    }\n\n    #[test]\n    fn connected_files_query_basic() {\n        let g = graph_fixture(false);\n        let q = ConnectedFilesQuery::new(\"src/a.rs\");\n        let res = q.run(\u0026g);\n        // a is connected to b\n        assert!(res.contains(\u0026PathBuf::from(\"src/b.rs\")));\n        // b is connected to a and c as well, but for a we expect only b because c is reached via b (no direct edge)\n        assert!(!res.contains(\u0026PathBuf::from(\"src/c.rs\")));\n    }\n\n    #[test]\n    fn function_usage_callers_and_callees() {\n        let g = graph_fixture(false);\n        // callees of fa should include file of fb\n        let q_callees = FunctionUsageQuery::callees(\"fa\");\n        let callees = q_callees.run(\u0026g);\n        assert!(callees.contains(\u0026PathBuf::from(\"src/b.rs\")));\n\n        // callers of fb should include file of fa\n        let q_callers = FunctionUsageQuery::callers(\"fb\");\n        let callers = q_callers.run(\u0026g);\n        assert!(callers.contains(\u0026PathBuf::from(\"src/a.rs\")));\n    }\n\n    #[test]\n    fn cycle_detection_detects_simple_cycle() {\n        let g = graph_fixture(true);\n        let q = CycleDetectionQuery::new();\n        let cycles = q.run(\u0026g);\n        // Expect at least one cycle involving a -\u003e b -\u003e c -\u003e a\n        assert!(cycles.iter().any(|cyc| {\n            // convert to set for containment check\n            let names: std::collections::HashSet\u003c_\u003e = cyc.iter().cloned().collect();\n            names.contains(\u0026PathBuf::from(\"src/a.rs\")) \u0026\u0026\n            names.contains(\u0026PathBuf::from(\"src/b.rs\")) \u0026\u0026\n            names.contains(\u0026PathBuf::from(\"src/c.rs\"))\n        }));\n    }\n\n    #[test]\n    fn trait_impls_basic() {\n        let mut g = KnowledgeGraph::default();\n        let p = PathBuf::from(\"src/x.rs\");\n        let impl_item = Item {\n            id: ItemId(\"impl:X:Display\".to_string()),\n            item_type: ItemType::Impl { trait_name: Some(\"Display\".to_string()), type_name: \"X\".to_string() },\n            name: \"impl Display for X\".to_string(),\n            visibility: crate::graph::Visibility::PubCrate,\n            location: crate::graph::Location { file: p.clone(), line_start: 1, line_end: 1 },\n            attributes: vec![],\n        };\n        g.files.insert(p.clone(), FileNode { path: p.clone(), items: vec![impl_item], imports: vec![], metrics: Default::default() });\n\n        let q = TraitImplsQuery::new(\"Display\");\n        let rows = q.run(\u0026g);\n        assert_eq!(rows.len(), 1);\n        assert_eq!(rows[0].0, p);\n        assert_eq!(rows[0].1, \"X\");\n    }\n}\n","traces":[{"line":22,"address":[7331616,7331639],"length":1,"stats":{"Line":2}},{"line":27,"address":[6791381,6790480,6791375],"length":1,"stats":{"Line":1}},{"line":28,"address":[7330699],"length":1,"stats":{"Line":1}},{"line":29,"address":[7330788,7330721],"length":1,"stats":{"Line":2}},{"line":30,"address":[7181481,7181619],"length":1,"stats":{"Line":2}},{"line":31,"address":[7181723],"length":1,"stats":{"Line":1}},{"line":32,"address":[7181826],"length":1,"stats":{"Line":1}},{"line":33,"address":[7331337],"length":1,"stats":{"Line":1}},{"line":34,"address":[7331402],"length":1,"stats":{"Line":1}},{"line":41,"address":[7847776,7846048,7846062,7847829],"length":1,"stats":{"Line":1}},{"line":42,"address":[6790818],"length":1,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[5719217,5719155],"length":1,"stats":{"Line":4}},{"line":60,"address":[6802278,6801207,6799808],"length":1,"stats":{"Line":2}},{"line":62,"address":[7331831],"length":1,"stats":{"Line":2}},{"line":63,"address":[7182416],"length":1,"stats":{"Line":2}},{"line":64,"address":[7334226,7332007,7331943],"length":1,"stats":{"Line":6}},{"line":65,"address":[7184352,7182715],"length":1,"stats":{"Line":8}},{"line":66,"address":[7333897,7333977],"length":1,"stats":{"Line":4}},{"line":67,"address":[7334262,7334083,7334239],"length":1,"stats":{"Line":4}},{"line":69,"address":[7184653],"length":1,"stats":{"Line":2}},{"line":73,"address":[7851502,7851488],"length":1,"stats":{"Line":6}},{"line":74,"address":[6801666,6800409],"length":1,"stats":{"Line":0}},{"line":77,"address":[7182983,7182918,7184294,7183073],"length":1,"stats":{"Line":4}},{"line":78,"address":[7183038,7183103],"length":1,"stats":{"Line":4}},{"line":80,"address":[7332664],"length":1,"stats":{"Line":2}},{"line":81,"address":[7332824,7332735],"length":1,"stats":{"Line":4}},{"line":83,"address":[6800895,6801217],"length":1,"stats":{"Line":4}},{"line":84,"address":[7333332],"length":1,"stats":{"Line":2}},{"line":85,"address":[6801359],"length":1,"stats":{"Line":2}},{"line":86,"address":[7333464],"length":1,"stats":{"Line":1}},{"line":90,"address":[7333297,7333523],"length":1,"stats":{"Line":4}},{"line":91,"address":[6801452],"length":1,"stats":{"Line":1}},{"line":92,"address":[7333629],"length":1,"stats":{"Line":1}},{"line":93,"address":[7333673],"length":1,"stats":{"Line":1}},{"line":99,"address":[7332965],"length":1,"stats":{"Line":2}},{"line":100,"address":[6801031,6801102],"length":1,"stats":{"Line":4}},{"line":101,"address":[6801117],"length":1,"stats":{"Line":2}},{"line":116,"address":[7331719,7331696],"length":1,"stats":{"Line":2}},{"line":118,"address":[7189984,7190007],"length":1,"stats":{"Line":2}},{"line":122,"address":[7339413,7337184,7338446],"length":1,"stats":{"Line":1}},{"line":124,"address":[6791543],"length":1,"stats":{"Line":1}},{"line":125,"address":[7187816],"length":1,"stats":{"Line":1}},{"line":126,"address":[7187951,7187887],"length":1,"stats":{"Line":2}},{"line":127,"address":[7189453,7188115],"length":1,"stats":{"Line":2}},{"line":128,"address":[6793242,6793204,6793561],"length":1,"stats":{"Line":1}},{"line":130,"address":[7189732],"length":1,"stats":{"Line":1}},{"line":131,"address":[6793422],"length":1,"stats":{"Line":1}},{"line":136,"address":[7337738,7337613],"length":1,"stats":{"Line":1}},{"line":137,"address":[6791975,6792036],"length":1,"stats":{"Line":2}},{"line":139,"address":[7188393],"length":1,"stats":{"Line":1}},{"line":140,"address":[7188464,7188541],"length":1,"stats":{"Line":2}},{"line":141,"address":[7188654],"length":1,"stats":{"Line":1}},{"line":143,"address":[6792703],"length":1,"stats":{"Line":1}},{"line":144,"address":[7338537],"length":1,"stats":{"Line":1}},{"line":148,"address":[7338680,7338457],"length":1,"stats":{"Line":2}},{"line":149,"address":[7189238],"length":1,"stats":{"Line":1}},{"line":155,"address":[7188679],"length":1,"stats":{"Line":1}},{"line":156,"address":[7338245,7338328],"length":1,"stats":{"Line":2}},{"line":157,"address":[7188891],"length":1,"stats":{"Line":1}},{"line":166,"address":[6797120],"length":1,"stats":{"Line":1}},{"line":170,"address":[7337165,7334464,7336602],"length":1,"stats":{"Line":1}},{"line":172,"address":[7185066],"length":1,"stats":{"Line":1}},{"line":173,"address":[7185177,7185264],"length":1,"stats":{"Line":2}},{"line":174,"address":[6939096,6939088],"length":1,"stats":{"Line":3}},{"line":177,"address":[6799759,6797747,6797657,6797716],"length":1,"stats":{"Line":2}},{"line":179,"address":[6797847],"length":1,"stats":{"Line":1}},{"line":180,"address":[6797958,6797902],"length":1,"stats":{"Line":2}},{"line":181,"address":[6798126,6799505],"length":1,"stats":{"Line":2}},{"line":182,"address":[6799580],"length":1,"stats":{"Line":1}},{"line":185,"address":[6798152],"length":1,"stats":{"Line":1}},{"line":186,"address":[7186173,7187160],"length":1,"stats":{"Line":2}},{"line":187,"address":[7336791],"length":1,"stats":{"Line":1}},{"line":192,"address":[7186207],"length":1,"stats":{"Line":1}},{"line":193,"address":[7335805,7335726],"length":1,"stats":{"Line":2}},{"line":194,"address":[6798493],"length":1,"stats":{"Line":1}},{"line":195,"address":[7335893],"length":1,"stats":{"Line":1}},{"line":197,"address":[7180400],"length":1,"stats":{"Line":1}},{"line":198,"address":[7180565,7180524],"length":1,"stats":{"Line":1}},{"line":199,"address":[7330004,7330120,7330049],"length":1,"stats":{"Line":2}},{"line":200,"address":[7330053],"length":1,"stats":{"Line":1}},{"line":201,"address":[7180677,7180620],"length":1,"stats":{"Line":2}},{"line":202,"address":[6805682,6805767],"length":1,"stats":{"Line":2}},{"line":203,"address":[7180900],"length":1,"stats":{"Line":1}},{"line":204,"address":[6805877],"length":1,"stats":{"Line":1}},{"line":206,"address":[7330446],"length":1,"stats":{"Line":3}},{"line":207,"address":[7181098],"length":1,"stats":{"Line":3}},{"line":208,"address":[7330628],"length":1,"stats":{"Line":1}},{"line":212,"address":[7330209],"length":1,"stats":{"Line":1}},{"line":213,"address":[7330262,7330225],"length":1,"stats":{"Line":1}},{"line":216,"address":[7335953,7336029],"length":1,"stats":{"Line":2}},{"line":217,"address":[7186741,7186961],"length":1,"stats":{"Line":2}},{"line":220,"address":[6798890],"length":1,"stats":{"Line":1}},{"line":232,"address":[5719109,5719115,5718848],"length":1,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[6796538,6793584,6797105],"length":1,"stats":{"Line":0}},{"line":240,"address":[7190130],"length":1,"stats":{"Line":0}},{"line":241,"address":[7190336,7190249],"length":1,"stats":{"Line":0}},{"line":242,"address":[7339803],"length":1,"stats":{"Line":0}},{"line":244,"address":[6794120,6794057,6797081],"length":1,"stats":{"Line":0}},{"line":247,"address":[7340301],"length":1,"stats":{"Line":0}},{"line":248,"address":[7340328,7340395],"length":1,"stats":{"Line":0}},{"line":249,"address":[7193503,7191103],"length":1,"stats":{"Line":0}},{"line":250,"address":[7343034],"length":1,"stats":{"Line":0}},{"line":253,"address":[7191133,7191187,7193473],"length":1,"stats":{"Line":0}},{"line":254,"address":[7191381,7191294],"length":1,"stats":{"Line":0}},{"line":255,"address":[6796552,6794927],"length":1,"stats":{"Line":0}},{"line":256,"address":[7342851],"length":1,"stats":{"Line":0}},{"line":261,"address":[7191529],"length":1,"stats":{"Line":0}},{"line":262,"address":[6795022],"length":1,"stats":{"Line":0}},{"line":263,"address":[7191657,7191733],"length":1,"stats":{"Line":0}},{"line":264,"address":[6795173,6795267],"length":1,"stats":{"Line":0}},{"line":265,"address":[7341322],"length":1,"stats":{"Line":0}},{"line":266,"address":[7341350],"length":1,"stats":{"Line":0}},{"line":267,"address":[6795403],"length":1,"stats":{"Line":0}},{"line":268,"address":[7341521],"length":1,"stats":{"Line":0}},{"line":269,"address":[6795660],"length":1,"stats":{"Line":0}},{"line":270,"address":[6795716],"length":1,"stats":{"Line":0}},{"line":271,"address":[6795760],"length":1,"stats":{"Line":0}},{"line":272,"address":[7341884],"length":1,"stats":{"Line":0}},{"line":277,"address":[7192467,7192020],"length":1,"stats":{"Line":0}},{"line":280,"address":[6795875],"length":1,"stats":{"Line":0}},{"line":281,"address":[7342091],"length":1,"stats":{"Line":0}},{"line":282,"address":[7192736,7192651,7192848],"length":1,"stats":{"Line":0}},{"line":283,"address":[7192767],"length":1,"stats":{"Line":0}},{"line":284,"address":[7192840],"length":1,"stats":{"Line":0}},{"line":286,"address":[6796169],"length":1,"stats":{"Line":0}},{"line":287,"address":[7342309],"length":1,"stats":{"Line":0}},{"line":289,"address":[7342359],"length":1,"stats":{"Line":0}},{"line":304,"address":[7193823,7193808],"length":1,"stats":{"Line":0}},{"line":308,"address":[7345511,7344854,7343280],"length":1,"stats":{"Line":0}},{"line":310,"address":[6788402],"length":1,"stats":{"Line":0}},{"line":311,"address":[7343449,7343536],"length":1,"stats":{"Line":0}},{"line":312,"address":[6939208,6939200],"length":1,"stats":{"Line":0}},{"line":315,"address":[7343757],"length":1,"stats":{"Line":0}},{"line":316,"address":[7343892,7343828],"length":1,"stats":{"Line":0}},{"line":317,"address":[6790189,6789064],"length":1,"stats":{"Line":0}},{"line":318,"address":[7345320],"length":1,"stats":{"Line":0}},{"line":321,"address":[7344086],"length":1,"stats":{"Line":0}},{"line":322,"address":[7194673],"length":1,"stats":{"Line":0}},{"line":323,"address":[6789157],"length":1,"stats":{"Line":0}},{"line":326,"address":[7194873,7194789],"length":1,"stats":{"Line":0}},{"line":327,"address":[7344865,7344440],"length":1,"stats":{"Line":0}},{"line":328,"address":[6789981,6790158],"length":1,"stats":{"Line":0}},{"line":329,"address":[6789995,6790100],"length":1,"stats":{"Line":0}},{"line":330,"address":[7195669,7195763,7195725],"length":1,"stats":{"Line":0}},{"line":336,"address":[7344487],"length":1,"stats":{"Line":0}},{"line":340,"address":[7846272],"length":1,"stats":{"Line":0}},{"line":341,"address":[9279992],"length":1,"stats":{"Line":0}},{"line":342,"address":[6939354],"length":1,"stats":{"Line":0}},{"line":343,"address":[6790332,6790464],"length":1,"stats":{"Line":0}},{"line":344,"address":[6113721,6113785,6113878],"length":1,"stats":{"Line":0}},{"line":345,"address":[7846958,7846944,7846584],"length":1,"stats":{"Line":0}},{"line":348,"address":[6789655],"length":1,"stats":{"Line":0}},{"line":349,"address":[6789681],"length":1,"stats":{"Line":0}},{"line":361,"address":[7196080,7196095],"length":1,"stats":{"Line":0}},{"line":365,"address":[7326736,7329818,7328708],"length":1,"stats":{"Line":0}},{"line":367,"address":[7326791],"length":1,"stats":{"Line":0}},{"line":368,"address":[7177376],"length":1,"stats":{"Line":0}},{"line":369,"address":[6802628,6805287,6802556],"length":1,"stats":{"Line":0}},{"line":370,"address":[7850464,7851452,7851440,7850486],"length":1,"stats":{"Line":0}},{"line":371,"address":[7329631,7329583],"length":1,"stats":{"Line":0}},{"line":372,"address":[6805174],"length":1,"stats":{"Line":0}},{"line":375,"address":[7177685],"length":1,"stats":{"Line":0}},{"line":376,"address":[7177795,7177890],"length":1,"stats":{"Line":0}},{"line":377,"address":[6802981],"length":1,"stats":{"Line":0}},{"line":380,"address":[7327567],"length":1,"stats":{"Line":0}},{"line":381,"address":[7178182,7178246],"length":1,"stats":{"Line":0}},{"line":382,"address":[7178410,7179649],"length":1,"stats":{"Line":0}},{"line":383,"address":[7329164],"length":1,"stats":{"Line":0}},{"line":384,"address":[7329268],"length":1,"stats":{"Line":0}},{"line":388,"address":[6803488],"length":1,"stats":{"Line":0}},{"line":389,"address":[7327939],"length":1,"stats":{"Line":0}},{"line":390,"address":[6803555],"length":1,"stats":{"Line":0}},{"line":393,"address":[7328139,7328055],"length":1,"stats":{"Line":0}},{"line":394,"address":[7179266,7178797],"length":1,"stats":{"Line":0}},{"line":395,"address":[7179441],"length":1,"stats":{"Line":0}},{"line":400,"address":[7860592,7860634],"length":1,"stats":{"Line":0}},{"line":403,"address":[6791344],"length":1,"stats":{"Line":0}},{"line":404,"address":[7847432],"length":1,"stats":{"Line":0}},{"line":405,"address":[6790826],"length":1,"stats":{"Line":0}},{"line":406,"address":[7860988,7861120],"length":1,"stats":{"Line":0}},{"line":407,"address":[7861145,7861081,7861239],"length":1,"stats":{"Line":0}},{"line":408,"address":[6791518,6791064,6791504],"length":1,"stats":{"Line":0}},{"line":411,"address":[7179061],"length":1,"stats":{"Line":0}},{"line":412,"address":[7179091],"length":1,"stats":{"Line":0}}],"covered":92,"coverable":186},{"path":["/","home","dio","knowledge-rs","src","utils","mod.rs"],"content":"// Utilities module placeholder per design\npub mod table {\n    // Render a simple ASCII table given headers and rows\n    pub fn render(headers: \u0026[\u0026str], rows: \u0026[Vec\u003cString\u003e]) -\u003e String {\n        let cols = headers.len();\n        let mut widths: Vec\u003cusize\u003e = headers.iter().map(|h| h.len()).collect();\n        for row in rows {\n            for c in 0..cols { widths[c] = widths[c].max(row.get(c).map(|s| s.len()).unwrap_or(0)); }\n        }\n        fn sep(widths: \u0026[usize]) -\u003e String {\n            let mut s = String::from(\"+\");\n            for w in widths { s.push_str(\u0026\"-\".repeat(w + 2)); s.push('+'); }\n            s\n        }\n        fn line(cells: Vec\u003cString\u003e, widths: \u0026[usize]) -\u003e String {\n            let mut s = String::from(\"|\");\n            for (i, cell) in cells.into_iter().enumerate() {\n                let w = widths[i];\n                s.push(' ');\n                s.push_str(\u0026cell);\n                if cell.len() \u003c w { s.push_str(\u0026\" \".repeat(w - cell.len())); }\n                s.push(' ');\n                s.push('|');\n            }\n            s\n        }\n\n        let mut out = String::new();\n        out.push_str(\u0026sep(\u0026widths)); out.push('\\n');\n        out.push_str(\u0026line(headers.iter().map(|s| s.to_string()).collect(), \u0026widths)); out.push('\\n');\n        out.push_str(\u0026sep(\u0026widths)); out.push('\\n');\n        for row in rows {\n            let mut cells = Vec::with_capacity(cols);\n            for i in 0..cols { cells.push(row.get(i).cloned().unwrap_or_default()); }\n            out.push_str(\u0026line(cells, \u0026widths)); out.push('\\n');\n        }\n        out.push_str(\u0026sep(\u0026widths));\n        out\n    }\n}\n\npub mod config {\n    use serde::Deserialize;\n    use std::fs;\n    use std::path::{Path, PathBuf};\n\n    #[derive(Debug, Clone, Deserialize, Default)]\n    pub struct DotConfig {\n        pub clusters: Option\u003cbool\u003e,\n        pub legend: Option\u003cbool\u003e,\n        pub theme: Option\u003cString\u003e,     // \"light\" | \"dark\"\n        pub rankdir: Option\u003cString\u003e,   // \"LR\" | \"TB\"\n        pub splines: Option\u003cString\u003e,   // \"curved\" | \"ortho\" | \"polyline\"\n        pub rounded: Option\u003cbool\u003e,\n    }\n\n    #[derive(Debug, Clone, Deserialize, Default)]\n    pub struct SvgConfig {\n        pub interactive: Option\u003cbool\u003e,\n    }\n\n    #[derive(Debug, Clone, Deserialize, Default)]\n    pub struct QueryConfig {\n        pub default_format: Option\u003cString\u003e, // \"text\" | \"json\"\n    }\n\n    #[derive(Debug, Clone, Deserialize, Default)]\n    pub struct Config {\n        pub root: Option\u003cString\u003e,\n        pub dot: Option\u003cDotConfig\u003e,\n        pub svg: Option\u003cSvgConfig\u003e,\n        pub query: Option\u003cQueryConfig\u003e,\n    }\n\n    fn default_config_path(root: \u0026Path) -\u003e PathBuf {\n        root.join(\"knowledge-rs.toml\")\n    }\n\n    pub fn load_config_at(path: \u0026Path) -\u003e Option\u003cConfig\u003e {\n        let data = fs::read_to_string(path).ok()?;\n        toml::from_str::\u003cConfig\u003e(\u0026data).ok()\n    }\n\n    pub fn load_config_near(root: \u0026Path) -\u003e Option\u003cConfig\u003e {\n        let p = default_config_path(root);\n        if p.exists() { load_config_at(\u0026p) } else { None }\n    }\n}\n\npub mod cache {\n    use serde::{Deserialize, Serialize};\n    use std::collections::HashMap;\n    use std::path::{Path, PathBuf};\n\n    use crate::graph::FileNode;\n\n    #[derive(Debug, Clone, Serialize, Deserialize, Default, PartialEq, Eq)]\n    pub struct CacheEntryMeta {\n        pub mtime: u64,\n        pub len: u64,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, Default)]\n    pub struct CacheEntry {\n        pub meta: CacheEntryMeta,\n        pub node: FileNode,\n    }\n\n    #[derive(Debug, Clone, Serialize, Deserialize, Default)]\n    pub struct Cache {\n        pub entries: HashMap\u003cPathBuf, CacheEntry\u003e,\n    }\n\n    #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n    pub enum CacheMode {\n        Use,\n        Ignore,\n        Rebuild,\n    }\n\n    fn cache_path(root: \u0026Path) -\u003e PathBuf {\n        root.join(\".knowledge_cache.json\")\n    }\n\n    pub fn load_cache(root: \u0026Path) -\u003e Option\u003cCache\u003e {\n        let path = cache_path(root);\n        let data = std::fs::read_to_string(path).ok()?;\n        serde_json::from_str::\u003cCache\u003e(\u0026data).ok()\n    }\n\n    pub fn save_cache(root: \u0026Path, cache: \u0026Cache) {\n        let path = cache_path(root);\n        if let Ok(data) = serde_json::to_string_pretty(cache) {\n            let _ = std::fs::write(path, data);\n        }\n    }\n\n    pub fn clear_cache(root: \u0026Path) {\n        let path = cache_path(root);\n        let _ = std::fs::remove_file(path);\n    }\n}\n\npub mod file_walker {\n    /// Discover Rust source files under `root`, with an option to bypass ignore rules.\n    pub fn rust_files_with_options(root: \u0026str, no_ignore: bool) -\u003e Vec\u003cString\u003e {\n        let mut out = Vec::new();\n        let mut walker = ignore::WalkBuilder::new(root);\n        // Explicitly enable .gitignore/.ignore support and parent traversal (unless bypassed)\n        walker\n            .follow_links(false)\n            .git_ignore(!no_ignore)\n            .git_global(false)\n            .git_exclude(false)\n            .ignore(!no_ignore)\n            .parents(true);\n        // Build a Gitignore matcher from root-level ignore files for explicit checks (unless bypassed)\n        let root_path = std::path::Path::new(root);\n        let matcher = if no_ignore {\n            None\n        } else {\n            let mut gi_builder = ignore::gitignore::GitignoreBuilder::new(root_path);\n            let gi = root_path.join(\".gitignore\");\n            if gi.exists() { let _ = gi_builder.add(gi); }\n            let ign = root_path.join(\".ignore\");\n            if ign.exists() { let _ = gi_builder.add(ign); }\n            gi_builder.build().ok()\n        };\n        for result in walker.build() {\n            if let Ok(entry) = result {\n                if entry.file_type().map(|t| t.is_file()).unwrap_or(false) {\n                    // Explicit filter using matcher (in addition to WalkBuilder's own filtering)\n                    if let Some(m) = \u0026matcher {\n                        if m.matched(entry.path(), false).is_ignore() { continue; }\n                    }\n                    if entry.path().extension() == Some(std::ffi::OsStr::new(\"rs\")) {\n                        if let Some(s) = entry.path().to_str() {\n                            out.push(s.to_string());\n                        }\n                    }\n                }\n            }\n        }\n        out\n    }\n\n    /// Backward-compatible helper that reads env var and delegates to rust_files_with_options.\n    pub fn rust_files(root: \u0026str) -\u003e Vec\u003cString\u003e {\n        let no_ignore = std::env::var(\"KNOWLEDGE_RS_NO_IGNORE\")\n            .map(|v| v == \"1\" || v.eq_ignore_ascii_case(\"true\"))\n            .unwrap_or(false);\n        rust_files_with_options(root, no_ignore)\n    }\n}\n","traces":[{"line":4,"address":[7695296,7697146,7698322],"length":1,"stats":{"Line":1}},{"line":5,"address":[7695405],"length":1,"stats":{"Line":1}},{"line":6,"address":[9669088,9669102],"length":1,"stats":{"Line":3}},{"line":7,"address":[7695497,7695584],"length":1,"stats":{"Line":2}},{"line":8,"address":[7354980,7352746],"length":1,"stats":{"Line":4}},{"line":10,"address":[6759984,6760468,6760474],"length":1,"stats":{"Line":1}},{"line":11,"address":[6760027],"length":1,"stats":{"Line":1}},{"line":12,"address":[6760059,6760131,6760295],"length":1,"stats":{"Line":3}},{"line":13,"address":[7699728],"length":1,"stats":{"Line":1}},{"line":15,"address":[6758864,6759938],"length":1,"stats":{"Line":1}},{"line":16,"address":[6758912],"length":1,"stats":{"Line":1}},{"line":17,"address":[7351494,7351382,7351613],"length":1,"stats":{"Line":3}},{"line":18,"address":[7351724,7351806,7351857],"length":1,"stats":{"Line":2}},{"line":19,"address":[6759459],"length":1,"stats":{"Line":1}},{"line":20,"address":[7351929],"length":1,"stats":{"Line":1}},{"line":21,"address":[7699153,7699091],"length":1,"stats":{"Line":2}},{"line":22,"address":[6759646],"length":1,"stats":{"Line":1}},{"line":23,"address":[7352256],"length":1,"stats":{"Line":1}},{"line":25,"address":[7698864],"length":1,"stats":{"Line":1}},{"line":28,"address":[6756276],"length":1,"stats":{"Line":1}},{"line":29,"address":[7352795,7352898],"length":1,"stats":{"Line":2}},{"line":30,"address":[8235347,8235312],"length":1,"stats":{"Line":3}},{"line":31,"address":[6756968],"length":1,"stats":{"Line":1}},{"line":32,"address":[6758283,6757209],"length":1,"stats":{"Line":2}},{"line":33,"address":[6757688,6757374],"length":1,"stats":{"Line":2}},{"line":34,"address":[7354826,7354188,7354276],"length":1,"stats":{"Line":3}},{"line":35,"address":[6758026,6758288,6757943],"length":1,"stats":{"Line":1}},{"line":37,"address":[7353895],"length":1,"stats":{"Line":1}},{"line":38,"address":[7354101],"length":1,"stats":{"Line":1}},{"line":75,"address":[6560672],"length":1,"stats":{"Line":1}},{"line":76,"address":[7024037],"length":1,"stats":{"Line":1}},{"line":79,"address":[7026425,7026112,7026431],"length":1,"stats":{"Line":1}},{"line":80,"address":[6562801],"length":1,"stats":{"Line":1}},{"line":81,"address":[6563014,6562951],"length":1,"stats":{"Line":2}},{"line":84,"address":[6560864,6561086,6561080],"length":1,"stats":{"Line":1}},{"line":85,"address":[7625778],"length":1,"stats":{"Line":1}},{"line":86,"address":[7625947,7625788,7625850],"length":1,"stats":{"Line":3}},{"line":121,"address":[8228928],"length":1,"stats":{"Line":5}},{"line":122,"address":[8242437],"length":1,"stats":{"Line":5}},{"line":125,"address":[8240576,8240918,8240912],"length":1,"stats":{"Line":5}},{"line":126,"address":[7171073],"length":1,"stats":{"Line":6}},{"line":127,"address":[7320139],"length":1,"stats":{"Line":6}},{"line":128,"address":[8240845,8240780],"length":1,"stats":{"Line":2}},{"line":131,"address":[9661584,9661998,9662027],"length":1,"stats":{"Line":3}},{"line":132,"address":[6444557],"length":1,"stats":{"Line":3}},{"line":133,"address":[7320982,7321039,7321089],"length":1,"stats":{"Line":9}},{"line":134,"address":[8231509,8231626],"length":1,"stats":{"Line":6}},{"line":138,"address":[8232112],"length":1,"stats":{"Line":1}},{"line":139,"address":[8232132],"length":1,"stats":{"Line":1}},{"line":140,"address":[7321742],"length":1,"stats":{"Line":1}},{"line":146,"address":[7034796,7033318,7031968],"length":1,"stats":{"Line":6}},{"line":147,"address":[9011289],"length":1,"stats":{"Line":7}},{"line":148,"address":[6651098],"length":1,"stats":{"Line":6}},{"line":152,"address":[6153063],"length":1,"stats":{"Line":6}},{"line":155,"address":[6651343],"length":1,"stats":{"Line":7}},{"line":158,"address":[6153230],"length":1,"stats":{"Line":6}},{"line":159,"address":[7032484,7032541],"length":1,"stats":{"Line":7}},{"line":160,"address":[7032523],"length":1,"stats":{"Line":1}},{"line":162,"address":[6153316],"length":1,"stats":{"Line":7}},{"line":163,"address":[6522158,6522082],"length":1,"stats":{"Line":12}},{"line":164,"address":[6153466,6153618,6153543],"length":1,"stats":{"Line":15}},{"line":165,"address":[6521702,6521831],"length":1,"stats":{"Line":12}},{"line":166,"address":[6652045,6651991,6651911],"length":1,"stats":{"Line":13}},{"line":167,"address":[7610706,7610827],"length":1,"stats":{"Line":12}},{"line":169,"address":[7582245,7582366,7582486],"length":1,"stats":{"Line":19}},{"line":170,"address":[6652746,6652556],"length":1,"stats":{"Line":13}},{"line":171,"address":[7611546,7611637],"length":1,"stats":{"Line":25}},{"line":173,"address":[6523560],"length":1,"stats":{"Line":6}},{"line":174,"address":[6523021,6523092],"length":1,"stats":{"Line":13}},{"line":176,"address":[7583373,7583098],"length":1,"stats":{"Line":13}},{"line":177,"address":[6523475],"length":1,"stats":{"Line":6}},{"line":178,"address":[7034694],"length":1,"stats":{"Line":6}},{"line":184,"address":[7611304],"length":1,"stats":{"Line":7}},{"line":188,"address":[6653824],"length":1,"stats":{"Line":1}},{"line":189,"address":[6524386],"length":1,"stats":{"Line":1}},{"line":190,"address":[7034889],"length":1,"stats":{"Line":1}},{"line":192,"address":[6523870],"length":1,"stats":{"Line":1}}],"covered":77,"coverable":77},{"path":["/","home","dio","knowledge-rs","src","visualization","mod.rs"],"content":"use crate::errors::KnowledgeGraphError;\nuse crate::graph::{ItemType, KnowledgeGraph, RelationshipType};\nuse std::collections::HashSet;\n\n#[derive(Debug, Clone, Copy)]\npub enum DotTheme { Light, Dark }\n\n#[derive(Debug, Clone, Copy)]\npub enum RankDir { LR, TB }\n\n#[derive(Debug, Clone, Copy)]\npub enum EdgeStyle { Curved, Ortho, Polyline }\n\n#[derive(Debug, Clone, Copy)]\npub struct DotOptions {\n    pub clusters: bool,\n    pub legend: bool,\n    pub theme: DotTheme,\n    pub rankdir: RankDir,\n    pub splines: EdgeStyle,\n    pub rounded: bool,\n}\n\nimpl Default for DotOptions {\n    fn default() -\u003e Self {\n        Self { clusters: true, legend: true, theme: DotTheme::Light, rankdir: RankDir::LR, splines: EdgeStyle::Curved, rounded: true }\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\npub struct SvgOptions {\n    pub dot: DotOptions,\n    pub interactive: bool,\n}\n\nimpl Default for SvgOptions {\n    fn default() -\u003e Self { Self { dot: DotOptions::default(), interactive: true } }\n}\n\n#[derive(Debug, Default)]\npub struct SvgGenerator;\n\nimpl SvgGenerator {\n    pub fn new() -\u003e Self { Self {} }\n\n    pub fn generate_svg_with_options(\u0026self, graph: \u0026KnowledgeGraph, opts: SvgOptions) -\u003e Result\u003cString, KnowledgeGraphError\u003e {\n        let dot = DotGenerator::new().generate_dot_with_options(graph, opts.dot)?;\n        // Render with Graphviz `dot -Tsvg`\n        let output = std::process::Command::new(\"dot\")\n            .arg(\"-Tsvg\")\n            .stdin(std::process::Stdio::piped())\n            .stdout(std::process::Stdio::piped())\n            .spawn()\n            .and_then(|mut child| {\n                use std::io::Write;\n                if let Some(stdin) = child.stdin.as_mut() {\n                    stdin.write_all(dot.as_bytes())?;\n                }\n                child.wait_with_output()\n            })\n            .map_err(|e| KnowledgeGraphError::Visualization(format!(\"Failed to run graphviz 'dot': {}\", e)))?;\n        if !output.status.success() {\n            return Err(KnowledgeGraphError::Visualization(format!(\"Graphviz 'dot' failed with code {:?}\", output.status.code())));\n        }\n        let mut svg = String::from_utf8(output.stdout).map_err(|e| KnowledgeGraphError::Visualization(format!(\"Invalid UTF-8 from dot: {}\", e)))?;\n        if opts.interactive {\n            svg = enhance_svg(\u0026svg);\n        }\n        Ok(svg)\n    }\n}\n\nfn enhance_svg(svg: \u0026str) -\u003e String {\n    // Inject minimal CSS/JS for hover highlight and clickable nodes\n    let injection = r#\"\n\u003cstyle\u003e\nsvg .node:hover ellipse, svg .node:hover polygon, svg .node:hover path, svg .node:hover rect { filter: brightness(1.15); stroke-width: 2; }\nsvg .edge:hover path { stroke-width: 2.2; }\n\u003c/style\u003e\n\u003cscript\u003e\u003c![CDATA[\n(function(){\n  document.querySelectorAll('g.node a').forEach(function(a){\n    a.addEventListener('click', function(ev){\n      ev.preventDefault();\n      const href = a.getAttribute('xlink:href') || a.getAttribute('href');\n      if (href) { console.log('clicked', href); }\n    });\n  });\n})();\n]]\u003e\u003c/script\u003e\n\"#;\n    if let Some(pos) = svg.rfind(\"\u003c/svg\u003e\") {\n        let mut out = String::with_capacity(svg.len() + injection.len());\n        out.push_str(\u0026svg[..pos]);\n        out.push_str(injection);\n        out.push_str(\u0026svg[pos..]);\n        out\n    } else {\n        let mut out = svg.to_string();\n        out.push_str(injection);\n        out\n    }\n}\n\n#[derive(Debug, Default)]\npub struct DotGenerator;\n\nimpl DotGenerator {\n    pub fn new() -\u003e Self { Self {} }\n\n    pub fn generate_dot(\u0026self, graph: \u0026KnowledgeGraph) -\u003e Result\u003cString, KnowledgeGraphError\u003e {\n        self.generate_dot_with_options(graph, DotOptions::default())\n    }\n\n    pub fn generate_dot_with_options(\u0026self, graph: \u0026KnowledgeGraph, opts: DotOptions) -\u003e Result\u003cString, KnowledgeGraphError\u003e {\n        let mut s = String::new();\n        s.push_str(\"digraph KnowledgeRS {\\n\");\n        let rank = match opts.rankdir { RankDir::LR =\u003e \"LR\", RankDir::TB =\u003e \"TB\" };\n        let splines = match opts.splines { EdgeStyle::Curved =\u003e \"curved\", EdgeStyle::Ortho =\u003e \"ortho\", EdgeStyle::Polyline =\u003e \"polyline\" };\n        let node_style = if opts.rounded { \"filled,rounded\" } else { \"filled\" };\n        s.push_str(\u0026format!(\"  rankdir={};\\n  graph [fontname=Helvetica, splines={}] ;\\n  node [shape=box, fontsize=10, style={}] ;\\n  edge [fontname=Helvetica, fontsize=9];\\n\", rank, splines, node_style));\n\n        if opts.clusters {\n            // Build hierarchical clusters from module roots\n            let mut visited: HashSet\u003cString\u003e = HashSet::new();\n            // Identify roots: files without a module parent\n            let mut roots: Vec\u003c_\u003e = graph\n                .files\n                .keys()\n                .filter(|p| graph.get_module_parent(*p).is_none())\n                .cloned()\n                .collect();\n            // Stable order for determinism\n            roots.sort();\n            for root in roots {\n                self.write_module_cluster(graph, \u0026root, \u0026mut s, \u0026mut visited, opts.theme);\n            }\n        } else {\n            // No clusters: emit all nodes flat\n            let mut paths: Vec\u003c_\u003e = graph.files.keys().cloned().collect();\n            paths.sort();\n            for path in paths {\n                if let Some(file) = graph.files.get(\u0026path) {\n                    for item in \u0026file.items {\n                        let node_id = sanitize_id(\u0026item.id.0);\n                        let (fill, shape) = style_for_item_with_theme(\u0026item.item_type, opts.theme);\n                        let url = format!(\"item://{}\", node_id);\n                        let tooltip = escape_label(\u0026item.name);\n                        s.push_str(\u0026format!(\n                            \"  \\\"{}\\\" [label=\\\"{}\\\", fillcolor=\\\"{}\\\", shape=\\\"{}\\\", URL=\\\"{}\\\", tooltip=\\\"{}\\\"];\\n\",\n                            node_id,\n                            escape_label(\u0026item.name),\n                            fill,\n                            shape,\n                            url,\n                            tooltip\n                        ));\n                    }\n                }\n            }\n        }\n\n        // Emit edges (relationships)\n        for rel in \u0026graph.relationships {\n            let from = sanitize_id(\u0026rel.from_item.0);\n            let to = sanitize_id(\u0026rel.to_item.0);\n            let (label, color, style) = match \u0026rel.relationship_type {\n                RelationshipType::Uses { import_type } =\u003e (format!(\"uses:{}\", import_type), \"#1f77b4\", \"dashed\"),\n                RelationshipType::Implements { trait_name } =\u003e (format!(\"impl:{}\", trait_name), \"#2ca02c\", \"dotted\"),\n                RelationshipType::Contains { containment_type } =\u003e (format!(\"contains:{}\", containment_type), \"#7f7f7f\", \"solid\"),\n                RelationshipType::Extends { extension_type } =\u003e (format!(\"extends:{}\", extension_type), \"#9467bd\", \"dashed\"),\n                RelationshipType::Calls { call_type } =\u003e (format!(\"calls:{}\", call_type), \"#d62728\", \"solid\"),\n            };\n            let penwidth = 0.8_f64.max(rel.strength).min(3.0);\n            s.push_str(\u0026format!(\n                \"  \\\"{}\\\" -\u003e \\\"{}\\\" [label=\\\"{}\\\", color=\\\"{}\\\", style=\\\"{}\\\", penwidth={}];\\n\",\n                from,\n                to,\n                escape_label(\u0026label),\n                color,\n                style,\n                penwidth\n            ));\n        }\n\n        if opts.legend {\n            // Legend cluster\n            s.push_str(\"  subgraph cluster_legend {\\n    label=\\\"Legend\\\";\\n    color=grey;\\n\");\n            let legend_items = [\n                (\"Module\", ItemType::Module { is_inline: false }),\n                (\"Function\", ItemType::Function { is_async: false, is_const: false }),\n                (\"Struct\", ItemType::Struct { is_tuple: false }),\n                (\"Enum\", ItemType::Enum { variant_count: 0 }),\n                (\"Trait\", ItemType::Trait { is_object_safe: false }),\n            ];\n            for (name, t) in legend_items {\n                let (fill, shape) = style_for_item_with_theme(\u0026t, opts.theme);\n                let id = sanitize_id(\u0026format!(\"legend_{}\", name));\n                s.push_str(\u0026format!(\"    \\\"{}\\\" [label=\\\"{}\\\", fillcolor=\\\"{}\\\", shape=\\\"{}\\\"];\\n\", id, name, fill, shape));\n            }\n            s.push_str(\"  }\\n\");\n        }\n\n        s.push_str(\"}\\n\");\n        Ok(s)\n    }\n\n    fn write_module_cluster(\n        \u0026self,\n        graph: \u0026KnowledgeGraph,\n        path: \u0026std::path::PathBuf,\n        out: \u0026mut String,\n        visited: \u0026mut HashSet\u003cString\u003e,\n        theme: DotTheme,\n    ) {\n        let key = path.to_string_lossy().to_string();\n        if !visited.insert(key.clone()) {\n            return;\n        }\n        let cluster_id = format!(\"cluster_{}\", sanitize_id(\u0026key));\n        let label = path.file_name().and_then(|p| p.to_str()).unwrap_or(\"\");\n        out.push_str(\u0026format!(\"  subgraph \\\"{}\\\" {{\\n    label=\\\"{}\\\";\\n    color=lightgrey;\\n\", cluster_id, escape_label(label)));\n\n        if let Some(file) = graph.files.get(path) {\n            for item in \u0026file.items {\n                let node_id = sanitize_id(\u0026item.id.0);\n                let (fill, shape) = style_for_item_with_theme(\u0026item.item_type, theme);\n                let url = format!(\"item://{}\", node_id);\n                let tooltip = escape_label(\u0026item.name);\n                out.push_str(\u0026format!(\n                    \"    \\\"{}\\\" [label=\\\"{}\\\", fillcolor=\\\"{}\\\", shape=\\\"{}\\\", URL=\\\"{}\\\", tooltip=\\\"{}\\\"];\\n\",\n                    node_id,\n                    escape_label(\u0026item.name),\n                    fill,\n                    shape,\n                    url,\n                    tooltip\n                ));\n            }\n        }\n\n        // Children\n        for child in graph.get_module_children(path).iter() {\n            self.write_module_cluster(graph, child, out, visited, theme);\n        }\n        out.push_str(\"  }\\n\");\n    }\n}\n\nfn sanitize_id(s: \u0026str) -\u003e String {\n    s.chars()\n        .map(|c| match c {\n            'a'..='z' | 'A'..='Z' | '0'..='9' | '_' =\u003e c,\n            _ =\u003e '_',\n        })\n        .collect()\n}\n\nfn escape_label(s: \u0026str) -\u003e String {\n    s.replace('\"', \"\\\\\\\"\")\n}\n\nfn style_for_item_with_theme(t: \u0026ItemType, theme: DotTheme) -\u003e (\u0026'static str, \u0026'static str) {\n    match (theme, t) {\n        (DotTheme::Light, ItemType::Module { .. }) =\u003e (\"#e0f3ff\", \"component\"),\n        (DotTheme::Light, ItemType::Function { .. }) =\u003e (\"#e8ffe0\", \"oval\"),\n        (DotTheme::Light, ItemType::Struct { .. }) =\u003e (\"#fff4e0\", \"box\"),\n        (DotTheme::Light, ItemType::Enum { .. }) =\u003e (\"#ffe0f0\", \"hexagon\"),\n        (DotTheme::Light, ItemType::Trait { .. }) =\u003e (\"#f0e0ff\", \"parallelogram\"),\n        (DotTheme::Light, ItemType::Impl { .. }) =\u003e (\"#f0fff0\", \"box3d\"),\n        (DotTheme::Light, ItemType::Const) =\u003e (\"#ffffe0\", \"note\"),\n        (DotTheme::Light, ItemType::Static { .. }) =\u003e (\"#ffffe0\", \"folder\"),\n        (DotTheme::Light, ItemType::Type) =\u003e (\"#f0ffff\", \"box\"),\n        (DotTheme::Light, ItemType::Macro) =\u003e (\"#e0ffe8\", \"cds\"),\n\n        (DotTheme::Dark, ItemType::Module { .. }) =\u003e (\"#124559\", \"component\"),\n        (DotTheme::Dark, ItemType::Function { .. }) =\u003e (\"#0b6e4f\", \"oval\"),\n        (DotTheme::Dark, ItemType::Struct { .. }) =\u003e (\"#7a4c00\", \"box\"),\n        (DotTheme::Dark, ItemType::Enum { .. }) =\u003e (\"#6a1e44\", \"hexagon\"),\n        (DotTheme::Dark, ItemType::Trait { .. }) =\u003e (\"#3c2a5a\", \"parallelogram\"),\n        (DotTheme::Dark, ItemType::Impl { .. }) =\u003e (\"#1a5e1a\", \"box3d\"),\n        (DotTheme::Dark, ItemType::Const) =\u003e (\"#6b6b00\", \"note\"),\n        (DotTheme::Dark, ItemType::Static { .. }) =\u003e (\"#6b6b00\", \"folder\"),\n        (DotTheme::Dark, ItemType::Type) =\u003e (\"#004f4f\", \"box\"),\n        (DotTheme::Dark, ItemType::Macro) =\u003e (\"#0f5e3a\", \"cds\"),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::graph::ItemType;\n\n    #[test]\n    fn test_sanitize_id_basic() {\n        let s = \"file:/path/to:thing.rs#1\";\n        let got = sanitize_id(s);\n        // Allowed: letters, numbers, underscore; others -\u003e underscore\n        assert_eq!(got, \"file__path_to_thing_rs_1\");\n        assert_eq!(sanitize_id(\"abc_DEF012\"), \"abc_DEF012\");\n    }\n\n    #[test]\n    fn test_escape_label_quotes() {\n        let s = \"a\\\"b\\\"c\";\n        let got = escape_label(s);\n        assert_eq!(got, \"a\\\\\\\"b\\\\\\\"c\");\n    }\n\n    #[test]\n    fn test_style_for_item_with_theme_all_variants() {\n        // Light theme expectations\n        let cases_light: Vec\u003c(ItemType, (\u0026str, \u0026str))\u003e = vec![\n            (ItemType::Module { is_inline: false }, (\"#e0f3ff\", \"component\")),\n            (ItemType::Function { is_async: false, is_const: false }, (\"#e8ffe0\", \"oval\")),\n            (ItemType::Struct { is_tuple: false }, (\"#fff4e0\", \"box\")),\n            (ItemType::Enum { variant_count: 0 }, (\"#ffe0f0\", \"hexagon\")),\n            (ItemType::Trait { is_object_safe: false }, (\"#f0e0ff\", \"parallelogram\")),\n            (ItemType::Impl { trait_name: None, type_name: \"T\".into() }, (\"#f0fff0\", \"box3d\")),\n            (ItemType::Const, (\"#ffffe0\", \"note\")),\n            (ItemType::Static { is_mut: false }, (\"#ffffe0\", \"folder\")),\n            (ItemType::Type, (\"#f0ffff\", \"box\")),\n            (ItemType::Macro, (\"#e0ffe8\", \"cds\")),\n        ];\n        for (t, expected) in cases_light {\n            assert_eq!(style_for_item_with_theme(\u0026t, DotTheme::Light), expected);\n        }\n\n        // Dark theme expectations\n        let cases_dark: Vec\u003c(ItemType, (\u0026str, \u0026str))\u003e = vec![\n            (ItemType::Module { is_inline: false }, (\"#124559\", \"component\")),\n            (ItemType::Function { is_async: false, is_const: false }, (\"#0b6e4f\", \"oval\")),\n            (ItemType::Struct { is_tuple: false }, (\"#7a4c00\", \"box\")),\n            (ItemType::Enum { variant_count: 0 }, (\"#6a1e44\", \"hexagon\")),\n            (ItemType::Trait { is_object_safe: false }, (\"#3c2a5a\", \"parallelogram\")),\n            (ItemType::Impl { trait_name: None, type_name: \"T\".into() }, (\"#1a5e1a\", \"box3d\")),\n            (ItemType::Const, (\"#6b6b00\", \"note\")),\n            (ItemType::Static { is_mut: false }, (\"#6b6b00\", \"folder\")),\n            (ItemType::Type, (\"#004f4f\", \"box\")),\n            (ItemType::Macro, (\"#0f5e3a\", \"cds\")),\n        ];\n        for (t, expected) in cases_dark {\n            assert_eq!(style_for_item_with_theme(\u0026t, DotTheme::Dark), expected);\n        }\n    }\n\n    #[test]\n    fn test_enhance_svg_injection() {\n        let minimal = \"\u003csvg\u003e\u003c/svg\u003e\";\n        let out = enhance_svg(minimal);\n        assert!(out.contains(\"\u003cstyle\u003e\"));\n        assert!(out.ends_with(\"\u003c/svg\u003e\"));\n\n        // No closing tag case\n        let no_close = \"\u003csvg\u003e\";\n        let out2 = enhance_svg(no_close);\n        assert!(out2.contains(\"\u003cstyle\u003e\"));\n    }\n}\n","traces":[{"line":37,"address":[7272820,7272816],"length":1,"stats":{"Line":0}},{"line":44,"address":[7343472],"length":1,"stats":{"Line":0}},{"line":46,"address":[8345728,8347769,8347943],"length":1,"stats":{"Line":0}},{"line":47,"address":[7294691],"length":1,"stats":{"Line":0}},{"line":49,"address":[8333125,8333235,8332805],"length":1,"stats":{"Line":0}},{"line":51,"address":[8336362],"length":1,"stats":{"Line":0}},{"line":52,"address":[8332998],"length":1,"stats":{"Line":0}},{"line":54,"address":[9766746],"length":1,"stats":{"Line":0}},{"line":56,"address":[7270173,7270091],"length":1,"stats":{"Line":0}},{"line":57,"address":[8326363,8326277],"length":1,"stats":{"Line":0}},{"line":59,"address":[8329908,8329712],"length":1,"stats":{"Line":0}},{"line":61,"address":[8332913,8334628,8333171,8333400,8333098],"length":1,"stats":{"Line":0}},{"line":62,"address":[8346756],"length":1,"stats":{"Line":0}},{"line":63,"address":[7277538,7277441],"length":1,"stats":{"Line":0}},{"line":65,"address":[9760816,9760838],"length":1,"stats":{"Line":0}},{"line":66,"address":[7336871,7337202],"length":1,"stats":{"Line":0}},{"line":67,"address":[9767967,9767890,9767993],"length":1,"stats":{"Line":0}},{"line":69,"address":[8334117],"length":1,"stats":{"Line":0}},{"line":73,"address":[7297665,7297671,7297104],"length":1,"stats":{"Line":1}},{"line":75,"address":[7338715],"length":1,"stats":{"Line":1}},{"line":92,"address":[6922774,6923349],"length":1,"stats":{"Line":2}},{"line":93,"address":[6922970,6923018,6922841],"length":1,"stats":{"Line":2}},{"line":94,"address":[8338730,8338638],"length":1,"stats":{"Line":2}},{"line":95,"address":[8348637],"length":1,"stats":{"Line":1}},{"line":96,"address":[6923147],"length":1,"stats":{"Line":1}},{"line":97,"address":[7279399],"length":1,"stats":{"Line":1}},{"line":99,"address":[6922904],"length":1,"stats":{"Line":1}},{"line":100,"address":[7338899],"length":1,"stats":{"Line":1}},{"line":101,"address":[8338962],"length":1,"stats":{"Line":1}},{"line":109,"address":[7308256],"length":1,"stats":{"Line":0}},{"line":111,"address":[7291344],"length":1,"stats":{"Line":0}},{"line":112,"address":[9762881],"length":1,"stats":{"Line":0}},{"line":115,"address":[7299200,7302235,7307803],"length":1,"stats":{"Line":0}},{"line":116,"address":[7326812],"length":1,"stats":{"Line":0}},{"line":117,"address":[8337193],"length":1,"stats":{"Line":0}},{"line":118,"address":[6925023],"length":1,"stats":{"Line":0}},{"line":119,"address":[9771019],"length":1,"stats":{"Line":0}},{"line":120,"address":[6925227],"length":1,"stats":{"Line":0}},{"line":121,"address":[7299717],"length":1,"stats":{"Line":0}},{"line":123,"address":[7300102],"length":1,"stats":{"Line":0}},{"line":125,"address":[6925727],"length":1,"stats":{"Line":0}},{"line":127,"address":[7329715],"length":1,"stats":{"Line":0}},{"line":130,"address":[7329798],"length":1,"stats":{"Line":0}},{"line":134,"address":[7302527,7302435],"length":1,"stats":{"Line":0}},{"line":135,"address":[8353658,8353860],"length":1,"stats":{"Line":0}},{"line":136,"address":[6928409],"length":1,"stats":{"Line":0}},{"line":140,"address":[7281941,7281896],"length":1,"stats":{"Line":0}},{"line":141,"address":[7327787,7327707],"length":1,"stats":{"Line":0}},{"line":142,"address":[8341764,8341562],"length":1,"stats":{"Line":0}},{"line":143,"address":[7328213,7328073],"length":1,"stats":{"Line":0}},{"line":144,"address":[7282657,7282588],"length":1,"stats":{"Line":0}},{"line":145,"address":[7282771],"length":1,"stats":{"Line":0}},{"line":146,"address":[8352251,8352177],"length":1,"stats":{"Line":0}},{"line":147,"address":[8352315],"length":1,"stats":{"Line":0}},{"line":148,"address":[8339154,8339249],"length":1,"stats":{"Line":0}},{"line":149,"address":[8339374,8339958],"length":1,"stats":{"Line":0}},{"line":152,"address":[7328888,7328983],"length":1,"stats":{"Line":0}},{"line":164,"address":[9774437,9772179],"length":1,"stats":{"Line":0}},{"line":165,"address":[8356445,8354164],"length":1,"stats":{"Line":0}},{"line":166,"address":[7305420,7305337],"length":1,"stats":{"Line":0}},{"line":167,"address":[6931531,6931016],"length":1,"stats":{"Line":0}},{"line":168,"address":[6931324,6931050],"length":1,"stats":{"Line":0}},{"line":169,"address":[7333456,7332897],"length":1,"stats":{"Line":0}},{"line":170,"address":[7333663,7332944],"length":1,"stats":{"Line":0}},{"line":171,"address":[7306486,7305607],"length":1,"stats":{"Line":0}},{"line":172,"address":[8343478,8344517],"length":1,"stats":{"Line":0}},{"line":174,"address":[6932542,6931627],"length":1,"stats":{"Line":0}},{"line":175,"address":[7307614,7307044],"length":1,"stats":{"Line":0}},{"line":179,"address":[8344818],"length":1,"stats":{"Line":0}},{"line":186,"address":[7284844],"length":1,"stats":{"Line":0}},{"line":188,"address":[8354235],"length":1,"stats":{"Line":0}},{"line":189,"address":[7285442],"length":1,"stats":{"Line":0}},{"line":190,"address":[9774653],"length":1,"stats":{"Line":0}},{"line":191,"address":[8341074],"length":1,"stats":{"Line":0}},{"line":192,"address":[9774863],"length":1,"stats":{"Line":0}},{"line":193,"address":[8344692],"length":1,"stats":{"Line":0}},{"line":194,"address":[7285341],"length":1,"stats":{"Line":0}},{"line":196,"address":[6929694,6929570],"length":1,"stats":{"Line":0}},{"line":197,"address":[6930062,6929811],"length":1,"stats":{"Line":0}},{"line":198,"address":[8355662],"length":1,"stats":{"Line":0}},{"line":199,"address":[8346066],"length":1,"stats":{"Line":0}},{"line":201,"address":[8342104],"length":1,"stats":{"Line":0}},{"line":204,"address":[7330486],"length":1,"stats":{"Line":0}},{"line":205,"address":[8345567],"length":1,"stats":{"Line":0}},{"line":208,"address":[8342608,8345696,8345381],"length":1,"stats":{"Line":0}},{"line":216,"address":[8329429],"length":1,"stats":{"Line":0}},{"line":217,"address":[8333000],"length":1,"stats":{"Line":0}},{"line":220,"address":[7273649,7273704],"length":1,"stats":{"Line":0}},{"line":221,"address":[7292133,7292216],"length":1,"stats":{"Line":0}},{"line":222,"address":[8330200],"length":1,"stats":{"Line":0}},{"line":224,"address":[9764292],"length":1,"stats":{"Line":0}},{"line":225,"address":[7292967,7292874],"length":1,"stats":{"Line":0}},{"line":226,"address":[7274852],"length":1,"stats":{"Line":0}},{"line":227,"address":[7274978,7274906],"length":1,"stats":{"Line":0}},{"line":228,"address":[8334498],"length":1,"stats":{"Line":0}},{"line":229,"address":[7293398,7293481],"length":1,"stats":{"Line":0}},{"line":230,"address":[8344708,8345288],"length":1,"stats":{"Line":0}},{"line":233,"address":[8331317,8331397],"length":1,"stats":{"Line":0}},{"line":243,"address":[6919867,6918505],"length":1,"stats":{"Line":0}},{"line":244,"address":[7294484,7294571],"length":1,"stats":{"Line":0}},{"line":246,"address":[8335739],"length":1,"stats":{"Line":0}},{"line":250,"address":[7339648],"length":1,"stats":{"Line":1}},{"line":251,"address":[7339698],"length":1,"stats":{"Line":1}},{"line":252,"address":[8349181],"length":1,"stats":{"Line":3}},{"line":253,"address":[8330466,8330429,8330513],"length":1,"stats":{"Line":3}},{"line":254,"address":[7438504],"length":1,"stats":{"Line":1}},{"line":259,"address":[8348896],"length":1,"stats":{"Line":1}},{"line":260,"address":[8348917],"length":1,"stats":{"Line":1}},{"line":263,"address":[7279872],"length":1,"stats":{"Line":1}},{"line":264,"address":[7298127],"length":1,"stats":{"Line":1}},{"line":265,"address":[8349391],"length":1,"stats":{"Line":1}},{"line":266,"address":[6923902],"length":1,"stats":{"Line":1}},{"line":267,"address":[7337821],"length":1,"stats":{"Line":1}},{"line":268,"address":[8336236],"length":1,"stats":{"Line":1}},{"line":269,"address":[8339691],"length":1,"stats":{"Line":1}},{"line":270,"address":[8336330],"length":1,"stats":{"Line":1}},{"line":271,"address":[8336377],"length":1,"stats":{"Line":1}},{"line":272,"address":[8336424],"length":1,"stats":{"Line":1}},{"line":273,"address":[6924228],"length":1,"stats":{"Line":1}},{"line":274,"address":[6924272],"length":1,"stats":{"Line":1}},{"line":276,"address":[7298736],"length":1,"stats":{"Line":1}},{"line":277,"address":[8349900],"length":1,"stats":{"Line":1}},{"line":278,"address":[8340056],"length":1,"stats":{"Line":1}},{"line":279,"address":[8336695],"length":1,"stats":{"Line":1}},{"line":280,"address":[8340150],"length":1,"stats":{"Line":1}},{"line":281,"address":[7298965],"length":1,"stats":{"Line":1}},{"line":282,"address":[7338468],"length":1,"stats":{"Line":1}},{"line":283,"address":[8336883],"length":1,"stats":{"Line":1}},{"line":284,"address":[7338562],"length":1,"stats":{"Line":1}},{"line":285,"address":[8336977],"length":1,"stats":{"Line":1}}],"covered":40,"coverable":130},{"path":["/","home","dio","knowledge-rs","tests","cache_modes.rs"],"content":"use knowledge_rs::graph::KnowledgeGraph;\nuse knowledge_rs::utils::cache::{self, CacheMode};\nuse std::fs::{self, File};\nuse std::io::Write;\nuse std::path::{Path, PathBuf};\nuse std::thread;\nuse std::time::Duration;\n\nfn write_file(path: \u0026Path, content: \u0026str) {\n    if let Some(parent) = path.parent() { let _ = fs::create_dir_all(parent); }\n    let mut f = File::create(path).unwrap();\n    f.write_all(content.as_bytes()).unwrap();\n    f.flush().unwrap();\n}\n\nfn read_cache_meta_len(root: \u0026Path, rel: \u0026str) -\u003e Option\u003c(u64, u64)\u003e {\n    let cache = cache::load_cache(root)?;\n    let key = root.join(rel);\n    let entry = cache.entries.get(\u0026key)?;\n    Some((entry.meta.mtime, entry.meta.len))\n}\n\nfn count_cache_entries(root: \u0026Path) -\u003e usize {\n    cache::load_cache(root).map(|c| c.entries.len()).unwrap_or(0)\n}\n\nfn make_proj(tmp: \u0026Path) -\u003e PathBuf {\n    let root = tmp.join(\"proj\");\n    // minimal Rust sources\n    write_file(\u0026root.join(\"src/lib.rs\"), \"pub fn a() {}\\npub mod m;\\n\");\n    write_file(\u0026root.join(\"src/m.rs\"), \"pub fn b() {}\\n\");\n    root\n}\n\n#[test]\nfn cache_mode_use_detects_changes_and_prunes_removed() {\n    let tmp = tempfile::tempdir().unwrap();\n    let root = make_proj(tmp.path());\n\n    // First build: creates cache with 2 files\n    let g1 = KnowledgeGraph::build_from_directory_with_cache(\u0026root, CacheMode::Use).unwrap();\n    assert!(g1.files.len() \u003e= 2);\n    assert_eq!(count_cache_entries(\u0026root), 2);\n\n    // Record meta of m.rs\n    let m1 = read_cache_meta_len(\u0026root, \"src/m.rs\").unwrap();\n\n    // Touch change in m.rs (ensure mtime changes)\n    thread::sleep(Duration::from_millis(1100));\n    write_file(\u0026root.join(\"src/m.rs\"), \"pub fn b() {}\\npub fn c() {}\\n\");\n\n    // Second build with Use should reuse lib.rs and reparse m.rs\n    let _g2 = KnowledgeGraph::build_from_directory_with_cache(\u0026root, CacheMode::Use).unwrap();\n    let m2 = read_cache_meta_len(\u0026root, \"src/m.rs\").unwrap();\n    assert_ne!(m1, m2, \"cache entry for modified file should update\");\n    assert_eq!(count_cache_entries(\u0026root), 2);\n\n    // Remove m.rs; build again should prune\n    fs::remove_file(root.join(\"src/m.rs\")).unwrap();\n    let _g3 = KnowledgeGraph::build_from_directory_with_cache(\u0026root, CacheMode::Use).unwrap();\n    assert_eq!(count_cache_entries(\u0026root), 1);\n}\n\n#[test]\nfn cache_mode_ignore_rebuilds_without_reuse() {\n    let tmp = tempfile::tempdir().unwrap();\n    let root = make_proj(tmp.path());\n\n    // Seed cache by a normal build\n    let _ = KnowledgeGraph::build_from_directory_with_cache(\u0026root, CacheMode::Use).unwrap();\n    let before = read_cache_meta_len(\u0026root, \"src/m.rs\").unwrap();\n\n    thread::sleep(Duration::from_millis(1100));\n    // Build with Ignore even if file unchanged should still parse and rewrite cache (mtime may or may not change depending on FS; ensure len change)\n    write_file(\u0026root.join(\"src/lib.rs\"), \"pub fn a() {}\\npub mod m;\\npub fn z() {}\\n\");\n    let _ = KnowledgeGraph::build_from_directory_with_cache(\u0026root, CacheMode::Ignore).unwrap();\n    let after = read_cache_meta_len(\u0026root, \"src/m.rs\").unwrap();\n    // m.rs unchanged so meta can be equal; ensure entries count preserved and lib.rs updated len\n    assert_eq!(count_cache_entries(\u0026root), 2);\n    let lib = read_cache_meta_len(\u0026root, \"src/lib.rs\").unwrap();\n    assert!(lib.1 \u003e 0);\n    assert!(before.1 \u003e 0);\n    // just sanity check access\n    let _ = after;\n}\n\n#[test]\nfn cache_mode_rebuild_clears_cache_file() {\n    let tmp = tempfile::tempdir().unwrap();\n    let root = make_proj(tmp.path());\n\n    let _ = KnowledgeGraph::build_from_directory_with_cache(\u0026root, CacheMode::Use).unwrap();\n    assert_eq!(count_cache_entries(\u0026root), 2);\n\n    // Rebuild should remove old cache then recreate\n    cache::clear_cache(\u0026root);\n    assert_eq!(count_cache_entries(\u0026root), 0);\n    let _ = KnowledgeGraph::build_from_directory_with_cache(\u0026root, CacheMode::Rebuild).unwrap();\n    assert_eq!(count_cache_entries(\u0026root), 2);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","cli_cache_modes.rs"],"content":"use assert_cmd::prelude::*;\nuse std::fs;\nuse std::io::Write;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse tempfile::tempdir;\n\n#[test]\nfn cli_build_cache_modes_succeed() {\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    // Minimal crate\n    write_file(\u0026src.join(\"lib.rs\"), r#\"\n        pub fn f() {}\n    \"#);\n\n    let json = root.join(\"graph.json\");\n\n    // Default (Use cache)\n    let mut use_cache = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    use_cache.arg(\"build\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--json\").arg(\u0026json);\n    use_cache.assert().success();\n    assert!(json.exists());\n\n    // Rebuild\n    let mut rebuild = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    rebuild.arg(\"build\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--json\").arg(\u0026json)\n        .arg(\"--rebuild\");\n    rebuild.assert().success();\n    assert!(json.exists());\n\n    // No-cache\n    let mut no_cache = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    no_cache.arg(\"build\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--json\").arg(\u0026json)\n        .arg(\"--no-cache\");\n    no_cache.assert().success();\n    assert!(json.exists());\n}\n\nfn write_file(path: \u0026PathBuf, content: \u0026str) {\n    let mut f = fs::File::create(path).unwrap();\n    f.write_all(content.as_bytes()).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","cli_outputs.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::fs;\nuse std::io::Write;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse tempfile::tempdir;\n\n#[test]\nfn cli_build_produces_dot_and_json_and_hubs_query_works() {\n    // Arrange: temp project with two files and a simple call relationship\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    write_file(\u0026src.join(\"lib.rs\"), r#\"\n        pub mod a;\n        pub fn top() {}\n    \"#);\n    write_file(\u0026src.join(\"a.rs\"), r#\"\n        use crate::top;\n        pub fn child() { top(); }\n    \"#);\n\n    // Act: run build with dot and json outputs\n    let mut cmd = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    cmd.arg(\"build\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--json\").arg(root.join(\"graph.json\"))\n        .arg(\"--dot\").arg(root.join(\"graph.dot\"));\n    cmd.assert().success();\n\n    // Assert: outputs exist and are non-empty\n    let json_path = root.join(\"graph.json\");\n    let dot_path = root.join(\"graph.dot\");\n    assert!(json_path.exists());\n    assert!(dot_path.exists());\n    assert!(fs::metadata(\u0026json_path).unwrap().len() \u003e 0);\n    assert!(fs::metadata(\u0026dot_path).unwrap().len() \u003e 0);\n\n    // Act: run hubs query on saved graph\n    let mut q = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    q.arg(\"query\").arg(\"hubs\")\n        .arg(\"--graph\").arg(\u0026json_path)\n        .arg(\"--metric\").arg(\"total\")\n        .arg(\"--top\").arg(\"5\")\n        .arg(\"--format\").arg(\"json\");\n    q.assert().success().stdout(predicate::str::contains(\"[\"));\n}\n\nfn write_file(path: \u0026PathBuf, content: \u0026str) {\n    let mut f = fs::File::create(path).unwrap();\n    f.write_all(content.as_bytes()).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","cli_smoke.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::fs;\nuse std::io::Write;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse tempfile::tempdir;\n\n// Bottom-up: simple CLI smoke test for build and a query\n#[test]\nfn cli_build_and_connected_files_smoke() {\n    // Arrange: temp project with two files and a simple import\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    // Create lib.rs and a.rs\n    write_file(\u0026src.join(\"lib.rs\"), r#\"\n        pub mod a;\n        pub fn top() {}\n    \"#);\n    write_file(\u0026src.join(\"a.rs\"), r#\"\n        use crate::top;\n        pub fn child() { top(); }\n    \"#);\n\n    // Act: run build command\n    let mut cmd = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    cmd.arg(\"build\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--json\").arg(root.join(\"graph.json\"));\n    cmd.assert().success();\n\n    // Assert: graph file exists and contains the module\n    let json_path = root.join(\"graph.json\");\n    assert!(json_path.exists());\n    let content = fs::read_to_string(\u0026json_path).unwrap();\n    assert!(content.contains(\"lib.rs\"));\n\n    // Act: run query connected-files\n    let mut cmd2 = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    cmd2.arg(\"query\").arg(\"connected-files\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--file\").arg(src.join(\"a.rs\"))\n        .arg(\"--format\").arg(\"json\");\n    cmd2.assert().success().stdout(predicate::str::contains(\"lib.rs\"));\n}\n\nfn write_file(path: \u0026PathBuf, content: \u0026str) {\n    let mut f = fs::File::create(path).unwrap();\n    f.write_all(content.as_bytes()).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","cli_svg_and_queries.rs"],"content":"use assert_cmd::prelude::*;\nuse predicates::prelude::*;\nuse std::fs;\nuse std::io::Write;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse tempfile::tempdir;\n\n#[test]\nfn cli_build_svg_when_graphviz_available() {\n    // Only run if Graphviz dot is available\n    let dot_available = Command::new(\"dot\").arg(\"-V\").output().is_ok();\n    if !dot_available {\n        eprintln!(\"Skipping SVG test: graphviz 'dot' not found\");\n        return;\n    }\n\n#[test]\nfn cli_query_module_centrality_trait_impls_and_cycles() {\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    // Create two modules and a trait impl to exercise the queries\n    write_file(\u0026src.join(\"lib.rs\"), r#\"\n        mod m1; mod m2;\n        pub use m1::X;\n        pub trait T { fn f(\u0026self) {} }\n    \"#);\n    write_file(\u0026src.join(\"m1.rs\"), r#\"\n        use crate::T;\n        pub struct X;\n        impl T for X { fn f(\u0026self) {} }\n    \"#);\n    write_file(\u0026src.join(\"m2.rs\"), r#\"\n        use crate::m1::X;\n        pub fn use_x() { let _ = X; }\n    \"#);\n\n    // Build graph JSON\n    let mut build = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    build.arg(\"build\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--json\").arg(root.join(\"graph.json\"));\n    build.assert().success();\n    let graph_path = root.join(\"graph.json\");\n\n    // module-centrality: expect some output rows\n    let mut mc = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    mc.arg(\"query\").arg(\"module-centrality\")\n        .arg(\"--graph\").arg(\u0026graph_path)\n        .arg(\"--metric\").arg(\"total\")\n        .arg(\"--top\").arg(\"5\")\n        .arg(\"--format\").arg(\"json\");\n    mc.assert().success().stdout(predicate::str::contains(\"[\"));\n\n    // trait-impls: expect at least one row for trait T\n    let mut ti = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    ti.arg(\"query\").arg(\"trait-impls\")\n        .arg(\"--graph\").arg(\u0026graph_path)\n        .arg(\"--trait\").arg(\"T\")\n        .arg(\"--format\").arg(\"json\");\n    ti.assert().success().stdout(predicate::str::contains(\"X\"));\n\n    // cycles: command should succeed; output may be empty which is acceptable\n    let mut cy = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    cy.arg(\"query\").arg(\"cycles\")\n        .arg(\"--graph\").arg(\u0026graph_path)\n        .arg(\"--format\").arg(\"json\");\n    cy.assert().success().stdout(predicate::str::contains(\"[\"));\n}\n\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    write_file(\u0026src.join(\"lib.rs\"), r#\"\n        pub fn top() {}\n    \"#);\n\n    let mut cmd = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    cmd.arg(\"build\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--svg\").arg(root.join(\"graph.svg\"));\n    cmd.assert().success();\n\n    let svg_path = root.join(\"graph.svg\");\n    assert!(svg_path.exists());\n    assert!(fs::metadata(\u0026svg_path).unwrap().len() \u003e 0);\n}\n\n#[test]\nfn cli_query_path_and_function_usage() {\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    write_file(\u0026src.join(\"lib.rs\"), r#\"\n        mod a; mod b;\n        pub use a::foo;\n    \"#);\n    write_file(\u0026src.join(\"a.rs\"), r#\"\n        pub fn foo() {}\n    \"#);\n    write_file(\u0026src.join(\"b.rs\"), r#\"\n        pub fn bar() { crate::a::foo(); }\n    \"#);\n\n    // Build graph JSON to speed queries\n    let mut build = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    build.arg(\"build\")\n        .arg(\"--path\").arg(root)\n        .arg(\"--json\").arg(root.join(\"graph.json\"));\n    build.assert().success();\n    let graph_path = root.join(\"graph.json\");\n\n    // path query: expect a path from b.rs to a.rs\n    let mut pathq = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    pathq.arg(\"query\").arg(\"path\")\n        .arg(\"--graph\").arg(\u0026graph_path)\n        .arg(\"--from\").arg(src.join(\"b.rs\"))\n        .arg(\"--to\").arg(src.join(\"a.rs\"))\n        .arg(\"--format\").arg(\"json\");\n    pathq.assert().success().stdout(predicate::str::contains(\"a.rs\"));\n\n    // function-usage: callers of foo should include b.rs\n    let mut funcq = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    funcq.arg(\"query\").arg(\"function-usage\")\n        .arg(\"--graph\").arg(\u0026graph_path)\n        .arg(\"--function\").arg(\"foo\")\n        .arg(\"--direction\").arg(\"callers\")\n        .arg(\"--format\").arg(\"json\");\n    funcq.assert().success().stdout(predicate::str::contains(\"b.rs\"));\n}\n\nfn write_file(path: \u0026PathBuf, content: \u0026str) {\n    let mut f = fs::File::create(path).unwrap();\n    f.write_all(content.as_bytes()).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","config_loading.rs"],"content":"use knowledge_rs::utils::config::{self};\nuse std::fs;\nuse std::path::Path;\n\nfn write(path: \u0026Path, content: \u0026str) {\n    if let Some(parent) = path.parent() { let _ = fs::create_dir_all(parent); }\n    fs::write(path, content).unwrap();\n}\n\n#[test]\nfn parses_full_config_file() {\n    let tmp = tempfile::tempdir().unwrap();\n    let cfg_path = tmp.path().join(\"knowledge-rs.toml\");\n    let data = r#\"\n[dot]\nclusters = true\nlegend = false\ntheme = \"dark\"\nrankdir = \"TB\"\nsplines = \"ortho\"\nrounded = true\n\n[svg]\ninteractive = true\n\n[query]\ndefault_format = \"json\"\n\"#;\n    write(\u0026cfg_path, data);\n\n    let cfg = config::load_config_at(\u0026cfg_path).expect(\"config parsed\");\n    assert_eq!(cfg.dot.as_ref().and_then(|d| d.clusters), Some(true));\n    assert_eq!(cfg.dot.as_ref().and_then(|d| d.legend), Some(false));\n    assert_eq!(cfg.dot.as_ref().and_then(|d| d.theme.as_ref()).map(|s| s.as_str()), Some(\"dark\"));\n    assert_eq!(cfg.dot.as_ref().and_then(|d| d.rankdir.as_ref()).map(|s| s.as_str()), Some(\"TB\"));\n    assert_eq!(cfg.dot.as_ref().and_then(|d| d.splines.as_ref()).map(|s| s.as_str()), Some(\"ortho\"));\n    assert_eq!(cfg.dot.as_ref().and_then(|d| d.rounded), Some(true));\n\n    assert_eq!(cfg.svg.as_ref().and_then(|s| s.interactive), Some(true));\n    assert_eq!(cfg.query.as_ref().and_then(|q| q.default_format.as_ref()).map(|s| s.as_str()), Some(\"json\"));\n}\n\n#[test]\nfn load_config_near_looks_for_default_name() {\n    let tmp = tempfile::tempdir().unwrap();\n    // create default location\n    let default_path = tmp.path().join(\"knowledge-rs.toml\");\n    write(\u0026default_path, \"[query]\\ndefault_format = 'text'\\n\");\n\n    let cfg = config::load_config_near(tmp.path()).expect(\"found default config\");\n    assert_eq!(cfg.query.and_then(|q| q.default_format), Some(\"text\".to_string()));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","ignore_patterns.rs"],"content":"use std::fs;\nuse std::path::PathBuf;\n\nuse knowledge_rs::graph::KnowledgeGraph;\n\nfn make_temp_project(entries: Vec\u003c(\u0026str, \u0026str)\u003e) -\u003e PathBuf {\n    let base = std::env::temp_dir()\n        .join(format!(\n            \"knowledge_rs_ignore_{}_{}\",\n            std::process::id(),\n            std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_nanos()\n        ));\n    fs::create_dir_all(base.join(\"src\")).unwrap();\n    for (rel, body) in entries {\n        let p = base.join(rel);\n        if let Some(par) = p.parent() { fs::create_dir_all(par).unwrap(); }\n\n#[test]\nfn multiple_ignore_files_with_negations() {\n    // Root ignores *.rs but subdir re-includes a specific file via negation\n    let root = make_temp_project(vec![\n        (\"src/.gitignore\", \"*.rs\\n!lib.rs\\n\"),\n        (\"src/a/.ignore\", \"*.rs\\n!keep.rs\\n\"),\n        (\"src/lib.rs\", \"mod a; pub fn root() {}\"),\n        (\"src/a/keep.rs\", \"pub fn k() {}\"),\n        (\"src/a/gone.rs\", \"pub fn g() {}\"),\n    ]);\n\n    let graph = KnowledgeGraph::build_from_directory(\u0026root.join(\"src\")).expect(\"build graph\");\n    // lib.rs is re-included by root-level negation\n    assert!(graph.files.keys().any(|p| p.ends_with(\"lib.rs\")));\n    // keep.rs is re-included by subdir negation\n    assert!(graph.files.keys().any(|p| p.ends_with(\"a/keep.rs\")));\n    // gone.rs remains ignored\n    assert!(!graph.files.keys().any(|p| p.ends_with(\"a/gone.rs\")));\n}\n        fs::write(p, body).unwrap();\n    }\n    base\n}\n\n#[test]\nfn ignores_files_listed_in_gitignore() {\n    let root = make_temp_project(vec![\n        (\"src/.ignore\", \"ignored.rs\\n\"),\n        (\"src/lib.rs\", \"mod kept; mod ignored; pub fn root() { kept::k(); }\"),\n        (\"src/kept.rs\", \"pub fn k() {}\"),\n        (\"src/ignored.rs\", \"pub fn x() {}\"),\n    ]);\n\n    // Build graph from src; the ignored file should not be parsed or present\n    let graph = KnowledgeGraph::build_from_directory(\u0026root.join(\"src\")).expect(\"build graph\");\n\n    // Ensure kept.rs exists\n    assert!(graph.files.keys().any(|p| p.ends_with(\"kept.rs\")));\n    // Ensure ignored.rs is not present due to .gitignore\n    assert!(!graph.files.keys().any(|p| p.ends_with(\"ignored.rs\")));\n}\n\n#[test]\nfn nested_ignore_file_in_subdir() {\n    let root = make_temp_project(vec![\n        (\"src/.ignore\", \"\"),\n        (\"src/a/.ignore\", \"skip.rs\\n\"),\n        (\"src/a/keep.rs\", \"pub fn k() {}\"),\n        (\"src/a/skip.rs\", \"pub fn s() {}\"),\n        (\"src/lib.rs\", \"pub fn root() {}\"),\n    ]);\n\n    let graph = KnowledgeGraph::build_from_directory(\u0026root.join(\"src\")).expect(\"build graph\");\n    assert!(graph.files.keys().any(|p| p.ends_with(\"a/keep.rs\")));\n    assert!(!graph.files.keys().any(|p| p.ends_with(\"a/skip.rs\")));\n}\n\n#[test]\nfn gitignore_negation_pattern() {\n    let root = make_temp_project(vec![\n        (\"src/.gitignore\", \"*.rs\\n!keep.rs\\n\"),\n        (\"src/keep.rs\", \"pub fn k() {}\"),\n        (\"src/gone.rs\", \"pub fn g() {}\"),\n        (\"src/lib.rs\", \"pub fn root() {}\"),\n    ]);\n\n    let graph = KnowledgeGraph::build_from_directory(\u0026root.join(\"src\")).expect(\"build graph\");\n    assert!(graph.files.keys().any(|p| p.ends_with(\"keep.rs\")));\n    assert!(!graph.files.keys().any(|p| p.ends_with(\"gone.rs\")));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","integration_queries.rs"],"content":"use std::fs;\nuse std::path::PathBuf;\n\nuse knowledge_rs::graph::KnowledgeGraph;\nuse knowledge_rs::query::{ConnectedFilesQuery, Query, CycleDetectionQuery};\n\nfn make_temp_project(contents: Vec\u003c(\u0026str, \u0026str)\u003e) -\u003e PathBuf {\n    let base = std::env::temp_dir()\n        .join(format!(\"knowledge_rs_it_{}_{}\", std::process::id(), std::time::SystemTime::now().elapsed().unwrap().as_nanos()));\n    fs::create_dir_all(base.join(\"src\")).unwrap();\n    for (path, body) in contents {\n        let p = base.join(path);\n        if let Some(parent) = p.parent() { fs::create_dir_all(parent).unwrap(); }\n        fs::write(p, body).unwrap();\n    }\n    base\n}\n\n#[test]\nfn integration_connected_files() {\n    let root = make_temp_project(vec![\n        (\"src/lib.rs\", r#\"\n            mod a;\n            mod b;\n            use crate::a::foo;\n            pub fn root() { foo(); }\n        \"#),\n        (\"src/a.rs\", r#\"\n            pub fn foo() {}\n        \"#),\n        (\"src/b.rs\", r#\"\n            pub fn bar() { crate::a::foo(); }\n        \"#),\n    ]);\n\n    let graph = KnowledgeGraph::build_from_directory(\u0026root.join(\"src\")).expect(\"build graph\");\n\n    // Connected files for a.rs should include lib.rs due to import use from lib\n    let connected = ConnectedFilesQuery::new(root.join(\"src/a.rs\")).run(\u0026graph);\n    assert!(connected.contains(\u0026root.join(\"src/lib.rs\")));\n}\n\n#[test]\n#[ignore = \"Call-graph extraction is simplistic and may not detect cycles from source yet; enable when improved.\"]\nfn integration_cycle_detection_simple() {\n    let root = make_temp_project(vec![\n        (\"src/lib.rs\", r#\"\n            mod a;\n            mod b;\n        \"#),\n        (\"src/a.rs\", r#\"\n            pub fn foo() { crate::b::bar(); }\n        \"#),\n        (\"src/b.rs\", r#\"\n            pub fn bar() { crate::a::foo(); }\n        \"#),\n    ]);\n\n    let graph = KnowledgeGraph::build_from_directory(\u0026root.join(\"src\")).expect(\"build graph\");\n    let cycles = CycleDetectionQuery::new().run(\u0026graph);\n    assert!(cycles.iter().any(|cyc| cyc.len() \u003e= 2));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","parser_props.rs"],"content":"use proptest::prelude::*;\nuse knowledge_rs::parser::RustParser;\n\n// Bottom-up property-based tests: parser robustness on arbitrary inputs\nproptest! {\n    // The parser should never panic on arbitrary UTF-8 input\n    #[test]\n    fn parser_never_panics_on_arbitrary_input(s in \".*\") {\n        let parser = RustParser::new();\n        let _ = parser.parse_file(\u0026s, std::path::Path::new(\"/prop.rs\"));\n        // No assertion needed: the test passes if it doesn't panic\n    }\n\n    // Basic invariant: item/import counts are finite and consistent\n    #[test]\n    fn parser_produces_reasonable_counts(s in \".*\") {\n        let parser = RustParser::new();\n        if let Ok(node) = parser.parse_file(\u0026s, std::path::Path::new(\"/prop.rs\")) {\n            // Items and imports should be non-negative (Vec len) and not overflow typical bounds\n            prop_assert!(node.items.len() \u003c= s.len() + 1);\n            prop_assert!(node.imports.len() \u003c= s.len() + 1);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","utils_tests.rs"],"content":"use knowledge_rs::utils::{file_walker, table};\nuse std::fs;\nuse std::io::Write;\nuse tempfile::tempdir;\n\n#[test]\nfn table_renderer_produces_expected_grid() {\n    let headers = [\"A\", \"B\"];\n    let rows = vec![vec![\"x\".into(), \"y\".into()], vec![\"long\".into(), \"z\".into()]];\n    let out = table::render(\u0026headers, \u0026rows);\n    assert!(out.starts_with(\"+\"));\n    assert!(out.contains(\"| A\"));\n    assert!(out.contains(\"long\"));\n}\n\n#[test]\nfn file_walker_respects_ignore_and_no_ignore() {\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    // Create files\n    write(\u0026src.join(\"lib.rs\"), \"pub mod hidden;\\n\");\n    write(\u0026src.join(\"hidden.rs\"), \"pub fn f() {}\\n\");\n\n    // Add .gitignore to hide hidden.rs\n    write(\u0026root.join(\".gitignore\"), \"src/hidden.rs\\n\");\n\n    // Default: should not see hidden.rs\n    let files = file_walker::rust_files(root.to_str().unwrap());\n    let listed: Vec\u003c_\u003e = files.iter().map(|s| s.ends_with(\"lib.rs\") || s.ends_with(\"hidden.rs\")).collect();\n    assert!(listed.iter().any(|\u0026b| b));\n    assert!(!files.iter().any(|s| s.ends_with(\"hidden.rs\")));\n\n    // no_ignore=true: should include hidden.rs\n    let files_all = file_walker::rust_files_with_options(root.to_str().unwrap(), true);\n    assert!(files_all.iter().any(|s| s.ends_with(\"hidden.rs\")));\n}\n\nfn write(path: \u0026std::path::Path, s: \u0026str) {\n    let mut f = fs::File::create(path).unwrap();\n    f.write_all(s.as_bytes()).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","dio","knowledge-rs","tests","visualization_dot.rs"],"content":"use assert_cmd::prelude::*;\nuse std::fs;\nuse std::io::Write;\nuse std::process::Command;\nuse tempfile::tempdir;\n\n#[test]\nfn dot_generator_clusters_and_flat_themes() {\n    let dir = tempdir().unwrap();\n    let root = dir.path();\n    let src = root.join(\"src\");\n    fs::create_dir_all(\u0026src).unwrap();\n\n    // Minimal multi-file crate to trigger clusters/children\n    write_file(\u0026src.join(\"lib.rs\"), r#\"\n        mod m;\n        pub struct S; pub enum E { A }\n        pub trait T { fn f(\u0026self); }\n    \"#);\n    write_file(\u0026src.join(\"m.rs\"), r#\"\n        pub fn foo() {}\n    \"#);\n\n    // Build a graph JSON then load it via CLI to ensure consistency\n    let graph_json = root.join(\"graph.json\");\n    let mut build = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    build.arg(\"build\").arg(\"--path\").arg(\u0026root).arg(\"--json\").arg(\u0026graph_json);\n    build.assert().success();\n\n    // Use the CLI to emit DOT with clusters + legend + dark theme\n    let dot_dark = root.join(\"dark.dot\");\n    let mut build_dot_dark = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    build_dot_dark\n        .arg(\"build\").arg(\"--path\").arg(\u0026root)\n        .arg(\"--dot\").arg(\u0026dot_dark)\n        .arg(\"--dot-clusters\").arg(\"on\")\n        .arg(\"--dot-legend\").arg(\"on\")\n        .arg(\"--dot-theme\").arg(\"dark\")\n        .arg(\"--dot-rankdir\").arg(\"TB\")\n        .arg(\"--dot-splines\").arg(\"polyline\")\n        .arg(\"--dot-rounded\").arg(\"off\");\n    build_dot_dark.assert().success();\n\n    let dot_dark_str = fs::read_to_string(\u0026dot_dark).unwrap();\n    assert!(dot_dark_str.contains(\"digraph KnowledgeRS\"));\n    assert!(dot_dark_str.contains(\"rankdir=TB\"));\n    assert!(dot_dark_str.contains(\"splines=polyline\"));\n    assert!(dot_dark_str.contains(\"subgraph \\\"cluster_\")); // clusters enabled\n    assert!(dot_dark_str.contains(\"label=\\\"Legend\\\"\"));  // legend enabled\n\n    // Emit DOT without clusters, light theme defaults\n    let dot_light = root.join(\"light.dot\");\n    let mut build_dot_light = Command::cargo_bin(\"knowledge-rs\").unwrap();\n    build_dot_light\n        .arg(\"build\").arg(\"--path\").arg(\u0026root)\n        .arg(\"--dot\").arg(\u0026dot_light)\n        .arg(\"--dot-clusters\").arg(\"off\")\n        .arg(\"--dot-legend\").arg(\"off\");\n    build_dot_light.assert().success();\n\n    let dot_light_str = fs::read_to_string(\u0026dot_light).unwrap();\n    assert!(dot_light_str.contains(\"rankdir=LR\")); // default\n    assert!(!dot_light_str.contains(\"cluster_\")); // no clusters\n}\n\nfn write_file(path: \u0026std::path::Path, content: \u0026str) {\n    let mut f = fs::File::create(path).unwrap();\n    f.write_all(content.as_bytes()).unwrap();\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>